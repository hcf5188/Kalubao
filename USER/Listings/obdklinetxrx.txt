; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\obdklinetxrx.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=..\obj\obdklinetxrx.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\OBD -I..\SYSTEM -I..\USER -I..\LIB\inc -I..\UCOSII\CONFIG -I..\UCOSII\PORT -I..\UCOSII\CORE -I..\HAEDWARE -I..\GPS -I..\CDMA -I..\DEAL -I..\USB\CONFIG -I..\USB\STM32_USB-FS-Device_Driver\inc -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.2.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\obdklinetxrx.crf ..\OBD\OBDKLineTxRx.c]
                          THUMB

                          AREA ||i.KLineFastInit||, CODE, READONLY, ALIGN=2

                  KLineFastInit PROC
;;;11     
;;;12     void KLineFastInit(void)
000000  b508              PUSH     {r3,lr}
;;;13     {
;;;14     	GPIO_InitTypeDef GPIO_InitStructure;
;;;15     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000002  2003              MOVS     r0,#3
000004  f88d0002          STRB     r0,[sp,#2]
;;;16     	
;;;17     	//TX IO Output
;;;18     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_KWP_TX;
000008  f44f6080          MOV      r0,#0x400
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;19       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;20       	GPIO_Init(GPIOB, &GPIO_InitStructure);
000016  4669              MOV      r1,sp
000018  4818              LDR      r0,|L1.124|
00001a  f7fffffe          BL       GPIO_Init
;;;21     
;;;22     	//T Idle 拉高300ms
;;;23     	GPIO_SetBits(GPIOB,GPIO_Pin_KWP_TX);
00001e  f44f6180          MOV      r1,#0x400
000022  4816              LDR      r0,|L1.124|
000024  f7fffffe          BL       GPIO_SetBits
;;;24     	OSTimeDlyHMSM(0,0,0,500);
000028  f44f73fa          MOV      r3,#0x1f4
00002c  2200              MOVS     r2,#0
00002e  4611              MOV      r1,r2
000030  4610              MOV      r0,r2
000032  f7fffffe          BL       OSTimeDlyHMSM
;;;25     
;;;26     	// 拉低25ms
;;;27     	GPIO_ResetBits(GPIOB,GPIO_Pin_KWP_TX);
000036  f44f6180          MOV      r1,#0x400
00003a  4810              LDR      r0,|L1.124|
00003c  f7fffffe          BL       GPIO_ResetBits
;;;28     	OSTimeDlyHMSM(0,0,0,25);
000040  2319              MOVS     r3,#0x19
000042  2200              MOVS     r2,#0
000044  4611              MOV      r1,r2
000046  4610              MOV      r0,r2
000048  f7fffffe          BL       OSTimeDlyHMSM
;;;29     
;;;30     	//拉高25ms
;;;31     	GPIO_SetBits(GPIOB,GPIO_Pin_KWP_TX);
00004c  f44f6180          MOV      r1,#0x400
000050  480a              LDR      r0,|L1.124|
000052  f7fffffe          BL       GPIO_SetBits
;;;32     	OSTimeDlyHMSM(0,0,0,25);
000056  2319              MOVS     r3,#0x19
000058  2200              MOVS     r2,#0
00005a  4611              MOV      r1,r2
00005c  4610              MOV      r0,r2
00005e  f7fffffe          BL       OSTimeDlyHMSM
;;;33     	//USART3  TX 转为收发器
;;;34     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_KWP_TX;
000062  f44f6080          MOV      r0,#0x400
000066  f8ad0000          STRH     r0,[sp,#0]
;;;35       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00006a  2018              MOVS     r0,#0x18
00006c  f88d0003          STRB     r0,[sp,#3]
;;;36       	GPIO_Init(GPIOB, &GPIO_InitStructure);
000070  4669              MOV      r1,sp
000072  4802              LDR      r0,|L1.124|
000074  f7fffffe          BL       GPIO_Init
;;;37     }
000078  bd08              POP      {r3,pc}
;;;38     
                          ENDP

00007a  0000              DCW      0x0000
                  |L1.124|
                          DCD      0x40010c00

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;38     
;;;39     void USART3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;40     {
;;;41     	uint8_t tmp;
;;;42     	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)//接收到数据
000002  f2405125          MOV      r1,#0x525
000006  481a              LDR      r0,|L2.112|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b148              CBZ      r0,|L2.34|
;;;43       	{
;;;44     		/* Read one byte from the receive data register */
;;;45     		tmp=USART_ReceiveData(USART3);
00000e  4818              LDR      r0,|L2.112|
000010  f7fffffe          BL       USART_ReceiveData
000014  b2c4              UXTB     r4,r0
;;;46     
;;;47     		//接收后的数据待处理----代码重构
;;;48     
;;;49     		USART_ClearITPendingBit(USART3, USART_IT_RXNE) ;
000016  f2405125          MOV      r1,#0x525
00001a  4815              LDR      r0,|L2.112|
00001c  f7fffffe          BL       USART_ClearITPendingBit
000020  e024              B        |L2.108|
                  |L2.34|
;;;50     
;;;51     	}
;;;52     	else if(USART_GetITStatus(USART3, USART_IT_TC) != RESET)//发送完毕
000022  f2406126          MOV      r1,#0x626
000026  4812              LDR      r0,|L2.112|
000028  f7fffffe          BL       USART_GetITStatus
00002c  b148              CBZ      r0,|L2.66|
;;;53     	{
;;;54     //		if(g_usart_data[u_index].tx_last!=g_usart_data[u_index].tx_used)
;;;55     //		{
;;;56     //			tmp=g_usart_data[u_index].tx_buf[g_usart_data[u_index].tx_used++];
;;;57     //			g_usart_data[u_index].tx_used&=0x01ff;
;;;58     			USART_SendData(USART3, tmp);
00002e  4621              MOV      r1,r4
000030  480f              LDR      r0,|L2.112|
000032  f7fffffe          BL       USART_SendData
;;;59     //		}else
;;;60     //		{
;;;61     //			 g_usart_data[u_index].flag_txstop=1;
;;;62     //		}
;;;63     
;;;64     		USART_ClearITPendingBit(USART3, USART_IT_TC) ;
000036  f2406126          MOV      r1,#0x626
00003a  480d              LDR      r0,|L2.112|
00003c  f7fffffe          BL       USART_ClearITPendingBit
000040  e014              B        |L2.108|
                  |L2.66|
;;;65     	}
;;;66     	else if(USART_GetITStatus(USART3, USART_IT_TXE) != RESET)//空
000042  f2407127          MOV      r1,#0x727
000046  480a              LDR      r0,|L2.112|
000048  f7fffffe          BL       USART_GetITStatus
00004c  b170              CBZ      r0,|L2.108|
;;;67     	{
;;;68     //		if(g_usart_data[u_index].tx_last!=g_usart_data[u_index].tx_used)
;;;69     //		{
;;;70     //			tmp=g_usart_data[u_index].tx_buf[g_usart_data[u_index].tx_used++];
;;;71     //			g_usart_data[u_index].tx_used&=0x01ff;
;;;72     			USART_SendData(USART3, tmp);
00004e  4621              MOV      r1,r4
000050  4807              LDR      r0,|L2.112|
000052  f7fffffe          BL       USART_SendData
;;;73     //		}
;;;74     //		else
;;;75     //		{
;;;76     //			 g_usart_data[u_index].flag_txstop=1;
;;;77     //		}
;;;78     		USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
000056  2200              MOVS     r2,#0
000058  f2407127          MOV      r1,#0x727
00005c  4804              LDR      r0,|L2.112|
00005e  f7fffffe          BL       USART_ITConfig
;;;79     		USART_ClearITPendingBit(USART3, USART_IT_TXE) ;
000062  f2407127          MOV      r1,#0x727
000066  4802              LDR      r0,|L2.112|
000068  f7fffffe          BL       USART_ClearITPendingBit
                  |L2.108|
;;;80     	}
;;;81     }
00006c  bd10              POP      {r4,pc}
;;;82     
                          ENDP

00006e  0000              DCW      0x0000
                  |L2.112|
                          DCD      0x40004800

;*** Start embedded assembler ***

#line 1 "..\\OBD\\OBDKLineTxRx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_OBDKLineTxRx_c_96cfeb63____REV16|
#line 465 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.2.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_OBDKLineTxRx_c_96cfeb63____REV16| PROC
#line 466

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_OBDKLineTxRx_c_96cfeb63____REVSH|
#line 480
|__asm___14_OBDKLineTxRx_c_96cfeb63____REVSH| PROC
#line 481

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_OBDKLineTxRx_c_96cfeb63____RRX|
#line 667
|__asm___14_OBDKLineTxRx_c_96cfeb63____RRX| PROC
#line 668

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
