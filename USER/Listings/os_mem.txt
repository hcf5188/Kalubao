; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\os_mem.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=..\obj\os_mem.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\OBD -I..\SYSTEM -I..\USER -I..\LIB\inc -I..\UCOSII\CONFIG -I..\UCOSII\PORT -I..\UCOSII\CORE -I..\HAEDWARE -I..\GPS -I..\CDMA -I..\DEAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\os_mem.crf ..\UCOSII\CORE\os_mem.c]
                          THUMB

                          AREA ||i.OSMemCreate||, CODE, READONLY, ALIGN=2

                  OSMemCreate PROC
;;;58     
;;;59     OS_MEM  *OSMemCreate (void   *addr,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;60                           INT32U  nblks,
;;;61                           INT32U  blksize,
;;;62                           INT8U  *perr)
;;;63     {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
;;;64         OS_MEM    *pmem;
;;;65         INT8U     *pblk;
;;;66         void     **plink;
;;;67         INT32U     loops;
;;;68         INT32U     i;
;;;69     #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;70         OS_CPU_SR  cpu_sr = 0u;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;71     #endif
;;;72     
;;;73     
;;;74     
;;;75     #ifdef OS_SAFETY_CRITICAL
;;;76         if (perr == (INT8U *)0) {
;;;77             OS_SAFETY_CRITICAL_EXCEPTION();
;;;78         }
;;;79     #endif
;;;80     
;;;81     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;82         if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;83             OS_SAFETY_CRITICAL_EXCEPTION();
;;;84         }
;;;85     #endif
;;;86     
;;;87     #if OS_ARG_CHK_EN > 0u
;;;88         if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
;;;89             *perr = OS_ERR_MEM_INVALID_ADDR;
;;;90             return ((OS_MEM *)0);
;;;91         }
;;;92         if (((INT32U)addr & (sizeof(void *) - 1u)) != 0u){  /* Must be pointer size aligned                */
;;;93             *perr = OS_ERR_MEM_INVALID_ADDR;
;;;94             return ((OS_MEM *)0);
;;;95         }
;;;96         if (nblks < 2u) {                                 /* Must have at least 2 blocks per partition     */
;;;97             *perr = OS_ERR_MEM_INVALID_BLKS;
;;;98             return ((OS_MEM *)0);
;;;99         }
;;;100        if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
;;;101            *perr = OS_ERR_MEM_INVALID_SIZE;
;;;102            return ((OS_MEM *)0);
;;;103        }
;;;104    #endif
;;;105        OS_ENTER_CRITICAL();
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  9000              STR      r0,[sp,#0]
;;;106        pmem = OSMemFreeList;                             /* Get next free memory partition                */
000016  4818              LDR      r0,|L1.120|
000018  6804              LDR      r4,[r0,#0]  ; OSMemFreeList
;;;107        if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
00001a  6800              LDR      r0,[r0,#0]  ; OSMemFreeList
00001c  b120              CBZ      r0,|L1.40|
;;;108            OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
00001e  4816              LDR      r0,|L1.120|
000020  6800              LDR      r0,[r0,#0]  ; OSMemFreeList
000022  6840              LDR      r0,[r0,#4]
000024  4914              LDR      r1,|L1.120|
000026  6008              STR      r0,[r1,#0]  ; OSMemFreeList
                  |L1.40|
;;;109        }
;;;110        OS_EXIT_CRITICAL();
000028  9800              LDR      r0,[sp,#0]
00002a  f7fffffe          BL       OS_CPU_SR_Restore
;;;111        if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
00002e  b92c              CBNZ     r4,|L1.60|
;;;112            *perr = OS_ERR_MEM_INVALID_PART;
000030  205a              MOVS     r0,#0x5a
000032  f88a0000          STRB     r0,[r10,#0]
;;;113            return ((OS_MEM *)0);
000036  2000              MOVS     r0,#0
                  |L1.56|
;;;114        }
;;;115        plink = (void **)addr;                            /* Create linked list of free memory blocks      */
;;;116        pblk  = (INT8U *)addr;
;;;117        loops  = nblks - 1u;
;;;118        for (i = 0u; i < loops; i++) {
;;;119            pblk +=  blksize;                             /* Point to the FOLLOWING block                  */
;;;120           *plink = (void  *)pblk;                        /* Save pointer to NEXT block in CURRENT block   */
;;;121            plink = (void **)pblk;                        /* Position to  NEXT      block                  */
;;;122        }
;;;123        *plink              = (void *)0;                  /* Last memory block points to NULL              */
;;;124        pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
;;;125        pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
;;;126        pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
;;;127        pmem->OSMemNBlks    = nblks;
;;;128        pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
;;;129        *perr               = OS_ERR_NONE;
;;;130        return (pmem);
;;;131    }
000038  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.60|
00003c  46a8              MOV      r8,r5                 ;115
00003e  462e              MOV      r6,r5                 ;116
000040  1e78              SUBS     r0,r7,#1              ;117
000042  9001              STR      r0,[sp,#4]            ;117
000044  f04f0b00          MOV      r11,#0                ;118
000048  e005              B        |L1.86|
                  |L1.74|
00004a  444e              ADD      r6,r6,r9              ;119
00004c  f8c86000          STR      r6,[r8,#0]            ;120
000050  46b0              MOV      r8,r6                 ;121
000052  f10b0b01          ADD      r11,r11,#1            ;118
                  |L1.86|
000056  9801              LDR      r0,[sp,#4]            ;118
000058  4583              CMP      r11,r0                ;118
00005a  d3f6              BCC      |L1.74|
00005c  2000              MOVS     r0,#0                 ;123
00005e  f8c80000          STR      r0,[r8,#0]            ;123
000062  6025              STR      r5,[r4,#0]            ;124
000064  6065              STR      r5,[r4,#4]            ;125
000066  6127              STR      r7,[r4,#0x10]         ;126
000068  60e7              STR      r7,[r4,#0xc]          ;127
00006a  f8c49008          STR      r9,[r4,#8]            ;128
00006e  f88a0000          STRB     r0,[r10,#0]           ;129
000072  4620              MOV      r0,r4                 ;130
000074  e7e0              B        |L1.56|
;;;132    /*$PAGE*/
                          ENDP

000076  0000              DCW      0x0000
                  |L1.120|
                          DCD      OSMemFreeList

                          AREA ||i.OSMemGet||, CODE, READONLY, ALIGN=1

                  OSMemGet PROC
;;;152    
;;;153    void  *OSMemGet (OS_MEM  *pmem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;154                     INT8U   *perr)
;;;155    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;156        void      *pblk;
;;;157    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;158        OS_CPU_SR  cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;159    #endif
;;;160    
;;;161    
;;;162    
;;;163    #ifdef OS_SAFETY_CRITICAL
;;;164        if (perr == (INT8U *)0) {
;;;165            OS_SAFETY_CRITICAL_EXCEPTION();
;;;166        }
;;;167    #endif
;;;168    
;;;169    #if OS_ARG_CHK_EN > 0u
;;;170        if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
;;;171            *perr = OS_ERR_MEM_INVALID_PMEM;
;;;172            return ((void *)0);
;;;173        }
;;;174    #endif
;;;175        OS_ENTER_CRITICAL();
00000a  f7fffffe          BL       OS_CPU_SR_Save
00000e  4607              MOV      r7,r0
;;;176        if (pmem->OSMemNFree > 0u) {                      /* See if there are any free memory blocks       */
000010  6920              LDR      r0,[r4,#0x10]
000012  b168              CBZ      r0,|L2.48|
;;;177            pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
000014  6866              LDR      r6,[r4,#4]
;;;178            pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
000016  6830              LDR      r0,[r6,#0]
000018  6060              STR      r0,[r4,#4]
;;;179            pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
00001a  6920              LDR      r0,[r4,#0x10]
00001c  1e40              SUBS     r0,r0,#1
00001e  6120              STR      r0,[r4,#0x10]
;;;180            OS_EXIT_CRITICAL();
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       OS_CPU_SR_Restore
;;;181            *perr = OS_ERR_NONE;                          /*      No error                                 */
000026  2000              MOVS     r0,#0
000028  7028              STRB     r0,[r5,#0]
;;;182            return (pblk);                                /*      Return memory block to caller            */
00002a  4630              MOV      r0,r6
                  |L2.44|
;;;183        }
;;;184        OS_EXIT_CRITICAL();
;;;185        *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
;;;186        return ((void *)0);                               /*      Return NULL pointer to caller            */
;;;187    }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L2.48|
000030  4638              MOV      r0,r7                 ;184
000032  f7fffffe          BL       OS_CPU_SR_Restore
000036  205d              MOVS     r0,#0x5d              ;185
000038  7028              STRB     r0,[r5,#0]            ;185
00003a  2000              MOVS     r0,#0                 ;186
00003c  e7f6              B        |L2.44|
;;;188    /*$PAGE*/
                          ENDP


                          AREA ||i.OSMemNameGet||, CODE, READONLY, ALIGN=2

                  OSMemNameGet PROC
;;;210    #if OS_MEM_NAME_EN > 0u
;;;211    INT8U  OSMemNameGet (OS_MEM   *pmem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;212                         INT8U   **pname,
;;;213                         INT8U    *perr)
;;;214    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;215        INT8U      len;
;;;216    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;217        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;218    #endif
;;;219    
;;;220    
;;;221    
;;;222    #ifdef OS_SAFETY_CRITICAL
;;;223        if (perr == (INT8U *)0) {
;;;224            OS_SAFETY_CRITICAL_EXCEPTION();
;;;225        }
;;;226    #endif
;;;227    
;;;228    #if OS_ARG_CHK_EN > 0u
;;;229        if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
;;;230            *perr = OS_ERR_MEM_INVALID_PMEM;
;;;231            return (0u);
;;;232        }
;;;233        if (pname == (INT8U **)0) {                  /* Is 'pname' a NULL pointer?                         */
;;;234            *perr = OS_ERR_PNAME_NULL;
;;;235            return (0u);
;;;236        }
;;;237    #endif
;;;238        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  480b              LDR      r0,|L3.60|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b120              CBZ      r0,|L3.28|
;;;239            *perr = OS_ERR_NAME_GET_ISR;
000012  2011              MOVS     r0,#0x11
000014  7028              STRB     r0,[r5,#0]
;;;240            return (0u);
000016  2000              MOVS     r0,#0
                  |L3.24|
;;;241        }
;;;242        OS_ENTER_CRITICAL();
;;;243        *pname = pmem->OSMemName;
;;;244        len    = OS_StrLen(*pname);
;;;245        OS_EXIT_CRITICAL();
;;;246        *perr  = OS_ERR_NONE;
;;;247        return (len);
;;;248    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L3.28|
00001c  f7fffffe          BL       OS_CPU_SR_Save
000020  4607              MOV      r7,r0                 ;242
000022  6970              LDR      r0,[r6,#0x14]         ;243
000024  6020              STR      r0,[r4,#0]            ;243
000026  6820              LDR      r0,[r4,#0]            ;244
000028  f7fffffe          BL       OS_StrLen
00002c  4680              MOV      r8,r0                 ;244
00002e  4638              MOV      r0,r7                 ;245
000030  f7fffffe          BL       OS_CPU_SR_Restore
000034  2000              MOVS     r0,#0                 ;246
000036  7028              STRB     r0,[r5,#0]            ;246
000038  4640              MOV      r0,r8                 ;247
00003a  e7ed              B        |L3.24|
;;;249    #endif
                          ENDP

                  |L3.60|
                          DCD      OSIntNesting

                          AREA ||i.OSMemNameSet||, CODE, READONLY, ALIGN=2

                  OSMemNameSet PROC
;;;274    #if OS_MEM_NAME_EN > 0u
;;;275    void  OSMemNameSet (OS_MEM  *pmem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;276                        INT8U   *pname,
;;;277                        INT8U   *perr)
;;;278    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;279    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;280        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;281    #endif
;;;282    
;;;283    
;;;284    
;;;285    #ifdef OS_SAFETY_CRITICAL
;;;286        if (perr == (INT8U *)0) {
;;;287            OS_SAFETY_CRITICAL_EXCEPTION();
;;;288        }
;;;289    #endif
;;;290    
;;;291    #if OS_ARG_CHK_EN > 0u
;;;292        if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
;;;293            *perr = OS_ERR_MEM_INVALID_PMEM;
;;;294            return;
;;;295        }
;;;296        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;297            *perr = OS_ERR_PNAME_NULL;
;;;298            return;
;;;299        }
;;;300    #endif
;;;301        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  4808              LDR      r0,|L4.48|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b118              CBZ      r0,|L4.26|
;;;302            *perr = OS_ERR_NAME_SET_ISR;
000012  2012              MOVS     r0,#0x12
000014  7020              STRB     r0,[r4,#0]
                  |L4.22|
;;;303            return;
;;;304        }
;;;305        OS_ENTER_CRITICAL();
;;;306        pmem->OSMemName = pname;
;;;307        OS_EXIT_CRITICAL();
;;;308        *perr           = OS_ERR_NONE;
;;;309    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L4.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;305
000020  616e              STR      r6,[r5,#0x14]         ;306
000022  4638              MOV      r0,r7                 ;307
000024  f7fffffe          BL       OS_CPU_SR_Restore
000028  2000              MOVS     r0,#0                 ;308
00002a  7020              STRB     r0,[r4,#0]            ;308
00002c  bf00              NOP      
00002e  e7f2              B        |L4.22|
;;;310    #endif
                          ENDP

                  |L4.48|
                          DCD      OSIntNesting

                          AREA ||i.OSMemPut||, CODE, READONLY, ALIGN=1

                  OSMemPut PROC
;;;330    
;;;331    INT8U  OSMemPut (OS_MEM  *pmem,
000000  b570              PUSH     {r4-r6,lr}
;;;332                     void    *pblk)
;;;333    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;334    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;335        OS_CPU_SR  cpu_sr = 0u;
000006  2600              MOVS     r6,#0
;;;336    #endif
;;;337    
;;;338    
;;;339    
;;;340    #if OS_ARG_CHK_EN > 0u
;;;341        if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
;;;342            return (OS_ERR_MEM_INVALID_PMEM);
;;;343        }
;;;344        if (pblk == (void *)0) {                     /* Must release a valid block                         */
;;;345            return (OS_ERR_MEM_INVALID_PBLK);
;;;346        }
;;;347    #endif
;;;348        OS_ENTER_CRITICAL();
000008  f7fffffe          BL       OS_CPU_SR_Save
00000c  4606              MOV      r6,r0
;;;349        if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
00000e  e9d41003          LDRD     r1,r0,[r4,#0xc]
000012  4288              CMP      r0,r1
000014  d304              BCC      |L5.32|
;;;350            OS_EXIT_CRITICAL();
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       OS_CPU_SR_Restore
;;;351            return (OS_ERR_MEM_FULL);
00001c  205e              MOVS     r0,#0x5e
                  |L5.30|
;;;352        }
;;;353        *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
;;;354        pmem->OSMemFreeList = pblk;
;;;355        pmem->OSMemNFree++;                          /* One more memory block in this partition            */
;;;356        OS_EXIT_CRITICAL();
;;;357        return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
;;;358    }
00001e  bd70              POP      {r4-r6,pc}
                  |L5.32|
000020  6860              LDR      r0,[r4,#4]            ;353
000022  6028              STR      r0,[r5,#0]            ;353
000024  6065              STR      r5,[r4,#4]            ;354
000026  6920              LDR      r0,[r4,#0x10]         ;355
000028  1c40              ADDS     r0,r0,#1              ;355
00002a  6120              STR      r0,[r4,#0x10]         ;355
00002c  4630              MOV      r0,r6                 ;356
00002e  f7fffffe          BL       OS_CPU_SR_Restore
000032  2000              MOVS     r0,#0                 ;357
000034  e7f3              B        |L5.30|
;;;359    /*$PAGE*/
                          ENDP


                          AREA ||i.OSMemQuery||, CODE, READONLY, ALIGN=1

                  OSMemQuery PROC
;;;378    #if OS_MEM_QUERY_EN > 0u
;;;379    INT8U  OSMemQuery (OS_MEM       *pmem,
000000  b570              PUSH     {r4-r6,lr}
;;;380                       OS_MEM_DATA  *p_mem_data)
;;;381    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;382    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;383        OS_CPU_SR  cpu_sr = 0u;
000006  2600              MOVS     r6,#0
;;;384    #endif
;;;385    
;;;386    
;;;387    
;;;388    #if OS_ARG_CHK_EN > 0u
;;;389        if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
;;;390            return (OS_ERR_MEM_INVALID_PMEM);
;;;391        }
;;;392        if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
;;;393            return (OS_ERR_MEM_INVALID_PDATA);
;;;394        }
;;;395    #endif
;;;396        OS_ENTER_CRITICAL();
000008  f7fffffe          BL       OS_CPU_SR_Save
00000c  4606              MOV      r6,r0
;;;397        p_mem_data->OSAddr     = pmem->OSMemAddr;
00000e  6828              LDR      r0,[r5,#0]
000010  6020              STR      r0,[r4,#0]
;;;398        p_mem_data->OSFreeList = pmem->OSMemFreeList;
000012  6868              LDR      r0,[r5,#4]
000014  6060              STR      r0,[r4,#4]
;;;399        p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
000016  68a8              LDR      r0,[r5,#8]
000018  60a0              STR      r0,[r4,#8]
;;;400        p_mem_data->OSNBlks    = pmem->OSMemNBlks;
00001a  68e8              LDR      r0,[r5,#0xc]
00001c  60e0              STR      r0,[r4,#0xc]
;;;401        p_mem_data->OSNFree    = pmem->OSMemNFree;
00001e  6928              LDR      r0,[r5,#0x10]
000020  6120              STR      r0,[r4,#0x10]
;;;402        OS_EXIT_CRITICAL();
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       OS_CPU_SR_Restore
;;;403        p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
000028  e9d40103          LDRD     r0,r1,[r4,#0xc]
00002c  1a40              SUBS     r0,r0,r1
00002e  6160              STR      r0,[r4,#0x14]
;;;404        return (OS_ERR_NONE);
000030  2000              MOVS     r0,#0
;;;405    }
000032  bd70              POP      {r4-r6,pc}
;;;406    #endif                                           /* OS_MEM_QUERY_EN                                    */
                          ENDP


                          AREA ||i.OS_MemInit||, CODE, READONLY, ALIGN=2

                  OS_MemInit PROC
;;;422    
;;;423    void  OS_MemInit (void)
000000  b570              PUSH     {r4-r6,lr}
;;;424    {
;;;425    #if OS_MAX_MEM_PART == 1u
;;;426        OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
;;;427        OSMemFreeList               = (OS_MEM *)&OSMemTbl[0]; /* Point to beginning of free list           */
;;;428    #if OS_MEM_NAME_EN > 0u
;;;429        OSMemFreeList->OSMemName    = (INT8U *)"?";           /* Unknown name                              */
;;;430    #endif
;;;431    #endif
;;;432    
;;;433    #if OS_MAX_MEM_PART >= 2u
;;;434        OS_MEM  *pmem;
;;;435        INT16U   i;
;;;436    
;;;437    
;;;438        OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
000002  21f0              MOVS     r1,#0xf0
000004  4811              LDR      r0,|L7.76|
000006  f7fffffe          BL       OS_MemClr
;;;439        for (i = 0u; i < (OS_MAX_MEM_PART - 1u); i++) {       /* Init. list of free memory partitions      */
00000a  2400              MOVS     r4,#0
00000c  e00e              B        |L7.44|
                  |L7.14|
;;;440            pmem                = &OSMemTbl[i];               /* Point to memory control block (MCB)       */
00000e  eb040044          ADD      r0,r4,r4,LSL #1
000012  490e              LDR      r1,|L7.76|
000014  eb0105c0          ADD      r5,r1,r0,LSL #3
;;;441            pmem->OSMemFreeList = (void *)&OSMemTbl[i + 1u];  /* Chain list of free partitions             */
000018  1c60              ADDS     r0,r4,#1
00001a  eb000040          ADD      r0,r0,r0,LSL #1
00001e  eb0100c0          ADD      r0,r1,r0,LSL #3
000022  6068              STR      r0,[r5,#4]
;;;442    #if OS_MEM_NAME_EN > 0u
;;;443            pmem->OSMemName  = (INT8U *)(void *)"?";
000024  a00a              ADR      r0,|L7.80|
000026  6168              STR      r0,[r5,#0x14]
000028  1c60              ADDS     r0,r4,#1              ;439
00002a  b284              UXTH     r4,r0                 ;439
                  |L7.44|
00002c  2c09              CMP      r4,#9                 ;439
00002e  d3ee              BCC      |L7.14|
;;;444    #endif
;;;445        }
;;;446        pmem                = &OSMemTbl[i];
000030  eb040044          ADD      r0,r4,r4,LSL #1
000034  4905              LDR      r1,|L7.76|
000036  eb0105c0          ADD      r5,r1,r0,LSL #3
;;;447        pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
00003a  2000              MOVS     r0,#0
00003c  6068              STR      r0,[r5,#4]
;;;448    #if OS_MEM_NAME_EN > 0u
;;;449        pmem->OSMemName = (INT8U *)(void *)"?";
00003e  a004              ADR      r0,|L7.80|
000040  6168              STR      r0,[r5,#0x14]
;;;450    #endif
;;;451    
;;;452        OSMemFreeList   = &OSMemTbl[0];                       /* Point to beginning of free list           */
000042  4608              MOV      r0,r1
000044  4903              LDR      r1,|L7.84|
000046  6008              STR      r0,[r1,#0]  ; OSMemFreeList
;;;453    #endif
;;;454    }
000048  bd70              POP      {r4-r6,pc}
;;;455    #endif                                                    /* OS_MEM_EN                                 */
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
                          DCD      OSMemTbl
                  |L7.80|
000050  3f00              DCB      "?",0
000052  00                DCB      0
000053  00                DCB      0
                  |L7.84|
                          DCD      OSMemFreeList

;*** Start embedded assembler ***

#line 1 "..\\UCOSII\\CORE\\os_mem.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_os_mem_c_181b424a____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_os_mem_c_181b424a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_os_mem_c_181b424a____REVSH|
#line 144
|__asm___8_os_mem_c_181b424a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
