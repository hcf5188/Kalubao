; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\hw_config.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=..\obj\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\OBD -I..\SYSTEM -I..\USER -I..\LIB\inc -I..\UCOSII\CONFIG -I..\UCOSII\PORT -I..\UCOSII\CORE -I..\HAEDWARE -I..\GPS -I..\CDMA -I..\DEAL -I..\USB\CONFIG -I..\USB\STM32_USB-FS-Device_Driver\inc -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.2.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\hw_config.crf ..\USB\CONFIG\hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;66     //需自行添加低功耗代码(比如关时钟等)
;;;67     void Enter_LowPowerMode(void)
000000  2003              MOVS     r0,#3
;;;68     {
;;;69     // 	printf("usb enter low power mode\r\n");
;;;70     	bDeviceState=SUSPENDED;
000002  4901              LDR      r1,|L1.8|
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;71     } 
000006  4770              BX       lr
;;;72     
                          ENDP

                  |L1.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;137    //用于USB配置信息
;;;138    void Get_SerialNum(void)
000000  b570              PUSH     {r4-r6,lr}
;;;139    {
;;;140    	u32 Device_Serial0, Device_Serial1, Device_Serial2;
;;;141    	Device_Serial0 = *(u32*)(0x1FFFF7E8);
000002  480a              LDR      r0,|L2.44|
000004  6804              LDR      r4,[r0,#0]
;;;142    	Device_Serial1 = *(u32*)(0x1FFFF7EC);
000006  1d00              ADDS     r0,r0,#4
000008  6805              LDR      r5,[r0,#0]
;;;143    	Device_Serial2 = *(u32*)(0x1FFFF7F0);
00000a  1d00              ADDS     r0,r0,#4
00000c  6806              LDR      r6,[r0,#0]
;;;144    	Device_Serial0 += Device_Serial2;
00000e  4434              ADD      r4,r4,r6
;;;145    	if (Device_Serial0 != 0)
000010  b154              CBZ      r4,|L2.40|
;;;146    	{
;;;147    		IntToUnicode (Device_Serial0,&Virtual_Com_Port_StringSerial[2] , 8);
000012  2208              MOVS     r2,#8
000014  4906              LDR      r1,|L2.48|
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IntToUnicode
;;;148    		IntToUnicode (Device_Serial1,&Virtual_Com_Port_StringSerial[18], 4);
00001c  2204              MOVS     r2,#4
00001e  4904              LDR      r1,|L2.48|
000020  3110              ADDS     r1,r1,#0x10
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       IntToUnicode
                  |L2.40|
;;;149    	}
;;;150    } 
000028  bd70              POP      {r4-r6,pc}
;;;151    
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      0x1ffff7e8
                  |L2.48|
                          DCD      Virtual_Com_Port_StringSerial+0x2

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=1

                  IntToUnicode PROC
;;;155    //len:要转换的长度
;;;156    void IntToUnicode (u32 value , u8 *pbuf , u8 len)
000000  b530              PUSH     {r4,r5,lr}
;;;157    {
000002  460b              MOV      r3,r1
;;;158    	u8 idx = 0;
000004  2100              MOVS     r1,#0
;;;159    	for( idx = 0 ; idx < len ; idx ++)
000006  bf00              NOP      
000008  e016              B        |L3.56|
                  |L3.10|
;;;160    	{
;;;161    		if( ((value >> 28)) < 0xA )
00000a  240a              MOVS     r4,#0xa
00000c  ebb47f10          CMP      r4,r0,LSR #28
000010  d905              BLS      |L3.30|
;;;162    		{
;;;163    			pbuf[ 2* idx] = (value >> 28) + '0';
000012  2430              MOVS     r4,#0x30
000014  eb047410          ADD      r4,r4,r0,LSR #28
000018  f8034011          STRB     r4,[r3,r1,LSL #1]
00001c  e005              B        |L3.42|
                  |L3.30|
;;;164    		}
;;;165    		else
;;;166    		{
;;;167    			pbuf[2* idx] = (value >> 28) + 'A' - 10; 
00001e  2441              MOVS     r4,#0x41
000020  eb047410          ADD      r4,r4,r0,LSR #28
000024  3c0a              SUBS     r4,r4,#0xa
000026  f8034011          STRB     r4,[r3,r1,LSL #1]
                  |L3.42|
;;;168    		} 
;;;169    		value = value << 4; 
00002a  0100              LSLS     r0,r0,#4
;;;170    		pbuf[ 2* idx + 1] = 0;
00002c  2500              MOVS     r5,#0
00002e  004c              LSLS     r4,r1,#1
000030  1c64              ADDS     r4,r4,#1
000032  551d              STRB     r5,[r3,r4]
000034  1c4c              ADDS     r4,r1,#1              ;159
000036  b2e1              UXTB     r1,r4                 ;159
                  |L3.56|
000038  4291              CMP      r1,r2                 ;159
00003a  dbe6              BLT      |L3.10|
;;;171    	}
;;;172    }
00003c  bd30              POP      {r4,r5,pc}
;;;173    /////////////////////////////////////////////////////////////////////////////////
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;74     //用户可以自行添加相关代码(比如重新配置时钟等)
;;;75     void Leave_LowPowerMode(void)
000000  4805              LDR      r0,|L4.24|
;;;76     {
;;;77     	DEVICE_INFO *pInfo=&Device_Info;
;;;78     //	printf("leave low power mode\r\n"); 
;;;79     	if (pInfo->Current_Configuration!=0)bDeviceState=CONFIGURED; 
000002  7a81              LDRB     r1,[r0,#0xa]
000004  b119              CBZ      r1,|L4.14|
000006  2105              MOVS     r1,#5
000008  4a04              LDR      r2,|L4.28|
00000a  6011              STR      r1,[r2,#0]  ; bDeviceState
00000c  e002              B        |L4.20|
                  |L4.14|
;;;80     	else bDeviceState = ATTACHED; 
00000e  2101              MOVS     r1,#1
000010  4a02              LDR      r2,|L4.28|
000012  6011              STR      r1,[r2,#0]  ; bDeviceState
                  |L4.20|
;;;81     } 
000014  4770              BX       lr
;;;82     
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      Device_Info
                  |L4.28|
                          DCD      bDeviceState

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;57     //USB时钟配置函数,USBclk=48Mhz@HCLK=72Mhz
;;;58     void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;59     {
;;;60     	RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);//USBclk=PLLclk/1.5=48Mhz	
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;61     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);	 //USB时钟使能		 
000008  2101              MOVS     r1,#1
00000a  05c8              LSLS     r0,r1,#23
00000c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;62     } 
000010  bd10              POP      {r4,pc}
;;;63     
                          ENDP


                          AREA ||i.TIM5_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM5_IRQHandler PROC
;;;196    
;;;197    void TIM5_IRQHandler(void)   //CDMA接收超时处理定时器中断
000000  b510              PUSH     {r4,lr}
;;;198    {
;;;199    	uint8_t *ptrRece;
;;;200    	OSIntEnter();//系统进入中断服务程序
000002  f7fffffe          BL       OSIntEnter
;;;201    	if (TIM_GetITStatus(TIM5, TIM_IT_Update) != RESET)  //检查TIM5更新中断发生与否
000006  2101              MOVS     r1,#1
000008  4824              LDR      r0,|L6.156|
00000a  f7fffffe          BL       TIM_GetITStatus
00000e  2800              CMP      r0,#0
000010  d040              BEQ      |L6.148|
;;;202    	{
;;;203    		TIM_ClearITPendingBit(TIM5, TIM_IT_Update  );  //清除TIMx更新中断标志 
000012  2101              MOVS     r1,#1
000014  4821              LDR      r0,|L6.156|
000016  f7fffffe          BL       TIM_ClearITPendingBit
;;;204    		usbRxTime ++;
00001a  4821              LDR      r0,|L6.160|
00001c  7800              LDRB     r0,[r0,#0]  ; usbRxTime
00001e  1c40              ADDS     r0,r0,#1
000020  491f              LDR      r1,|L6.160|
000022  7008              STRB     r0,[r1,#0]
;;;205    		if(usbRxTime > 2)
000024  4608              MOV      r0,r1
000026  7800              LDRB     r0,[r0,#0]  ; usbRxTime
000028  2802              CMP      r0,#2
00002a  dd33              BLE      |L6.148|
;;;206    		{
;;;207    			usbRxTime = 0;
00002c  2000              MOVS     r0,#0
00002e  7008              STRB     r0,[r1,#0]
;;;208    			usbReceLen = Store_Getlength(receUSB_S);
000030  481c              LDR      r0,|L6.164|
000032  6800              LDR      r0,[r0,#0]  ; receUSB_S
000034  f7fffffe          BL       Store_Getlength
000038  491b              LDR      r1,|L6.168|
00003a  8008              STRH     r0,[r1,#0]
;;;209    			if(usbReceLen>2 )
00003c  4608              MOV      r0,r1
00003e  8800              LDRH     r0,[r0,#0]  ; usbReceLen
000040  2802              CMP      r0,#2
000042  dd1f              BLE      |L6.132|
;;;210    			{
;;;211    				ptrRece = Mem_malloc(usbReceLen);
000044  4608              MOV      r0,r1
000046  8800              LDRH     r0,[r0,#0]  ; usbReceLen
000048  f7fffffe          BL       Mem_malloc
00004c  4604              MOV      r4,r0
;;;212    				if(ptrRece != NULL)//内存块申请成功
00004e  b1a4              CBZ      r4,|L6.122|
;;;213    				{
;;;214    					Store_Getdates(receUSB_S,ptrRece,usbReceLen);
000050  4815              LDR      r0,|L6.168|
000052  8802              LDRH     r2,[r0,#0]  ; usbReceLen
000054  4621              MOV      r1,r4
000056  4813              LDR      r0,|L6.164|
000058  6800              LDR      r0,[r0,#0]  ; receUSB_S
00005a  f7fffffe          BL       Store_Getdates
;;;215    					if(OSQPost(USBRecieveQ,ptrRece) != OS_ERR_NONE)//推送不成功需要释放内存块
00005e  4621              MOV      r1,r4
000060  4812              LDR      r0,|L6.172|
000062  6800              LDR      r0,[r0,#0]  ; USBRecieveQ
000064  f7fffffe          BL       OSQPost
000068  b180              CBZ      r0,|L6.140|
;;;216    					{
;;;217    						Mem_free(ptrRece);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       Mem_free
;;;218    						Store_Clear(receUSB_S);//舍弃本次接收的数据
000070  480c              LDR      r0,|L6.164|
000072  6800              LDR      r0,[r0,#0]  ; receUSB_S
000074  f7fffffe          BL       Store_Clear
000078  e008              B        |L6.140|
                  |L6.122|
;;;219    					}
;;;220    				}
;;;221    				else
;;;222    					Store_Clear(receUSB_S);    //舍弃本次接收的数据
00007a  480a              LDR      r0,|L6.164|
00007c  6800              LDR      r0,[r0,#0]  ; receUSB_S
00007e  f7fffffe          BL       Store_Clear
000082  e003              B        |L6.140|
                  |L6.132|
;;;223    			}
;;;224    			else
;;;225    				Store_Clear(receUSB_S);//接收的数据长度<=2 视为无效数据，没有这么短的回复
000084  4807              LDR      r0,|L6.164|
000086  6800              LDR      r0,[r0,#0]  ; receUSB_S
000088  f7fffffe          BL       Store_Clear
                  |L6.140|
;;;226    				
;;;227    			TIM_Cmd(TIM5, DISABLE);
00008c  2100              MOVS     r1,#0
00008e  4803              LDR      r0,|L6.156|
000090  f7fffffe          BL       TIM_Cmd
                  |L6.148|
;;;228    		}
;;;229    	}
;;;230    	OSIntExit();  //中断服务结束，系统进行任务调度
000094  f7fffffe          BL       OSIntExit
;;;231    }
000098  bd10              POP      {r4,pc}
;;;232    //发送一个字节数据到USB虚拟串口
                          ENDP

00009a  0000              DCW      0x0000
                  |L6.156|
                          DCD      0x40000c00
                  |L6.160|
                          DCD      usbRxTime
                  |L6.164|
                          DCD      receUSB_S
                  |L6.168|
                          DCD      usbReceLen
                  |L6.172|
                          DCD      USBRecieveQ

                          AREA ||i.USBWakeUp_IRQHandler||, CODE, READONLY, ALIGN=1

                  USBWakeUp_IRQHandler PROC
;;;45     //USB唤醒中断服务函数
;;;46     void USBWakeUp_IRQHandler(void) 
000000  b510              PUSH     {r4,lr}
;;;47     {
;;;48     	EXTI_ClearITPendingBit(EXTI_Line18);//清除USB唤醒中断挂起位
000002  f44f2080          MOV      r0,#0x40000
000006  f7fffffe          BL       EXTI_ClearITPendingBit
;;;49     } 
00000a  bd10              POP      {r4,pc}
;;;50     
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=1

                  USB_Cable_Config PROC
;;;113    //         ENABLE,上拉
;;;114    void USB_Cable_Config (FunctionalState NewState)
000000  4770              BX       lr
;;;115    { 
;;;116    //	if (NewState!=DISABLE)printf("usb pull up enable\r\n"); 
;;;117    //	else printf("usb pull up disable\r\n"); 
;;;118    }
;;;119    
                          ENDP


                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;83     //USB中断配置
;;;84     void USB_Interrupts_Config(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;85     { 
;;;86     	NVIC_InitTypeDef NVIC_InitStructure;
;;;87     	EXTI_InitTypeDef EXTI_InitStructure;
;;;88     
;;;89      
;;;90     	/* Configure the EXTI line 18 connected internally to the USB IP */
;;;91     	EXTI_ClearITPendingBit(EXTI_Line18);
000002  f44f2080          MOV      r0,#0x40000
000006  f7fffffe          BL       EXTI_ClearITPendingBit
;;;92     											  //  开启线18上的中断
;;;93     	EXTI_InitStructure.EXTI_Line = EXTI_Line18; // USB resume from suspend mode
00000a  f44f2080          MOV      r0,#0x40000
00000e  9000              STR      r0,[sp,#0]
;;;94     	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;	//line 18上事件上升降沿触发
000010  2008              MOVS     r0,#8
000012  f88d0005          STRB     r0,[sp,#5]
;;;95     	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
000016  2001              MOVS     r0,#1
000018  f88d0006          STRB     r0,[sp,#6]
;;;96     	EXTI_Init(&EXTI_InitStructure); 	 
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       EXTI_Init
;;;97     
;;;98     	/* Enable the USB interrupt */
;;;99     	NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;	//组2，优先级次之 
000022  2014              MOVS     r0,#0x14
000024  f88d0008          STRB     r0,[sp,#8]
;;;100    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000028  2001              MOVS     r0,#1
00002a  f88d0009          STRB     r0,[sp,#9]
;;;101    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00002e  2000              MOVS     r0,#0
000030  f88d000a          STRB     r0,[sp,#0xa]
;;;102    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000034  2001              MOVS     r0,#1
000036  f88d000b          STRB     r0,[sp,#0xb]
;;;103    	NVIC_Init(&NVIC_InitStructure);
00003a  a802              ADD      r0,sp,#8
00003c  f7fffffe          BL       NVIC_Init
;;;104    	
;;;105    	/* Enable the USB Wake-up interrupt */
;;;106    	NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;   //组2，优先级最高	
000040  202a              MOVS     r0,#0x2a
000042  f88d0008          STRB     r0,[sp,#8]
;;;107    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000046  2000              MOVS     r0,#0
000048  f88d0009          STRB     r0,[sp,#9]
;;;108    	NVIC_Init(&NVIC_InitStructure);   
00004c  a802              ADD      r0,sp,#8
00004e  f7fffffe          BL       NVIC_Init
;;;109    }	
000052  bd0e              POP      {r1-r3,pc}
;;;110    
                          ENDP


                          AREA ||i.USB_LP_CAN1_RX0_IRQHandler||, CODE, READONLY, ALIGN=1

                  USB_LP_CAN1_RX0_IRQHandler PROC
;;;51     //USB中断处理函数
;;;52     void USB_LP_CAN1_RX0_IRQHandler(void) 
000000  b510              PUSH     {r4,lr}
;;;53     {
;;;54     	USB_Istr();
000002  f7fffffe          BL       USB_Istr
;;;55     } 
000006  bd10              POP      {r4,pc}
;;;56     
                          ENDP


                          AREA ||i.USB_Port_Set||, CODE, READONLY, ALIGN=2

                  USB_Port_Set PROC
;;;122    //       1,允许连接	   
;;;123    void USB_Port_Set(u8 enable)
000000  b510              PUSH     {r4,lr}
;;;124    {
000002  4604              MOV      r4,r0
;;;125    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);    //使能PORTA时钟		 
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;126    	if(enable)_SetCNTR(_GetCNTR()&(~(1<<1)));//退出断电模式
00000c  b13c              CBZ      r4,|L11.30|
00000e  480f              LDR      r0,|L11.76|
000010  6800              LDR      r0,[r0,#0]
000012  b280              UXTH     r0,r0
000014  f0200002          BIC      r0,r0,#2
000018  490c              LDR      r1,|L11.76|
00001a  6008              STR      r0,[r1,#0]
00001c  e014              B        |L11.72|
                  |L11.30|
;;;127    	else
;;;128    	{	  
;;;129    		_SetCNTR(_GetCNTR()|(1<<1));  // 断电模式
00001e  480b              LDR      r0,|L11.76|
000020  6800              LDR      r0,[r0,#0]
000022  b280              UXTH     r0,r0
000024  f0400002          ORR      r0,r0,#2
000028  4908              LDR      r1,|L11.76|
00002a  6008              STR      r0,[r1,#0]
;;;130    		GPIOA->CRH&=0XFFF00FFF;
00002c  4808              LDR      r0,|L11.80|
00002e  6800              LDR      r0,[r0,#0]
000030  f420207f          BIC      r0,r0,#0xff000
000034  4906              LDR      r1,|L11.80|
000036  6008              STR      r0,[r1,#0]
;;;131    		GPIOA->CRH|=0X00033000;
000038  4608              MOV      r0,r1
00003a  6800              LDR      r0,[r0,#0]
00003c  f440304c          ORR      r0,r0,#0x33000
000040  6008              STR      r0,[r1,#0]
;;;132    		PAout(12)=0;	    		  
000042  2000              MOVS     r0,#0
000044  4903              LDR      r1,|L11.84|
000046  6008              STR      r0,[r1,#0]
                  |L11.72|
;;;133    	}
;;;134    }  
000048  bd10              POP      {r4,pc}
;;;135    
                          ENDP

00004a  0000              DCW      0x0000
                  |L11.76|
                          DCD      0x40005c40
                  |L11.80|
                          DCD      0x40010804
                  |L11.84|
                          DCD      0x422101b0

                          AREA ||i.USB_To_USART_Send_Data||, CODE, READONLY, ALIGN=2

                  USB_To_USART_Send_Data PROC
;;;182    uint16_t usbReceLen = 0;
;;;183    void USB_To_USART_Send_Data(u8* data_buffer, u8 Nb_bytes)
000000  b570              PUSH     {r4-r6,lr}
;;;184    { 
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;185    	u8 i;
;;;186    	for(i=0;i<Nb_bytes;i++)
000006  2400              MOVS     r4,#0
000008  e006              B        |L12.24|
                  |L12.10|
;;;187    	{  
;;;188    		Store_Push(receUSB_S,data_buffer[i]);
00000a  5d29              LDRB     r1,[r5,r4]
00000c  4809              LDR      r0,|L12.52|
00000e  6800              LDR      r0,[r0,#0]  ; receUSB_S
000010  f7fffffe          BL       Store_Push
000014  1c60              ADDS     r0,r4,#1              ;186
000016  b2c4              UXTB     r4,r0                 ;186
                  |L12.24|
000018  42b4              CMP      r4,r6                 ;186
00001a  dbf6              BLT      |L12.10|
;;;189    	} 
;;;190    	usbRxTime = 1;
00001c  2001              MOVS     r0,#1
00001e  4906              LDR      r1,|L12.56|
000020  7008              STRB     r0,[r1,#0]
;;;191    	TIM_SetCounter(TIM5,0); //清空计数器
000022  2100              MOVS     r1,#0
000024  4805              LDR      r0,|L12.60|
000026  f7fffffe          BL       TIM_SetCounter
;;;192    	TIM_Cmd(TIM5, ENABLE);  //使能TIMx	
00002a  2101              MOVS     r1,#1
00002c  4803              LDR      r0,|L12.60|
00002e  f7fffffe          BL       TIM_Cmd
;;;193    } 
000032  bd70              POP      {r4-r6,pc}
;;;194    
                          ENDP

                  |L12.52|
                          DCD      receUSB_S
                  |L12.56|
                          DCD      usbRxTime
                  |L12.60|
                          DCD      0x40000c00

                          AREA ||i.USB_USART_SendDatas||, CODE, READONLY, ALIGN=2

                  USB_USART_SendDatas PROC
;;;233    extern SYS_OperationVar  varOperation;
;;;234    void USB_USART_SendDatas(uint8_t* ptrSend,uint16_t datLen)
000000  b570              PUSH     {r4-r6,lr}
;;;235    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;236    #if OS_CRITICAL_METHOD == 3u           /* Allocate storage for CPU status register           */
;;;237    	OS_CPU_SR  cpu_sr = 0u;
000006  2600              MOVS     r6,#0
;;;238    #endif
;;;239    	
;;;240    	if(datLen < 1 || datLen >1020)
000008  2c01              CMP      r4,#1
00000a  db02              BLT      |L13.18|
00000c  f5b47f7f          CMP      r4,#0x3fc
000010  dd00              BLE      |L13.20|
                  |L13.18|
;;;241    		return ;
;;;242    	OS_ENTER_CRITICAL();
;;;243    	
;;;244    	if(CirQ_Pushs(sendUSB_Q,ptrSend,datLen) != OK)
;;;245    	{
;;;246    		OS_EXIT_CRITICAL();
;;;247    	}
;;;248    	OS_EXIT_CRITICAL();
;;;249    	
;;;250    	varOperation.isUSBSendDat = 1;	
;;;251    }
000012  bd70              POP      {r4-r6,pc}
                  |L13.20|
000014  f7fffffe          BL       OS_CPU_SR_Save
000018  4606              MOV      r6,r0                 ;242
00001a  4622              MOV      r2,r4                 ;244
00001c  4629              MOV      r1,r5                 ;244
00001e  4808              LDR      r0,|L13.64|
000020  6800              LDR      r0,[r0,#0]            ;244  ; sendUSB_Q
000022  f7fffffe          BL       CirQ_Pushs
000026  b110              CBZ      r0,|L13.46|
000028  4630              MOV      r0,r6                 ;246
00002a  f7fffffe          BL       OS_CPU_SR_Restore
                  |L13.46|
00002e  4630              MOV      r0,r6                 ;248
000030  f7fffffe          BL       OS_CPU_SR_Restore
000034  2001              MOVS     r0,#1                 ;250
000036  4903              LDR      r1,|L13.68|
000038  f8810097          STRB     r0,[r1,#0x97]         ;250
00003c  bf00              NOP      
00003e  e7e8              B        |L13.18|
;;;252    
                          ENDP

                  |L13.64|
                          DCD      sendUSB_Q
                  |L13.68|
                          DCD      varOperation

                          AREA ||i.usb_printf||, CODE, READONLY, ALIGN=2

                  usb_printf PROC
;;;254    //确保一次发送数据不超USB_USART_REC_LEN字节
;;;255    void usb_printf(char* fmt,...)  
000000  b40f              PUSH     {r0-r3}
;;;256    {  
000002  b538              PUSH     {r3-r5,lr}
;;;257    	u16 datLen;
;;;258    	va_list ap;
;;;259    #if OS_CRITICAL_METHOD == 3u           /* Allocate storage for CPU status register           */
;;;260    	OS_CPU_SR  cpu_sr = 0u;
000004  2500              MOVS     r5,#0
;;;261    #endif
;;;262    	va_start(ap,fmt);
000006  a805              ADD      r0,sp,#0x14
000008  9000              STR      r0,[sp,#0]
;;;263    	vsprintf((char*)USART_PRINTF_Buffer,fmt,ap);
00000a  4813              LDR      r0,|L14.88|
00000c  9a00              LDR      r2,[sp,#0]
00000e  9904              LDR      r1,[sp,#0x10]
000010  f7fffffe          BL       __c89vsprintf
;;;264    	va_end(ap);
000014  2000              MOVS     r0,#0
000016  9000              STR      r0,[sp,#0]
;;;265    	
;;;266    	datLen=strlen((const char*)USART_PRINTF_Buffer);//此次发送数据的长度
000018  480f              LDR      r0,|L14.88|
00001a  f7fffffe          BL       strlen
00001e  b284              UXTH     r4,r0
;;;267    	
;;;268    	OS_ENTER_CRITICAL();
000020  f7fffffe          BL       OS_CPU_SR_Save
000024  4605              MOV      r5,r0
;;;269    	
;;;270    	CirQ_OnePush(sendUSB_Q,0x10); //调试信息输出
000026  2110              MOVS     r1,#0x10
000028  480c              LDR      r0,|L14.92|
00002a  6800              LDR      r0,[r0,#0]  ; sendUSB_Q
00002c  f7fffffe          BL       CirQ_OnePush
;;;271    	
;;;272    	if(CirQ_Pushs(sendUSB_Q,USART_PRINTF_Buffer,datLen) != OK)
000030  4622              MOV      r2,r4
000032  4909              LDR      r1,|L14.88|
000034  4809              LDR      r0,|L14.92|
000036  6800              LDR      r0,[r0,#0]  ; sendUSB_Q
000038  f7fffffe          BL       CirQ_Pushs
00003c  b110              CBZ      r0,|L14.68|
;;;273    	{
;;;274    		OS_EXIT_CRITICAL();
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       OS_CPU_SR_Restore
                  |L14.68|
;;;275    	}
;;;276    	OS_EXIT_CRITICAL();
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       OS_CPU_SR_Restore
;;;277    	varOperation.isUSBSendDat = 1;//通知USB进行数据发送
00004a  2001              MOVS     r0,#1
00004c  4904              LDR      r1,|L14.96|
00004e  f8810097          STRB     r0,[r1,#0x97]
;;;278    	
;;;279    } 
000052  bc38              POP      {r3-r5}
000054  f85dfb14          LDR      pc,[sp],#0x14
;;;280    
                          ENDP

                  |L14.88|
                          DCD      USART_PRINTF_Buffer
                  |L14.92|
                          DCD      sendUSB_Q
                  |L14.96|
                          DCD      varOperation

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USART_PRINTF_Buffer
                          %        200
                  USB_USART_RX_BUF
                          %        200

                          AREA ||.data||, DATA, ALIGN=1

                  USB_USART_RX_STA
000000  0000              DCW      0x0000
                  usbRxTime
000002  0000              DCB      0x00,0x00
                  usbReceLen
000004  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\USB\\CONFIG\\hw_config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_4866bdfc____REV16|
#line 465 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.2.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___11_hw_config_c_4866bdfc____REV16| PROC
#line 466

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_4866bdfc____REVSH|
#line 480
|__asm___11_hw_config_c_4866bdfc____REVSH| PROC
#line 481

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_4866bdfc____RRX|
#line 667
|__asm___11_hw_config_c_4866bdfc____RRX| PROC
#line 668

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
