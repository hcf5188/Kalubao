; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\vardeal.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=..\obj\vardeal.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\OBD -I..\SYSTEM -I..\USER -I..\LIB\inc -I..\UCOSII\CONFIG -I..\UCOSII\PORT -I..\UCOSII\CORE -I..\HAEDWARE -I..\GPS -I..\CDMA -I..\DEAL -I..\USB\CONFIG -I..\USB\STM32_USB-FS-Device_Driver\inc -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.2.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\vardeal.crf ..\DEAL\varDeal.c]
                          THUMB

                          AREA ||i.CARVarInit||, CODE, READONLY, ALIGN=2

                  CARVarInit PROC
;;;302    //车辆运行的数据 初始化
;;;303    void CARVarInit(void)
000000  2000              MOVS     r0,#0
;;;304    {
;;;305    	carAllRecord.startTime       = 0;//发动机启动时间
000002  4920              LDR      r1,|L1.132|
000004  6008              STR      r0,[r1,#0]  ; carAllRecord
;;;306    	carAllRecord.stopTime        = 0;//发动机停止时间
000006  6048              STR      r0,[r1,#4]  ; carAllRecord
;;;307    	carAllRecord.totalMileage    = 0;//此次总行程
000008  6088              STR      r0,[r1,#8]  ; carAllRecord
;;;308    	carAllRecord.totalFuel       = 0;//总油耗
00000a  60c8              STR      r0,[r1,#0xc]  ; carAllRecord
;;;309    	carAllRecord.startlongitude  = 0;//汽车开始 经度
00000c  6108              STR      r0,[r1,#0x10]  ; carAllRecord
;;;310    	carAllRecord.startlatitude   = 0;//汽车开始 纬度
00000e  6148              STR      r0,[r1,#0x14]  ; carAllRecord
;;;311    	carAllRecord.stoplongitude   = 0;//汽车停止 经度
000010  6188              STR      r0,[r1,#0x18]  ; carAllRecord
;;;312    	carAllRecord.stoplatitude    = 0;//汽车停止 纬度
000012  61c8              STR      r0,[r1,#0x1c]  ; carAllRecord
;;;313    	carAllRecord.rapidlyPlusNum  = 0;//急加速次数
000014  f8810020          STRB     r0,[r1,#0x20]
;;;314    	carAllRecord.rapidlySubNum   = 0;//急减速次数
000018  f8810021          STRB     r0,[r1,#0x21]
;;;315    	carAllRecord.engineSpeedMax  = 0;//最高转速
00001c  8448              STRH     r0,[r1,#0x22]
;;;316    	carAllRecord.carSpeedMax     = 0;//最高车速
00001e  8488              STRH     r0,[r1,#0x24]
;;;317    	carAllRecord.messageNum      = 0;//消息条数
000020  f8c10026          STR      r0,[r1,#0x26]  ; carAllRecord
;;;318    	carAllRecord.cdmaReStart     = 0;//CDMA重启次数
000024  f881002a          STRB     r0,[r1,#0x2a]
;;;319    	carAllRecord.netFlow         = 0;//网络流量
000028  f8c1002b          STR      r0,[r1,#0x2b]  ; carAllRecord
;;;320    	
;;;321    	carAllRecord.afterFuel       = 0;//后喷油量
00002c  f8a10046          STRH     r0,[r1,#0x46]
;;;322    	carAllRecord.afterFuel1      = 0;
000030  f8a10048          STRH     r0,[r1,#0x48]
;;;323    	carAllRecord.afterFuel2      = 0;
000034  f8a1004a          STRH     r0,[r1,#0x4a]
;;;324    	carAllRecord.afterFuel3      = 0;
000038  f8a1004c          STRH     r0,[r1,#0x4c]
;;;325    	carAllRecord.afterFuelTemp   = 0;
00003c  f881004e          STRB     r0,[r1,#0x4e]
;;;326    	carAllRecord.allFuel         = 0; //总喷油量
000040  f8c10035          STR      r0,[r1,#0x35]  ; carAllRecord
;;;327    	carAllRecord.allFuelTemp     = 0;
000044  f8810039          STRB     r0,[r1,#0x39]
;;;328    	carAllRecord.beforeFuel      = 0; //预喷油量
000048  f8a1003d          STRH     r0,[r1,#0x3d]
;;;329    	carAllRecord.beforeFuel1     = 0;
00004c  f8a1003f          STRH     r0,[r1,#0x3f]
;;;330    	carAllRecord.beforeFuel2     = 0;
000050  f8a10041          STRH     r0,[r1,#0x41]
;;;331    	carAllRecord.beforeFuel3     = 0;
000054  f8a10043          STRH     r0,[r1,#0x43]
;;;332    	carAllRecord.beforeFuelTemp  = 0;
000058  f8810045          STRB     r0,[r1,#0x45]
;;;333    	carAllRecord.carSpeed        = 0; //车速
00005c  f8a1002f          STRH     r0,[r1,#0x2f]
;;;334    	carAllRecord.carSpeedTemp    = 0;
000060  f8810031          STRB     r0,[r1,#0x31]
;;;335    	carAllRecord.curFuel         = 0; //当前喷油量
000064  f8a1004f          STRH     r0,[r1,#0x4f]
;;;336    	carAllRecord.curFuelTemp     = 0;
000068  f8810051          STRB     r0,[r1,#0x51]
;;;337    	carAllRecord.primaryFuel     = 0; //主喷油量
00006c  8748              STRH     r0,[r1,#0x3a]
;;;338    	carAllRecord.primaryFuelTemp = 0;
00006e  f881003c          STRB     r0,[r1,#0x3c]
;;;339    	carAllRecord.engineSpeed     = 0; //发动机转速
000072  8648              STRH     r0,[r1,#0x32]
;;;340    	carAllRecord.engineSpeedTemp = 0; 
000074  f8810034          STRB     r0,[r1,#0x34]
;;;341    	carAllRecord.runLen1         = 0; //行驶距离为 0
000078  6548              STR      r0,[r1,#0x54]  ; carAllRecord
;;;342    	carAllRecord.runLen2         = 0; //车辆距离为 0
00007a  6588              STR      r0,[r1,#0x58]  ; carAllRecord
;;;343    	carAllRecord.instantFuel     = 0; //瞬时油耗
00007c  f8a10052          STRH     r0,[r1,#0x52]
;;;344    }
000080  4770              BX       lr
;;;345    
                          ENDP

000082  0000              DCW      0x0000
                  |L1.132|
                          DCD      carAllRecord

                          AREA ||i.CDMASendDataPack||, CODE, READONLY, ALIGN=2

                  CDMASendDataPack PROC
;;;37     uint16_t crc      = 0;
;;;38     void CDMASendDataPack(_CDMADataToSend* ptr)//对上传的数据包进行帧头封装、CRC校验等
000000  b570              PUSH     {r4-r6,lr}
;;;39     {
000002  4604              MOV      r4,r0
;;;40     	_PROTOCOL_HEAD *pHead = NULL;
000004  2500              MOVS     r5,#0
;;;41     	
;;;42     	realTime = RTC_GetCounter();//得到系统运行的RTC时间
000006  f7fffffe          BL       RTC_GetCounter
00000a  4927              LDR      r1,|L2.168|
00000c  6008              STR      r0,[r1,#0]  ; realTime
;;;43     	
;;;44     	pHead = Mem_malloc(sizeof(_PROTOCOL_HEAD));
00000e  201b              MOVS     r0,#0x1b
000010  f7fffffe          BL       Mem_malloc
000014  4605              MOV      r5,r0
;;;45     	
;;;46     	pHead->magic    = 0x7E;
000016  207e              MOVS     r0,#0x7e
000018  7028              STRB     r0,[r5,#0]
;;;47     	pHead->len      = t_htons(ptr->datLength - 3);   //MAP层数据长度
00001a  8821              LDRH     r1,[r4,#0]
00001c  1ec9              SUBS     r1,r1,#3
00001e  b288              UXTH     r0,r1
000020  f7fffffe          BL       t_htons
000024  f8a50001          STRH     r0,[r5,#1]
;;;48     	memcpy(pHead->device,varOperation.imei,16);      //拷贝设备唯一标识码 IMEI
000028  2210              MOVS     r2,#0x10
00002a  4920              LDR      r1,|L2.172|
00002c  1ce8              ADDS     r0,r5,#3
00002e  f7fffffe          BL       __aeabi_memcpy
;;;49     	pHead->msgid    = t_htonl(varOperation.sendId);  //发送帧流水号 
000032  491e              LDR      r1,|L2.172|
000034  3909              SUBS     r1,r1,#9
000036  6dc8              LDR      r0,[r1,#0x5c]  ; varOperation
000038  f7fffffe          BL       t_htonl
00003c  f8c50013          STR      r0,[r5,#0x13]
;;;50     	pHead->time_cli = t_htonl(realTime);             //记录当前包要发送的时间 
000040  4819              LDR      r0,|L2.168|
000042  6800              LDR      r0,[r0,#0]  ; realTime
000044  f7fffffe          BL       t_htonl
000048  f8c50017          STR      r0,[r5,#0x17]
;;;51     	
;;;52     	varOperation.sendId ++;
00004c  4817              LDR      r0,|L2.172|
00004e  3809              SUBS     r0,r0,#9
000050  6dc0              LDR      r0,[r0,#0x5c]  ; varOperation
000052  1c40              ADDS     r0,r0,#1
000054  4915              LDR      r1,|L2.172|
000056  3909              SUBS     r1,r1,#9
000058  65c8              STR      r0,[r1,#0x5c]  ; varOperation
;;;53     	
;;;54     	memcpy(ptr->data,pHead,sizeof(_PROTOCOL_HEAD));
00005a  6860              LDR      r0,[r4,#4]
00005c  221b              MOVS     r2,#0x1b
00005e  4629              MOV      r1,r5
000060  f7fffffe          BL       __aeabi_memcpy
;;;55     	Mem_free(pHead);                                 //申请的内存块，用完一定要释放啊
000064  4628              MOV      r0,r5
000066  f7fffffe          BL       Mem_free
;;;56     	
;;;57     	crc = CRC_Compute16(&ptr->data[1],ptr -> datLength-1);
00006a  8822              LDRH     r2,[r4,#0]
00006c  1e51              SUBS     r1,r2,#1
00006e  6862              LDR      r2,[r4,#4]
000070  1c50              ADDS     r0,r2,#1
000072  f7fffffe          BL       CRC_Compute16
000076  490e              LDR      r1,|L2.176|
000078  8008              STRH     r0,[r1,#0]
;;;58     	
;;;59     	ptr->data[ptr->datLength++] = (crc>>8) & 0xff;
00007a  4608              MOV      r0,r1
00007c  8800              LDRH     r0,[r0,#0]  ; crc
00007e  0a01              LSRS     r1,r0,#8
000080  8822              LDRH     r2,[r4,#0]
000082  1c50              ADDS     r0,r2,#1
000084  8020              STRH     r0,[r4,#0]
000086  6860              LDR      r0,[r4,#4]
000088  5481              STRB     r1,[r0,r2]
;;;60     	ptr->data[ptr->datLength++] = crc & 0xff;
00008a  4809              LDR      r0,|L2.176|
00008c  7801              LDRB     r1,[r0,#0]  ; crc
00008e  8822              LDRH     r2,[r4,#0]
000090  1c50              ADDS     r0,r2,#1
000092  8020              STRH     r0,[r4,#0]
000094  6860              LDR      r0,[r4,#4]
000096  5481              STRB     r1,[r0,r2]
;;;61     	ptr->data[ptr->datLength++] = 0x7E;
000098  217e              MOVS     r1,#0x7e
00009a  8822              LDRH     r2,[r4,#0]
00009c  1c50              ADDS     r0,r2,#1
00009e  8020              STRH     r0,[r4,#0]
0000a0  6860              LDR      r0,[r4,#4]
0000a2  5481              STRB     r1,[r0,r2]
;;;62     }
0000a4  bd70              POP      {r4-r6,pc}
;;;63     
                          ENDP

0000a6  0000              DCW      0x0000
                  |L2.168|
                          DCD      realTime
                  |L2.172|
                          DCD      varOperation+0x9
                  |L2.176|
                          DCD      ||crc||

                          AREA ||i.CDMNSendDataInit||, CODE, READONLY, ALIGN=2

                  CDMNSendDataInit PROC
;;;5      
;;;6      _CDMADataToSend* CDMNSendDataInit(uint16_t length)//要发送的数据，进行初始化
000000  b570              PUSH     {r4-r6,lr}
;;;7      {
000002  4605              MOV      r5,r0
;;;8      	_CDMADataToSend* ptr = NULL;
000004  2400              MOVS     r4,#0
;;;9      	ptr = Mem_malloc(sizeof(_CDMADataToSend));
000006  2008              MOVS     r0,#8
000008  f7fffffe          BL       Mem_malloc
00000c  4604              MOV      r4,r0
;;;10     	
;;;11     	ptr->timeCount = 0;
00000e  2000              MOVS     r0,#0
000010  8060              STRH     r0,[r4,#2]
;;;12     	ptr->datLength = FRAME_HEAD_LEN;
000012  201b              MOVS     r0,#0x1b
000014  8020              STRH     r0,[r4,#0]
;;;13     	ptr->data = Mem_malloc(length);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       Mem_malloc
00001c  6060              STR      r0,[r4,#4]
;;;14     	
;;;15     	ptr->data[ptr->datLength ++] = 7;             //ECU 配置文件版本号
00001e  2107              MOVS     r1,#7
000020  8822              LDRH     r2,[r4,#0]
000022  1c50              ADDS     r0,r2,#1
000024  8020              STRH     r0,[r4,#0]
000026  6860              LDR      r0,[r4,#4]
000028  5481              STRB     r1,[r0,r2]
;;;16     	ptr->data[ptr->datLength ++] = 0x60;
00002a  2160              MOVS     r1,#0x60
00002c  8822              LDRH     r2,[r4,#0]
00002e  1c50              ADDS     r0,r2,#1
000030  8020              STRH     r0,[r4,#0]
000032  6860              LDR      r0,[r4,#4]
000034  5481              STRB     r1,[r0,r2]
;;;17     	ptr->data[ptr->datLength ++] = 0x00;
000036  2100              MOVS     r1,#0
000038  8822              LDRH     r2,[r4,#0]
00003a  1c50              ADDS     r0,r2,#1
00003c  8020              STRH     r0,[r4,#0]
00003e  6860              LDR      r0,[r4,#4]
000040  5481              STRB     r1,[r0,r2]
;;;18     	
;;;19     	ptr->data[ptr->datLength ++] = (canDataConfig.pidVersion >> 24) & 0x000000FF;
000042  4811              LDR      r0,|L3.136|
000044  6800              LDR      r0,[r0,#0]  ; canDataConfig
000046  0e00              LSRS     r0,r0,#24
000048  8822              LDRH     r2,[r4,#0]
00004a  1c51              ADDS     r1,r2,#1
00004c  8021              STRH     r1,[r4,#0]
00004e  6861              LDR      r1,[r4,#4]
000050  5488              STRB     r0,[r1,r2]
;;;20     	ptr->data[ptr->datLength ++] = (canDataConfig.pidVersion >> 16) & 0x000000FF;
000052  480d              LDR      r0,|L3.136|
000054  6800              LDR      r0,[r0,#0]  ; canDataConfig
000056  f3c04107          UBFX     r1,r0,#16,#8
00005a  8822              LDRH     r2,[r4,#0]
00005c  1c50              ADDS     r0,r2,#1
00005e  8020              STRH     r0,[r4,#0]
000060  6860              LDR      r0,[r4,#4]
000062  5481              STRB     r1,[r0,r2]
;;;21     	ptr->data[ptr->datLength ++] = (canDataConfig.pidVersion >>  8) & 0x000000FF;
000064  4808              LDR      r0,|L3.136|
000066  8800              LDRH     r0,[r0,#0]  ; canDataConfig
000068  f3c02107          UBFX     r1,r0,#8,#8
00006c  8822              LDRH     r2,[r4,#0]
00006e  1c50              ADDS     r0,r2,#1
000070  8020              STRH     r0,[r4,#0]
000072  6860              LDR      r0,[r4,#4]
000074  5481              STRB     r1,[r0,r2]
;;;22     	ptr->data[ptr->datLength ++] =  canDataConfig.pidVersion & 0x000000FF;
000076  4804              LDR      r0,|L3.136|
000078  7801              LDRB     r1,[r0,#0]  ; canDataConfig
00007a  8822              LDRH     r2,[r4,#0]
00007c  1c50              ADDS     r0,r2,#1
00007e  8020              STRH     r0,[r4,#0]
000080  6860              LDR      r0,[r4,#4]
000082  5481              STRB     r1,[r0,r2]
;;;23     
;;;24     	return ptr;
000084  4620              MOV      r0,r4
;;;25     }
000086  bd70              POP      {r4-r6,pc}
;;;26     _CDMADataToSend* CDMNSendInfoInit(uint16_t length)//要发送的数据，进行初始化
                          ENDP

                  |L3.136|
                          DCD      canDataConfig

                          AREA ||i.CDMNSendInfoInit||, CODE, READONLY, ALIGN=1

                  CDMNSendInfoInit PROC
;;;25     }
;;;26     _CDMADataToSend* CDMNSendInfoInit(uint16_t length)//要发送的数据，进行初始化
000000  b570              PUSH     {r4-r6,lr}
;;;27     {
000002  4605              MOV      r5,r0
;;;28     	_CDMADataToSend* ptr = NULL;
000004  2400              MOVS     r4,#0
;;;29     	ptr = Mem_malloc(sizeof(_CDMADataToSend));
000006  2008              MOVS     r0,#8
000008  f7fffffe          BL       Mem_malloc
00000c  4604              MOV      r4,r0
;;;30     	
;;;31     	ptr->timeCount = 0;
00000e  2000              MOVS     r0,#0
000010  8060              STRH     r0,[r4,#2]
;;;32     	ptr->datLength = FRAME_HEAD_LEN;
000012  201b              MOVS     r0,#0x1b
000014  8020              STRH     r0,[r4,#0]
;;;33     	ptr->data = Mem_malloc(length);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       Mem_malloc
00001c  6060              STR      r0,[r4,#4]
;;;34     	return ptr;
00001e  4620              MOV      r0,r4
;;;35     }
000020  bd70              POP      {r4-r6,pc}
;;;36     uint32_t realTime = 0;
                          ENDP


                          AREA ||i.GlobalVarInit||, CODE, READONLY, ALIGN=2

                  GlobalVarInit PROC
;;;84     uint8_t pid2Config[300]  = {0};//此数组用来保存PID第二配置文件数据
;;;85     void GlobalVarInit(void )      //todo：全局变量初始化  不断补充，从Flash中读取需不需要更新等 (ECU版本)
000000  b570              PUSH     {r4-r6,lr}
;;;86     {    
;;;87     	uint8_t *ptrMode;
;;;88     	uint8_t offset = 0;
000002  2400              MOVS     r4,#0
;;;89     	ptrMode = Mem_malloc(80);
000004  2050              MOVS     r0,#0x50
000006  f7fffffe          BL       Mem_malloc
00000a  4605              MOV      r5,r0
;;;90     	
;;;91     	//从Flash中载入数据进全局变量
;;;92     	Flash_ReadDat((uint8_t *)&sysUpdateVar,SBOOT_UPGREAD_ADDR,sizeof(_SystemInformation));
00000c  2210              MOVS     r2,#0x10
00000e  4964              LDR      r1,|L5.416|
000010  4864              LDR      r0,|L5.420|
000012  f7fffffe          BL       Flash_ReadDat
;;;93     	//从Flash中读取PID参数
;;;94     	Flash_ReadDat((uint8_t *)&canDataConfig,PIDCONFIG,sizeof(_CANDataConfig));
000016  221b              MOVS     r2,#0x1b
000018  4963              LDR      r1,|L5.424|
00001a  4864              LDR      r0,|L5.428|
00001c  f7fffffe          BL       Flash_ReadDat
;;;95     	
;;;96     	PIDConfig2DataRead(configData,PID1CONFIGADDR,6000);
000020  f2417270          MOV      r2,#0x1770
000024  4962              LDR      r1,|L5.432|
000026  4863              LDR      r0,|L5.436|
000028  f7fffffe          BL       PIDConfig2DataRead
;;;97     	ptrPIDAllDat = (_OBD_PID_Cmd *)configData;
00002c  4861              LDR      r0,|L5.436|
00002e  4962              LDR      r1,|L5.440|
000030  6008              STR      r0,[r1,#0]  ; ptrPIDAllDat
;;;98     	
;;;99     	Flash_ReadDat(pid2Config,PID2CONFIGADDR,300); //读取第二配置文件数据
000032  f44f7296          MOV      r2,#0x12c
000036  4961              LDR      r1,|L5.444|
000038  4861              LDR      r0,|L5.448|
00003a  f7fffffe          BL       Flash_ReadDat
;;;100    	ptrPIDVars   = (VARConfig*)pid2Config;
00003e  4860              LDR      r0,|L5.448|
000040  4960              LDR      r1,|L5.452|
000042  6008              STR      r0,[r1,#0]  ; ptrPIDVars
;;;101    	
;;;102    	Flash_ReadDat(strengPower,STRENGE_Q,300);  //读出喷油量的原始值
000044  f44f7296          MOV      r2,#0x12c
000048  495f              LDR      r1,|L5.456|
00004a  4860              LDR      r0,|L5.460|
00004c  f7fffffe          BL       Flash_ReadDat
;;;103    	if(strengPower[0] != 0xAF)                 //从未记录过该车的喷油量
000050  485e              LDR      r0,|L5.460|
000052  7800              LDRB     r0,[r0,#0]  ; strengPower
000054  28af              CMP      r0,#0xaf
000056  d004              BEQ      |L5.98|
;;;104    		memset(strengPower,0,300);	
000058  f44f7196          MOV      r1,#0x12c
00005c  485b              LDR      r0,|L5.460|
00005e  f7fffffe          BL       __aeabi_memclr
                  |L5.98|
;;;105    	
;;;106    	Flash_ReadDat(ptrMode,PROMOTE_ADDR,80);    //读取提升动力相关参数
000062  2250              MOVS     r2,#0x50
000064  495a              LDR      r1,|L5.464|
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       Flash_ReadDat
;;;107    	memcpy(strengthFuelFlash.ecuVer,&ptrMode[offset],16);
00006c  1929              ADDS     r1,r5,r4
00006e  2210              MOVS     r2,#0x10
000070  4858              LDR      r0,|L5.468|
000072  f7fffffe          BL       __aeabi_memcpy
;;;108    	offset += 16;
000076  f1040010          ADD      r0,r4,#0x10
00007a  b2c4              UXTB     r4,r0
;;;109    	memcpy(strengthFuelFlash.fuelAddr,&ptrMode[offset],5);
00007c  1928              ADDS     r0,r5,r4
00007e  4955              LDR      r1,|L5.468|
000080  6802              LDR      r2,[r0,#0]
000082  610a              STR      r2,[r1,#0x10]  ; strengthFuelFlash
000084  7900              LDRB     r0,[r0,#4]
000086  7508              STRB     r0,[r1,#0x14]
;;;110    	offset += 5;
000088  1d60              ADDS     r0,r4,#5
00008a  b2c4              UXTB     r4,r0
;;;111    	memcpy(strengthFuelFlash.mask ,&ptrMode[offset],4);
00008c  1929              ADDS     r1,r5,r4
00008e  4851              LDR      r0,|L5.468|
000090  6809              LDR      r1,[r1,#0]
000092  f8c01015          STR      r1,[r0,#0x15]  ; strengthFuelFlash
;;;112    	offset += 4;
000096  1d20              ADDS     r0,r4,#4
000098  b2c4              UXTB     r4,r0
;;;113    	memcpy(strengthFuelFlash.safe1,&ptrMode[offset],8);
00009a  1929              ADDS     r1,r5,r4
00009c  484d              LDR      r0,|L5.468|
00009e  301a              ADDS     r0,r0,#0x1a
0000a0  680a              LDR      r2,[r1,#0]
0000a2  6002              STR      r2,[r0,#0]  ; strengthFuelFlash
0000a4  6849              LDR      r1,[r1,#4]
0000a6  6041              STR      r1,[r0,#4]  ; strengthFuelFlash
;;;114    	offset += 8;
0000a8  f1040008          ADD      r0,r4,#8
0000ac  b2c4              UXTB     r4,r0
;;;115    	memcpy(strengthFuelFlash.safe2,&ptrMode[offset],8);
0000ae  1928              ADDS     r0,r5,r4
0000b0  4948              LDR      r1,|L5.468|
0000b2  3122              ADDS     r1,r1,#0x22
0000b4  6802              LDR      r2,[r0,#0]
0000b6  600a              STR      r2,[r1,#0]  ; strengthFuelFlash
0000b8  6840              LDR      r0,[r0,#4]
0000ba  6048              STR      r0,[r1,#4]  ; strengthFuelFlash
;;;116    	offset += 8;
0000bc  f1040008          ADD      r0,r4,#8
0000c0  b2c4              UXTB     r4,r0
;;;117    	memcpy(strengthFuelFlash.mode1,&ptrMode[offset],8);
0000c2  1929              ADDS     r1,r5,r4
0000c4  4843              LDR      r0,|L5.468|
0000c6  302a              ADDS     r0,r0,#0x2a
0000c8  680a              LDR      r2,[r1,#0]
0000ca  6002              STR      r2,[r0,#0]  ; strengthFuelFlash
0000cc  6849              LDR      r1,[r1,#4]
0000ce  6041              STR      r1,[r0,#4]  ; strengthFuelFlash
;;;118    	offset += 8;
0000d0  f1040008          ADD      r0,r4,#8
0000d4  b2c4              UXTB     r4,r0
;;;119    	memcpy(strengthFuelFlash.mode2,&ptrMode[offset],8);
0000d6  1928              ADDS     r0,r5,r4
0000d8  493e              LDR      r1,|L5.468|
0000da  3132              ADDS     r1,r1,#0x32
0000dc  6802              LDR      r2,[r0,#0]
0000de  600a              STR      r2,[r1,#0]  ; strengthFuelFlash
0000e0  6840              LDR      r0,[r0,#4]
0000e2  6048              STR      r0,[r1,#4]  ; strengthFuelFlash
;;;120    	offset += 8;
0000e4  f1040008          ADD      r0,r4,#8
0000e8  b2c4              UXTB     r4,r0
;;;121    	strengthFuelFlash.modeOrder = ptrMode[offset++];
0000ea  4620              MOV      r0,r4
0000ec  1c61              ADDS     r1,r4,#1
0000ee  b2cc              UXTB     r4,r1
0000f0  5c28              LDRB     r0,[r5,r0]
0000f2  4938              LDR      r1,|L5.468|
0000f4  f881003a          STRB     r0,[r1,#0x3a]
;;;122    	Mem_free(ptrMode);
0000f8  4628              MOV      r0,r5
0000fa  f7fffffe          BL       Mem_free
;;;123    	
;;;124    	varOperation.pidNum      = canDataConfig.pidNum;//得到PID指令的个数
0000fe  482b              LDR      r0,|L5.428|
000100  8880              LDRH     r0,[r0,#4]  ; canDataConfig
000102  4935              LDR      r1,|L5.472|
000104  f8a10078          STRH     r0,[r1,#0x78]
;;;125    	varOperation.isDataFlow  = 1;              //设备启动的时候，数据流未流动
000108  2001              MOVS     r0,#1
00010a  f881002d          STRB     r0,[r1,#0x2d]
;;;126    	varOperation.isCDMAStart = CDMA_CLOSE;     //CDMA初始状态为关闭
00010e  f881002f          STRB     r0,[r1,#0x2f]
;;;127    	varOperation.isEngineRun = ENGINE_RUN;     //初始认为发动机是启动了的
000112  2000              MOVS     r0,#0
000114  f881002e          STRB     r0,[r1,#0x2e]
;;;128    	varOperation.sendId      = 0x80000000;     //发送的帧流水号
000118  f04f4000          MOV      r0,#0x80000000
00011c  65c8              STR      r0,[r1,#0x5c]  ; varOperation
;;;129    	
;;;130    	varOperation.pidVersion = canDataConfig.pidVersion;
00011e  4823              LDR      r0,|L5.428|
000120  6800              LDR      r0,[r0,#0]  ; canDataConfig
000122  f8c1007a          STR      r0,[r1,#0x7a]  ; varOperation
;;;131    	varOperation.busType    = canDataConfig.busType;
000126  4821              LDR      r0,|L5.428|
000128  7a00              LDRB     r0,[r0,#8]  ; canDataConfig
00012a  f8810086          STRB     r0,[r1,#0x86]
;;;132    	varOperation.canIdType  = canDataConfig.canIdType;
00012e  481f              LDR      r0,|L5.428|
000130  7a40              LDRB     r0,[r0,#9]  ; canDataConfig
000132  f8810087          STRB     r0,[r1,#0x87]
;;;133    	varOperation.canTxId    = canDataConfig.canTxId;
000136  481d              LDR      r0,|L5.428|
000138  f8d0000a          LDR      r0,[r0,#0xa]  ; canDataConfig
00013c  f8c10088          STR      r0,[r1,#0x88]  ; varOperation
;;;134    	varOperation.canRxId    = canDataConfig.canRxId;
000140  481a              LDR      r0,|L5.428|
000142  f8d0000e          LDR      r0,[r0,#0xe]  ; canDataConfig
000146  f8c1008c          STR      r0,[r1,#0x8c]  ; varOperation
;;;135    	varOperation.canBaud    = canDataConfig.canBaud;
00014a  4818              LDR      r0,|L5.428|
00014c  7c80              LDRB     r0,[r0,#0x12]  ; canDataConfig
00014e  f8810090          STRB     r0,[r1,#0x90]
;;;136    	varOperation.oilMode    = 0;  //默认正常模式
000152  2000              MOVS     r0,#0
000154  f8810098          STRB     r0,[r1,#0x98]
;;;137    	varOperation.isStrenOilOK = 0;//默认不可以进行动力提升
000158  f8810099          STRB     r0,[r1,#0x99]
;;;138    	varOperation.strengthRun = 0;
00015c  f8810094          STRB     r0,[r1,#0x94]
;;;139    	varOperation.datOKLeng   = 0;
000160  f8a10096          STRH     r0,[r1,#0x96]
;;;140    	varOperation.pidRun      = 1;
000164  2001              MOVS     r0,#1
000166  f8810095          STRB     r0,[r1,#0x95]
;;;141    	memset(varOperation.ecuVersion,0,20);
00016a  2114              MOVS     r1,#0x14
00016c  481a              LDR      r0,|L5.472|
00016e  3064              ADDS     r0,r0,#0x64
000170  f7fffffe          BL       __aeabi_memclr
;;;142    	
;;;143    	varOperation.pidVarNum  = canDataConfig.pidVarNum;
000174  480d              LDR      r0,|L5.428|
000176  88c0              LDRH     r0,[r0,#6]  ; canDataConfig
000178  4917              LDR      r1,|L5.472|
00017a  f8a10084          STRH     r0,[r1,#0x84]
;;;144    	
;;;145    	varOperation.ipPotr = IP_Port;             //todo:后期是域名解析  初始化端口号
00017e  f242700e          MOV      r0,#0x270e
000182  f8a10044          STRH     r0,[r1,#0x44]
;;;146    	memset(varOperation.ipAddr,0,18);
000186  2112              MOVS     r1,#0x12
000188  4813              LDR      r0,|L5.472|
00018a  3032              ADDS     r0,r0,#0x32
00018c  f7fffffe          BL       __aeabi_memclr
;;;147    	memcpy(varOperation.ipAddr,ipAddr,sizeof(ipAddr));//todo：IP地址，程序升级后用flash中的IP及端口号	//采用域名解析了
000190  220e              MOVS     r2,#0xe
000192  4912              LDR      r1,|L5.476|
000194  4810              LDR      r0,|L5.472|
000196  3032              ADDS     r0,r0,#0x32
000198  f7fffffe          BL       __aeabi_memcpy
;;;148    }
00019c  bd70              POP      {r4-r6,pc}
;;;149     uint8_t* RecvDataAnalysis(uint8_t* ptrDataToDeal)//解析接收到的数据包
                          ENDP

00019e  0000              DCW      0x0000
                  |L5.416|
                          DCD      0x08007800
                  |L5.420|
                          DCD      sysUpdateVar
                  |L5.424|
                          DCD      0x08060800
                  |L5.428|
                          DCD      canDataConfig
                  |L5.432|
                          DCD      0x08063000
                  |L5.436|
                          DCD      configData
                  |L5.440|
                          DCD      ptrPIDAllDat
                  |L5.444|
                          DCD      0x08061000
                  |L5.448|
                          DCD      pid2Config
                  |L5.452|
                          DCD      ptrPIDVars
                  |L5.456|
                          DCD      0x08060000
                  |L5.460|
                          DCD      strengPower
                  |L5.464|
                          DCD      0x08065000
                  |L5.468|
                          DCD      strengthFuelFlash
                  |L5.472|
                          DCD      varOperation
                  |L5.476|
                          DCD      ipAddr

                          AREA ||i.LogReport||, CODE, READONLY, ALIGN=2

                  LogReport PROC
;;;261    
;;;262    void LogReport(char* fmt,...)          //上传日志文件
000000  b40f              PUSH     {r0-r3}
;;;263    {
000002  b57c              PUSH     {r2-r6,lr}
;;;264    	u8 datLen,err;
;;;265    	va_list ap;
;;;266    	uint8_t * ptrSaveLog;
;;;267    
;;;268    	if(cdmaDataToSend->datLength > 750)
000004  4821              LDR      r0,|L6.140|
000006  6800              LDR      r0,[r0,#0]  ; cdmaDataToSend
000008  8800              LDRH     r0,[r0,#0]
00000a  f24021ee          MOV      r1,#0x2ee
00000e  4288              CMP      r0,r1
000010  dd02              BLE      |L6.24|
                  |L6.18|
;;;269    		return;
;;;270    	ptrSaveLog = Mem_malloc(255);
;;;271    	va_start(ap,fmt);
;;;272    	vsprintf((char*)ptrSaveLog,fmt,ap);
;;;273    	va_end(ap);
;;;274    	
;;;275    	datLen=strlen((const char*)ptrSaveLog);//此次发送数据的长度
;;;276    	
;;;277    	OSMutexPend(CDMASendMutex,0,&err);
;;;278    	
;;;279    	if((datLen + cdmaLogData->top) < 900)				
;;;280    	{
;;;281    		memcpy(&cdmaLogData->base[cdmaLogData->top],ptrSaveLog,datLen);
;;;282    		cdmaLogData->top += datLen;
;;;283    	}
;;;284    	OSMutexPost(CDMASendMutex);
;;;285    	Mem_free(ptrSaveLog);
;;;286    }
000012  bc7c              POP      {r2-r6}
000014  f85dfb14          LDR      pc,[sp],#0x14
                  |L6.24|
000018  20ff              MOVS     r0,#0xff              ;270
00001a  f7fffffe          BL       Mem_malloc
00001e  4605              MOV      r5,r0                 ;270
000020  a807              ADD      r0,sp,#0x1c           ;271
000022  9000              STR      r0,[sp,#0]            ;271
000024  4628              MOV      r0,r5                 ;272
000026  9a00              LDR      r2,[sp,#0]            ;272
000028  9906              LDR      r1,[sp,#0x18]         ;272
00002a  f7fffffe          BL       __c89vsprintf
00002e  2000              MOVS     r0,#0                 ;273
000030  9000              STR      r0,[sp,#0]            ;273
000032  4628              MOV      r0,r5                 ;275
000034  f7fffffe          BL       strlen
000038  b2c4              UXTB     r4,r0                 ;275
00003a  aa01              ADD      r2,sp,#4              ;277
00003c  2100              MOVS     r1,#0                 ;277
00003e  4814              LDR      r0,|L6.144|
000040  6800              LDR      r0,[r0,#0]            ;277  ; CDMASendMutex
000042  f7fffffe          BL       OSMutexPend
000046  4813              LDR      r0,|L6.148|
000048  6800              LDR      r0,[r0,#0]            ;279  ; cdmaLogData
00004a  8800              LDRH     r0,[r0,#0]            ;279
00004c  4420              ADD      r0,r0,r4              ;279
00004e  f5b07f61          CMP      r0,#0x384             ;279
000052  da11              BGE      |L6.120|
000054  490f              LDR      r1,|L6.148|
000056  6809              LDR      r1,[r1,#0]            ;281  ; cdmaLogData
000058  6849              LDR      r1,[r1,#4]            ;281
00005a  4a0e              LDR      r2,|L6.148|
00005c  6812              LDR      r2,[r2,#0]            ;281  ; cdmaLogData
00005e  8812              LDRH     r2,[r2,#0]            ;281
000060  1888              ADDS     r0,r1,r2              ;281
000062  4622              MOV      r2,r4                 ;281
000064  4629              MOV      r1,r5                 ;281
000066  f7fffffe          BL       __aeabi_memcpy
00006a  480a              LDR      r0,|L6.148|
00006c  6800              LDR      r0,[r0,#0]            ;282  ; cdmaLogData
00006e  8800              LDRH     r0,[r0,#0]            ;282
000070  4420              ADD      r0,r0,r4              ;282
000072  4908              LDR      r1,|L6.148|
000074  6809              LDR      r1,[r1,#0]            ;282  ; cdmaLogData
000076  8008              STRH     r0,[r1,#0]            ;282
                  |L6.120|
000078  4805              LDR      r0,|L6.144|
00007a  6800              LDR      r0,[r0,#0]            ;284  ; CDMASendMutex
00007c  f7fffffe          BL       OSMutexPost
000080  4628              MOV      r0,r5                 ;285
000082  f7fffffe          BL       Mem_free
000086  bf00              NOP      
000088  e7c3              B        |L6.18|
;;;287    
                          ENDP

00008a  0000              DCW      0x0000
                  |L6.140|
                          DCD      cdmaDataToSend
                  |L6.144|
                          DCD      CDMASendMutex
                  |L6.148|
                          DCD      cdmaLogData

                          AREA ||i.MemLog||, CODE, READONLY, ALIGN=2

                  MemLog PROC
;;;290    
;;;291    void MemLog(_CDMADataToSend* ptr)
000000  b51f              PUSH     {r0-r4,lr}
;;;292    {
000002  4604              MOV      r4,r0
;;;293    	LogReport("\r\n03-1:%d;2:%d;3:%d;4:%d;5:%d;6:%d;7:%d;",\
000004  4809              LDR      r0,|L7.44|
000006  7bc0              LDRB     r0,[r0,#0xf]  ; allMemState
000008  4908              LDR      r1,|L7.44|
00000a  7b49              LDRB     r1,[r1,#0xd]  ; allMemState
00000c  4a07              LDR      r2,|L7.44|
00000e  7ad2              LDRB     r2,[r2,#0xb]  ; allMemState
000010  4b06              LDR      r3,|L7.44|
000012  7a5b              LDRB     r3,[r3,#9]  ; allMemState
000014  e9cd3200          STRD     r3,r2,[sp,#0]
000018  e9cd1002          STRD     r1,r0,[sp,#8]
00001c  4803              LDR      r0,|L7.44|
00001e  79c3              LDRB     r3,[r0,#7]  ; allMemState
000020  7942              LDRB     r2,[r0,#5]  ; allMemState
000022  8841              LDRH     r1,[r0,#2]  ; allMemState
000024  a002              ADR      r0,|L7.48|
000026  f7fffffe          BL       LogReport
;;;294    			allMemState.memUsedMax1,\
;;;295    			allMemState.memUsedMax2,\
;;;296    			allMemState.memUsedMax3,\
;;;297    			allMemState.memUsedMax4,\
;;;298    			allMemState.memUsedMax5,\
;;;299    			allMemState.memUsedMax6,\
;;;300    			allMemState.memUsedMax7);
;;;301    }
00002a  bd1f              POP      {r0-r4,pc}
;;;302    //车辆运行的数据 初始化
                          ENDP

                  |L7.44|
                          DCD      allMemState
                  |L7.48|
000030  0d0a3033          DCB      "\r\n03-1:%d;2:%d;3:%d;4:%d;5:%d;6:%d;7:%d;",0
000034  2d313a25
000038  643b323a
00003c  25643b33
000040  3a25643b
000044  343a2564
000048  3b353a25
00004c  643b363a
000050  25643b37
000054  3a25643b
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.RecvDataAnalysis||, CODE, READONLY, ALIGN=1

                  RecvDataAnalysis PROC
;;;148    }
;;;149     uint8_t* RecvDataAnalysis(uint8_t* ptrDataToDeal)//解析接收到的数据包
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;150    {
000004  4605              MOV      r5,r0
;;;151    	uint16_t i = 0;
000006  2600              MOVS     r6,#0
;;;152    	uint16_t datLen   = 0;
000008  2400              MOVS     r4,#0
;;;153    	uint16_t crcDat   = 0;
00000a  46a0              MOV      r8,r4
;;;154    	uint16_t crcCheck = 0;
00000c  46a1              MOV      r9,r4
;;;155    	uint8_t* ptr = NULL;
00000e  2700              MOVS     r7,#0
;;;156    	while(1)
000010  e00e              B        |L8.48|
                  |L8.18|
;;;157    	{
;;;158    		if(ptrDataToDeal[i++] == 0x7E)
000012  4630              MOV      r0,r6
000014  1c71              ADDS     r1,r6,#1
000016  b28e              UXTH     r6,r1
000018  5c28              LDRB     r0,[r5,r0]
00001a  287e              CMP      r0,#0x7e
00001c  d100              BNE      |L8.32|
;;;159    			break;
00001e  e008              B        |L8.50|
                  |L8.32|
;;;160    		if(i >= 60)
000020  2e3c              CMP      r6,#0x3c
000022  db05              BLT      |L8.48|
;;;161    		{
;;;162    			Mem_free(ptrDataToDeal);
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       Mem_free
;;;163    			return NULL;
00002a  2000              MOVS     r0,#0
                  |L8.44|
;;;164    		}
;;;165    	}
;;;166    	datLen   = ptrDataToDeal[i++];
;;;167    	datLen   = (datLen << 8) + ptrDataToDeal[i--];
;;;168    	crcCheck = CRC_Compute16(&ptrDataToDeal[i],datLen + 2);
;;;169    	
;;;170    	crcDat   = ptrDataToDeal[i + datLen +2];
;;;171    	crcDat   = (crcDat << 8) + ptrDataToDeal[i + datLen +3];
;;;172    	if(crcCheck != crcDat)
;;;173    	{
;;;174    		Mem_free(ptrDataToDeal);
;;;175    		return NULL;
;;;176    	}
;;;177    	ptr = Mem_malloc(datLen);
;;;178    	datLen = datLen - 24;
;;;179    	ptr[0] = (datLen >> 8)  & 0x00FF;
;;;180    	ptr[1] = datLen & 0x00FF;
;;;181    	memcpy(&ptr[2],&ptrDataToDeal[i + 26],datLen);
;;;182    	
;;;183    	Mem_free(ptrDataToDeal);
;;;184    	return ptr;
;;;185    }
00002c  e8bd87f0          POP      {r4-r10,pc}
                  |L8.48|
000030  e7ef              B        |L8.18|
                  |L8.50|
000032  bf00              NOP                            ;159
000034  4630              MOV      r0,r6                 ;166
000036  1c71              ADDS     r1,r6,#1              ;166
000038  b28e              UXTH     r6,r1                 ;166
00003a  5c2c              LDRB     r4,[r5,r0]            ;166
00003c  4630              MOV      r0,r6                 ;167
00003e  1e71              SUBS     r1,r6,#1              ;167
000040  b28e              UXTH     r6,r1                 ;167
000042  5c28              LDRB     r0,[r5,r0]            ;167
000044  eb002004          ADD      r0,r0,r4,LSL #8       ;167
000048  b284              UXTH     r4,r0                 ;167
00004a  19a8              ADDS     r0,r5,r6              ;168
00004c  1ca1              ADDS     r1,r4,#2              ;168
00004e  f7fffffe          BL       CRC_Compute16
000052  4681              MOV      r9,r0                 ;168
000054  1930              ADDS     r0,r6,r4              ;170
000056  1c80              ADDS     r0,r0,#2              ;170
000058  f8158000          LDRB     r8,[r5,r0]            ;170
00005c  1930              ADDS     r0,r6,r4              ;171
00005e  1cc0              ADDS     r0,r0,#3              ;171
000060  5c28              LDRB     r0,[r5,r0]            ;171
000062  eb002008          ADD      r0,r0,r8,LSL #8       ;171
000066  fa1ff880          UXTH     r8,r0                 ;171
00006a  45c1              CMP      r9,r8                 ;172
00006c  d004              BEQ      |L8.120|
00006e  4628              MOV      r0,r5                 ;174
000070  f7fffffe          BL       Mem_free
000074  2000              MOVS     r0,#0                 ;175
000076  e7d9              B        |L8.44|
                  |L8.120|
000078  4620              MOV      r0,r4                 ;177
00007a  f7fffffe          BL       Mem_malloc
00007e  4607              MOV      r7,r0                 ;177
000080  f1a40018          SUB      r0,r4,#0x18           ;178
000084  b284              UXTH     r4,r0                 ;178
000086  0a20              LSRS     r0,r4,#8              ;179
000088  7038              STRB     r0,[r7,#0]            ;179
00008a  707c              STRB     r4,[r7,#1]            ;180
00008c  f106001a          ADD      r0,r6,#0x1a           ;181
000090  1829              ADDS     r1,r5,r0              ;181
000092  4622              MOV      r2,r4                 ;181
000094  1cb8              ADDS     r0,r7,#2              ;181
000096  f7fffffe          BL       __aeabi_memcpy
00009a  4628              MOV      r0,r5                 ;183
00009c  f7fffffe          BL       Mem_free
0000a0  4638              MOV      r0,r7                 ;184
0000a2  e7c3              B        |L8.44|
;;;186    
                          ENDP


                          AREA ||i.RevolvingSpeedDeal||, CODE, READONLY, ALIGN=2

                  RevolvingSpeedDeal PROC
;;;191    
;;;192    void RevolvingSpeedDeal(void)//todo:发动机转速处理
000000  b570              PUSH     {r4-r6,lr}
;;;193    {
;;;194    	static uint8_t openClose = 0;
;;;195    	static uint8_t loginFlag = 0;
;;;196    //	uint8_t err;
;;;197    	uint32_t currentTime = 0;  //当前时间
000002  2500              MOVS     r5,#0
;;;198    	uint32_t currentHour = 0;//当前小时     0点-1点   发送登录报文，请求升级
000004  2400              MOVS     r4,#0
;;;199    	
;;;200    	currentTime = RTC_GetCounter();
000006  f7fffffe          BL       RTC_GetCounter
00000a  4605              MOV      r5,r0
;;;201    	currentHour = (currentTime/3600) %24;  //得到当前的小时数
00000c  f44f6061          MOV      r0,#0xe10
000010  fbb5f0f0          UDIV     r0,r5,r0
000014  2118              MOVS     r1,#0x18
000016  fbb0f2f1          UDIV     r2,r0,r1
00001a  fb010412          MLS      r4,r1,r2,r0
;;;202    	if(currentHour > 0)
00001e  b114              CBZ      r4,|L9.38|
;;;203    		loginFlag = 0;
000020  2000              MOVS     r0,#0
000022  493b              LDR      r1,|L9.272|
000024  7008              STRB     r0,[r1,#0]
                  |L9.38|
;;;204    	
;;;205    	if(varOperation.isEngineRun == ENGINE_RUN)//发动机正在运行中
000026  483b              LDR      r0,|L9.276|
000028  f890002e          LDRB     r0,[r0,#0x2e]  ; varOperation
00002c  bb20              CBNZ     r0,|L9.120|
;;;206    	{
;;;207    		if(openClose != 1)
00002e  483a              LDR      r0,|L9.280|
000030  7800              LDRB     r0,[r0,#0]  ; openClose
000032  2801              CMP      r0,#1
000034  d06a              BEQ      |L9.268|
;;;208    		{
;;;209    			openClose = 1;
000036  2001              MOVS     r0,#1
000038  4937              LDR      r1,|L9.280|
00003a  7008              STRB     r0,[r1,#0]
;;;210    			//todo:打开CDMA电源、GPS电源、数据流动标志、三个小灯
;;;211    			freOBDLed  = 100;
00003c  2064              MOVS     r0,#0x64
00003e  4937              LDR      r1,|L9.284|
000040  8008              STRH     r0,[r1,#0]
;;;212    			freCDMALed = 100;
000042  4937              LDR      r1,|L9.288|
000044  8008              STRH     r0,[r1,#0]
;;;213    			freGPSLed  = 100;
000046  4937              LDR      r1,|L9.292|
000048  8008              STRH     r0,[r1,#0]
;;;214    			OSTaskResume(CDMA_LED_PRIO);
00004a  2014              MOVS     r0,#0x14
00004c  f7fffffe          BL       OSTaskResume
;;;215    			OSTaskResume(GPS_LED_PRIO);
000050  2015              MOVS     r0,#0x15
000052  f7fffffe          BL       OSTaskResume
;;;216    			OSTaskResume(OBD_LED_PRIO);
000056  2016              MOVS     r0,#0x16
000058  f7fffffe          BL       OSTaskResume
;;;217    			
;;;218    			CDMAPowerOpen_Close(CDMA_OPEN);//打开CDMA电源
00005c  2000              MOVS     r0,#0
00005e  f7fffffe          BL       CDMAPowerOpen_Close
;;;219    			CDMAConfigInit();              //初始化CDMA
000062  f7fffffe          BL       CDMAConfigInit
;;;220    			OSTaskResume(CDMA_TASK_PRIO);  //回复CDMA发送任务
000066  200b              MOVS     r0,#0xb
000068  f7fffffe          BL       OSTaskResume
;;;221    			
;;;222    			GPS_POWER_ON;  //打开
00006c  f44f7180          MOV      r1,#0x100
000070  482d              LDR      r0,|L9.296|
000072  f7fffffe          BL       GPIO_ResetBits
000076  e049              B        |L9.268|
                  |L9.120|
;;;223    		}
;;;224    	}
;;;225    	else if(varOperation.isEngineRun == ENGINE_STOP)//发动机已停止运行
000078  4826              LDR      r0,|L9.276|
00007a  f890002e          LDRB     r0,[r0,#0x2e]  ; varOperation
00007e  2801              CMP      r0,#1
000080  d144              BNE      |L9.268|
;;;226    	{
;;;227    		if(currentHour == 0 && loginFlag == 0 && openClose == 0)//零点到,CDMA已关闭，发送登录报文
000082  b9a4              CBNZ     r4,|L9.174|
000084  4822              LDR      r0,|L9.272|
000086  7800              LDRB     r0,[r0,#0]  ; loginFlag
000088  b988              CBNZ     r0,|L9.174|
00008a  4823              LDR      r0,|L9.280|
00008c  7800              LDRB     r0,[r0,#0]  ; openClose
00008e  b970              CBNZ     r0,|L9.174|
;;;228    		{
;;;229    			loginFlag = 1;
000090  2001              MOVS     r0,#1
000092  491f              LDR      r1,|L9.272|
000094  7008              STRB     r0,[r1,#0]
;;;230    			openClose = 1;
000096  4920              LDR      r1,|L9.280|
000098  7008              STRB     r0,[r1,#0]
;;;231    			CDMAPowerOpen_Close(CDMA_OPEN);//打开CDMA电源
00009a  2000              MOVS     r0,#0
00009c  f7fffffe          BL       CDMAPowerOpen_Close
;;;232    			CDMAConfigInit();              //初始化CDMA
0000a0  f7fffffe          BL       CDMAConfigInit
;;;233    			OSTaskResume(CDMA_TASK_PRIO);  //回复CDMA发送任务
0000a4  200b              MOVS     r0,#0xb
0000a6  f7fffffe          BL       OSTaskResume
;;;234    			LoginDataSend();               //发送登录报文
0000aa  f7fffffe          BL       LoginDataSend
                  |L9.174|
;;;235    		}
;;;236    		if(openClose != 0 && varOperation.isLoginDeal == 1)//需要关闭并且无正在处理的登录报文
0000ae  481a              LDR      r0,|L9.280|
0000b0  7800              LDRB     r0,[r0,#0]  ; openClose
0000b2  b358              CBZ      r0,|L9.268|
0000b4  4817              LDR      r0,|L9.276|
0000b6  f8900030          LDRB     r0,[r0,#0x30]  ; varOperation
0000ba  2801              CMP      r0,#1
0000bc  d126              BNE      |L9.268|
;;;237    		{
;;;238    			openClose = 0;
0000be  2000              MOVS     r0,#0
0000c0  4915              LDR      r1,|L9.280|
0000c2  7008              STRB     r0,[r1,#0]
;;;239    			varOperation.isDataFlow  = 1; //禁止数据流
0000c4  2001              MOVS     r0,#1
0000c6  4913              LDR      r1,|L9.276|
0000c8  f881002d          STRB     r0,[r1,#0x2d]
;;;240    			GPS_POWER_OFF;                //关闭GPS电源
0000cc  0201              LSLS     r1,r0,#8
0000ce  4816              LDR      r0,|L9.296|
0000d0  f7fffffe          BL       GPIO_SetBits
;;;241    			
;;;242    			OSTimeDlyHMSM(0,0,5,0);       //5s的时间，应该能将所有要发送的数据都发送完毕了
0000d4  2300              MOVS     r3,#0
0000d6  2205              MOVS     r2,#5
0000d8  4619              MOV      r1,r3
0000da  4618              MOV      r0,r3
0000dc  f7fffffe          BL       OSTimeDlyHMSM
;;;243    			
;;;244    			//todo：关闭CDMA电源、GPS电源、数据流动标志、三个小灯任务挂起并关闭
;;;245    		
;;;246    			OSTaskSuspend(GPS_TASK_PRIO);     //挂起GPS任务
0000e0  200e              MOVS     r0,#0xe
0000e2  f7fffffe          BL       OSTaskSuspend
;;;247    			
;;;248    			OSTaskSuspend(CDMA_TASK_PRIO);    //挂起CDMA任务
0000e6  200b              MOVS     r0,#0xb
0000e8  f7fffffe          BL       OSTaskSuspend
;;;249    			CDMAPowerOpen_Close(CDMA_CLOSE);  //关闭CDMA电源
0000ec  2001              MOVS     r0,#1
0000ee  f7fffffe          BL       CDMAPowerOpen_Close
;;;250    			
;;;251    			//挂起LED灯
;;;252    			OSTaskSuspend(CDMA_LED_PRIO);
0000f2  2014              MOVS     r0,#0x14
0000f4  f7fffffe          BL       OSTaskSuspend
;;;253    			OSTaskSuspend(GPS_LED_PRIO);
0000f8  2015              MOVS     r0,#0x15
0000fa  f7fffffe          BL       OSTaskSuspend
;;;254    			OSTaskSuspend(OBD_LED_PRIO);
0000fe  2016              MOVS     r0,#0x16
000100  f7fffffe          BL       OSTaskSuspend
;;;255    			GPIO_SetBits(GPIOB,GPIO_Pin_0 | GPIO_Pin_3 | GPIO_Pin_5 | GPIO_Pin_4);//关闭所有小灯
000104  2139              MOVS     r1,#0x39
000106  4809              LDR      r0,|L9.300|
000108  f7fffffe          BL       GPIO_SetBits
                  |L9.268|
;;;256    			
;;;257    			//关闭LED灯光提示  发送蜂鸣器关机提示音  
;;;258    		}
;;;259    	}
;;;260    }
00010c  bd70              POP      {r4-r6,pc}
;;;261    
                          ENDP

00010e  0000              DCW      0x0000
                  |L9.272|
                          DCD      loginFlag
                  |L9.276|
                          DCD      varOperation
                  |L9.280|
                          DCD      openClose
                  |L9.284|
                          DCD      freOBDLed
                  |L9.288|
                          DCD      freCDMALed
                  |L9.292|
                          DCD      freGPSLed
                  |L9.296|
                          DCD      0x40011000
                  |L9.300|
                          DCD      0x40010c00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  configData
                          %        6000
                  strengPower
                          %        300
                  pid2Config
                          %        300

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ipAddr
000000  3131362e          DCB      0x31,0x31,0x36,0x2e
000004  36322e31          DCB      0x36,0x32,0x2e,0x31
000008  39352e39          DCB      0x39,0x35,0x2e,0x39
00000c  3900              DCB      0x39,0x00
                  proIPAddr
00000e  7463              DCB      0x74,0x63
000010  702e3531          DCB      0x70,0x2e,0x35,0x31
000014  676f6e67          DCB      0x67,0x6f,0x6e,0x67
000018  6775692e          DCB      0x67,0x75,0x69,0x2e
00001c  636f6d00          DCB      0x63,0x6f,0x6d,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  realTime
                          DCD      0x00000000
                  ||crc||
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  ptrPIDAllDat
                          DCD      0x00000000
                  ptrPIDVars
                          DCD      0x00000000
                  openClose
000010  00                DCB      0x00
                  loginFlag
000011  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\DEAL\\varDeal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_varDeal_c_4d905525____REV16|
#line 465 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.2.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_varDeal_c_4d905525____REV16| PROC
#line 466

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_varDeal_c_4d905525____REVSH|
#line 480
|__asm___9_varDeal_c_4d905525____REVSH| PROC
#line 481

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_varDeal_c_4d905525____RRX|
#line 667
|__asm___9_varDeal_c_4d905525____RRX| PROC
#line 668

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
