; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\cdma_tx_rx.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=..\obj\cdma_tx_rx.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\OBD -I..\SYSTEM -I..\USER -I..\LIB\inc -I..\UCOSII\CONFIG -I..\UCOSII\PORT -I..\UCOSII\CORE -I..\HAEDWARE -I..\GPS -I..\CDMA -I..\DEAL -I..\USB\CONFIG -I..\USB\STM32_USB-FS-Device_Driver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\cdma_tx_rx.crf ..\CDMA\CDMA_Tx_Rx.c]
                          THUMB

                          AREA ||i.CDMASendByte||, CODE, READONLY, ALIGN=2

                  CDMASendByte PROC
;;;7      
;;;8      void CDMASendByte(uint8_t dat)
000000  b570              PUSH     {r4-r6,lr}
;;;9      {
000002  4604              MOV      r4,r0
;;;10     #if OS_CRITICAL_METHOD == 3u           /* Allocate storage for CPU status register           */
;;;11     	OS_CPU_SR  cpu_sr = 0u;
000004  2500              MOVS     r5,#0
;;;12     #endif
;;;13     	if(CirQ_GetLength(sendCDMA_Q)>0)
000006  480b              LDR      r0,|L1.52|
000008  6800              LDR      r0,[r0,#0]  ; sendCDMA_Q
00000a  f7fffffe          BL       CirQ_GetLength
00000e  2800              CMP      r0,#0
000010  dd0b              BLE      |L1.42|
;;;14     	{
;;;15     		OS_ENTER_CRITICAL();
000012  f7fffffe          BL       OS_CPU_SR_Save
000016  4605              MOV      r5,r0
;;;16     		CirQ_OnePush(sendCDMA_Q,dat);
000018  4621              MOV      r1,r4
00001a  4806              LDR      r0,|L1.52|
00001c  6800              LDR      r0,[r0,#0]  ; sendCDMA_Q
00001e  f7fffffe          BL       CirQ_OnePush
;;;17     		OS_EXIT_CRITICAL();
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       OS_CPU_SR_Restore
000028  e003              B        |L1.50|
                  |L1.42|
;;;18     	}
;;;19     	else
;;;20     		USART_SendData(USART2, dat);
00002a  4621              MOV      r1,r4
00002c  4802              LDR      r0,|L1.56|
00002e  f7fffffe          BL       USART_SendData
                  |L1.50|
;;;21     }
000032  bd70              POP      {r4-r6,pc}
;;;22     uint8_t CDMASendDatas(const uint8_t* s,uint16_t length)
                          ENDP

                  |L1.52|
                          DCD      sendCDMA_Q
                  |L1.56|
                          DCD      0x40004400

                          AREA ||i.CDMASendDatas||, CODE, READONLY, ALIGN=2

                  CDMASendDatas PROC
;;;21     }
;;;22     uint8_t CDMASendDatas(const uint8_t* s,uint16_t length)
000000  b570              PUSH     {r4-r6,lr}
;;;23     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;24     #if OS_CRITICAL_METHOD == 3u           /* Allocate storage for CPU status register           */
;;;25     	OS_CPU_SR  cpu_sr = 0u;
000006  2600              MOVS     r6,#0
;;;26     #endif
;;;27     //	uint8_t data;
;;;28     	if(length < 1 || length >1020)
000008  2c01              CMP      r4,#1
00000a  db02              BLT      |L2.18|
00000c  f5b47f7f          CMP      r4,#0x3fc
000010  dd01              BLE      |L2.22|
                  |L2.18|
;;;29     		return 1;
000012  2001              MOVS     r0,#1
                  |L2.20|
;;;30     	OS_ENTER_CRITICAL();
;;;31     	
;;;32     	if(CirQ_Pushs(sendCDMA_Q,s,length) != OK)
;;;33     	{
;;;34     		OS_EXIT_CRITICAL();
;;;35     		return 2;
;;;36     	}
;;;37     	OS_EXIT_CRITICAL();
;;;38     	if(CirQ_GetLength(sendCDMA_Q) > 0)
;;;39     	{
;;;40     		USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
;;;41     	}
;;;42     	return  0;
;;;43     }
000014  bd70              POP      {r4-r6,pc}
                  |L2.22|
000016  f7fffffe          BL       OS_CPU_SR_Save
00001a  4606              MOV      r6,r0                 ;30
00001c  4622              MOV      r2,r4                 ;32
00001e  4629              MOV      r1,r5                 ;32
000020  480d              LDR      r0,|L2.88|
000022  6800              LDR      r0,[r0,#0]            ;32  ; sendCDMA_Q
000024  f7fffffe          BL       CirQ_Pushs
000028  b120              CBZ      r0,|L2.52|
00002a  4630              MOV      r0,r6                 ;34
00002c  f7fffffe          BL       OS_CPU_SR_Restore
000030  2002              MOVS     r0,#2                 ;35
000032  e7ef              B        |L2.20|
                  |L2.52|
000034  4630              MOV      r0,r6                 ;37
000036  f7fffffe          BL       OS_CPU_SR_Restore
00003a  4807              LDR      r0,|L2.88|
00003c  6800              LDR      r0,[r0,#0]            ;38  ; sendCDMA_Q
00003e  f7fffffe          BL       CirQ_GetLength
000042  2800              CMP      r0,#0                 ;38
000044  dd05              BLE      |L2.82|
000046  2201              MOVS     r2,#1                 ;40
000048  f2407127          MOV      r1,#0x727             ;40
00004c  4803              LDR      r0,|L2.92|
00004e  f7fffffe          BL       USART_ITConfig
                  |L2.82|
000052  2000              MOVS     r0,#0                 ;42
000054  e7de              B        |L2.20|
;;;44     
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      sendCDMA_Q
                  |L2.92|
                          DCD      0x40004400

                          AREA ||i.TIM4_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM4_IRQHandler PROC
;;;106    uint16_t offadf = 0;
;;;107    void TIM4_IRQHandler(void)   //CDMA接收超时处理定时器中断
000000  b510              PUSH     {r4,lr}
;;;108    {
;;;109    	OSIntEnter();//系统进入中断服务程序
000002  f7fffffe          BL       OSIntEnter
;;;110    	if (TIM_GetITStatus(TIM4, TIM_IT_Update) != RESET)  //检查TIM4更新中断发生与否
000006  2101              MOVS     r1,#1
000008  483b              LDR      r0,|L3.248|
00000a  f7fffffe          BL       TIM_GetITStatus
00000e  2800              CMP      r0,#0
000010  d06f              BEQ      |L3.242|
;;;111    	{
;;;112    		TIM_ClearITPendingBit(TIM4, TIM_IT_Update  );  //清除TIMx更新中断标志 
000012  2101              MOVS     r1,#1
000014  4838              LDR      r0,|L3.248|
000016  f7fffffe          BL       TIM_ClearITPendingBit
;;;113    		rxTimeOut ++;
00001a  4838              LDR      r0,|L3.252|
00001c  8800              LDRH     r0,[r0,#0]  ; rxTimeOut
00001e  1c40              ADDS     r0,r0,#1
000020  4936              LDR      r1,|L3.252|
000022  8008              STRH     r0,[r1,#0]
;;;114    		if(rxTimeOut > 2)
000024  4608              MOV      r0,r1
000026  8800              LDRH     r0,[r0,#0]  ; rxTimeOut
000028  2802              CMP      r0,#2
00002a  dd62              BLE      |L3.242|
;;;115    		{
;;;116    			rxTimeOut = 0;
00002c  2000              MOVS     r0,#0
00002e  8008              STRH     r0,[r1,#0]
;;;117    			receDatalen = Store_Getlength(receCDMA_S);
000030  4833              LDR      r0,|L3.256|
000032  6800              LDR      r0,[r0,#0]  ; receCDMA_S
000034  f7fffffe          BL       Store_Getlength
000038  4932              LDR      r1,|L3.260|
00003a  8008              STRH     r0,[r1,#0]
;;;118    			if(receDatalen>2 )
00003c  4608              MOV      r0,r1
00003e  8800              LDRH     r0,[r0,#0]  ; receDatalen
000040  2802              CMP      r0,#2
000042  dd4e              BLE      |L3.226|
;;;119    			{
;;;120    				ptrRece = Mem_malloc(receDatalen);
000044  4608              MOV      r0,r1
000046  8800              LDRH     r0,[r0,#0]  ; receDatalen
000048  f7fffffe          BL       Mem_malloc
00004c  492e              LDR      r1,|L3.264|
00004e  6008              STR      r0,[r1,#0]  ; ptrRece
;;;121    				if(ptrRece != NULL)//内存块申请成功
000050  4608              MOV      r0,r1
000052  6800              LDR      r0,[r0,#0]  ; ptrRece
000054  2800              CMP      r0,#0
000056  d03f              BEQ      |L3.216|
;;;122    				{
;;;123    					Store_Getdates(receCDMA_S,ptrRece,receDatalen);
000058  482a              LDR      r0,|L3.260|
00005a  8802              LDRH     r2,[r0,#0]  ; receDatalen
00005c  4608              MOV      r0,r1
00005e  6801              LDR      r1,[r0,#0]  ; ptrRece
000060  4827              LDR      r0,|L3.256|
000062  6800              LDR      r0,[r0,#0]  ; receCDMA_S
000064  f7fffffe          BL       Store_Getdates
;;;124    					pCmp = strstr((const char*)ptrRece,"ZIPRECV");  //如果接收到服务器主动下发的消息则发送给专门处理函数的消息队列
000068  a128              ADR      r1,|L3.268|
00006a  4827              LDR      r0,|L3.264|
00006c  6800              LDR      r0,[r0,#0]  ; ptrRece
00006e  f7fffffe          BL       strstr
000072  4928              LDR      r1,|L3.276|
000074  6008              STR      r0,[r1,#0]  ; pCmp
;;;125    					if(pCmp == NULL)
000076  4608              MOV      r0,r1
000078  6800              LDR      r0,[r0,#0]  ; pCmp
00007a  b978              CBNZ     r0,|L3.156|
;;;126    					{
;;;127    						if(OSQPost(CDMARecieveQ,ptrRece) != OS_ERR_NONE)//推送不成功需要释放内存块
00007c  4822              LDR      r0,|L3.264|
00007e  6801              LDR      r1,[r0,#0]  ; ptrRece
000080  4825              LDR      r0,|L3.280|
000082  6800              LDR      r0,[r0,#0]  ; CDMARecieveQ
000084  f7fffffe          BL       OSQPost
000088  b328              CBZ      r0,|L3.214|
;;;128    						{
;;;129    							Mem_free(ptrRece);
00008a  481f              LDR      r0,|L3.264|
00008c  6800              LDR      r0,[r0,#0]  ; ptrRece
00008e  f7fffffe          BL       Mem_free
;;;130    							Store_Clear(receCDMA_S);//舍弃本次接收的数据
000092  481b              LDR      r0,|L3.256|
000094  6800              LDR      r0,[r0,#0]  ; receCDMA_S
000096  f7fffffe          BL       Store_Clear
00009a  e026              B        |L3.234|
                  |L3.156|
;;;131    						}
;;;132    					}
;;;133    					else
;;;134    					{
;;;135    						memcpy(adf,ptrRece,receDatalen);
00009c  4819              LDR      r0,|L3.260|
00009e  8802              LDRH     r2,[r0,#0]  ; receDatalen
0000a0  4819              LDR      r0,|L3.264|
0000a2  6801              LDR      r1,[r0,#0]  ; ptrRece
0000a4  481d              LDR      r0,|L3.284|
0000a6  f7fffffe          BL       __aeabi_memcpy
;;;136    						offadf += receDatalen;
0000aa  481d              LDR      r0,|L3.288|
0000ac  8800              LDRH     r0,[r0,#0]  ; offadf
0000ae  4915              LDR      r1,|L3.260|
0000b0  8809              LDRH     r1,[r1,#0]  ; receDatalen
0000b2  4408              ADD      r0,r0,r1
0000b4  491a              LDR      r1,|L3.288|
0000b6  8008              STRH     r0,[r1,#0]
;;;137    						if(OSQPost(ZIPRecv_Q,ptrRece) != OS_ERR_NONE)// 推送给专门处理服务器下发的数据的消息队列
0000b8  4813              LDR      r0,|L3.264|
0000ba  6801              LDR      r1,[r0,#0]  ; ptrRece
0000bc  4819              LDR      r0,|L3.292|
0000be  6800              LDR      r0,[r0,#0]  ; ZIPRecv_Q
0000c0  f7fffffe          BL       OSQPost
0000c4  b138              CBZ      r0,|L3.214|
;;;138    						{
;;;139    							Mem_free(ptrRece);
0000c6  4810              LDR      r0,|L3.264|
0000c8  6800              LDR      r0,[r0,#0]  ; ptrRece
0000ca  f7fffffe          BL       Mem_free
;;;140    							Store_Clear(receCDMA_S);//舍弃本次接收的数据
0000ce  480c              LDR      r0,|L3.256|
0000d0  6800              LDR      r0,[r0,#0]  ; receCDMA_S
0000d2  f7fffffe          BL       Store_Clear
                  |L3.214|
0000d6  e008              B        |L3.234|
                  |L3.216|
;;;141    						}
;;;142    					}
;;;143    				}
;;;144    				else
;;;145    					Store_Clear(receCDMA_S);    //舍弃本次接收的数据
0000d8  4809              LDR      r0,|L3.256|
0000da  6800              LDR      r0,[r0,#0]  ; receCDMA_S
0000dc  f7fffffe          BL       Store_Clear
0000e0  e003              B        |L3.234|
                  |L3.226|
;;;146    			}
;;;147    			else
;;;148    				Store_Clear(receCDMA_S);//接收的数据长度<=2 视为无效数据，没有这么短的回复
0000e2  4807              LDR      r0,|L3.256|
0000e4  6800              LDR      r0,[r0,#0]  ; receCDMA_S
0000e6  f7fffffe          BL       Store_Clear
                  |L3.234|
;;;149    				
;;;150    			TIM_Cmd(TIM4, DISABLE);
0000ea  2100              MOVS     r1,#0
0000ec  4802              LDR      r0,|L3.248|
0000ee  f7fffffe          BL       TIM_Cmd
                  |L3.242|
;;;151    		}
;;;152    	}
;;;153    	OSIntExit();  //中断服务结束，系统进行任务调度
0000f2  f7fffffe          BL       OSIntExit
;;;154    }
0000f6  bd10              POP      {r4,pc}
;;;155    
                          ENDP

                  |L3.248|
                          DCD      0x40000800
                  |L3.252|
                          DCD      rxTimeOut
                  |L3.256|
                          DCD      receCDMA_S
                  |L3.260|
                          DCD      receDatalen
                  |L3.264|
                          DCD      ptrRece
                  |L3.268|
00010c  5a495052          DCB      "ZIPRECV",0
000110  45435600
                  |L3.276|
                          DCD      pCmp
                  |L3.280|
                          DCD      CDMARecieveQ
                  |L3.284|
                          DCD      adf
                  |L3.288|
                          DCD      offadf
                  |L3.292|
                          DCD      ZIPRecv_Q

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;49     NORMAL_STATE rxtxState;
;;;50     void USART2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;51     {
;;;52     	OSIntEnter();//系统进入中断服务程序
000002  f7fffffe          BL       OSIntEnter
;;;53     	dkfs = receCDMA_S->base;
000006  483b              LDR      r0,|L4.244|
000008  6800              LDR      r0,[r0,#0]  ; receCDMA_S
00000a  6840              LDR      r0,[r0,#4]
00000c  493a              LDR      r1,|L4.248|
00000e  6008              STR      r0,[r1,#0]  ; dkfs
;;;54     	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)//接收到数据
000010  f2405125          MOV      r1,#0x525
000014  4839              LDR      r0,|L4.252|
000016  f7fffffe          BL       USART_GetITStatus
00001a  b300              CBZ      r0,|L4.94|
;;;55       	{
;;;56         	byteRece = USART_ReceiveData(USART2);
00001c  4837              LDR      r0,|L4.252|
00001e  f7fffffe          BL       USART_ReceiveData
000022  4937              LDR      r1,|L4.256|
000024  7008              STRB     r0,[r1,#0]
;;;57     	
;;;58     		rxtxState = Store_Push(receCDMA_S,byteRece);   
000026  4608              MOV      r0,r1
000028  7801              LDRB     r1,[r0,#0]  ; byteRece
00002a  4832              LDR      r0,|L4.244|
00002c  6800              LDR      r0,[r0,#0]  ; receCDMA_S
00002e  f7fffffe          BL       Store_Push
000032  4934              LDR      r1,|L4.260|
000034  7008              STRB     r0,[r1,#0]
;;;59     		if(rxtxState == OK)
000036  4608              MOV      r0,r1
000038  7800              LDRB     r0,[r0,#0]  ; rxtxState
00003a  b950              CBNZ     r0,|L4.82|
;;;60     		{
;;;61     			rxTimeOut = 1;
00003c  2001              MOVS     r0,#1
00003e  4932              LDR      r1,|L4.264|
000040  8008              STRH     r0,[r1,#0]
;;;62     			TIM_SetCounter(TIM4,0); //清空计数器
000042  2100              MOVS     r1,#0
000044  4831              LDR      r0,|L4.268|
000046  f7fffffe          BL       TIM_SetCounter
;;;63     			TIM_Cmd(TIM4, ENABLE);  //使能TIMx
00004a  2101              MOVS     r1,#1
00004c  482f              LDR      r0,|L4.268|
00004e  f7fffffe          BL       TIM_Cmd
                  |L4.82|
;;;64     		}
;;;65     		USART_ClearITPendingBit(USART2, USART_IT_RXNE) ;
000052  f2405125          MOV      r1,#0x525
000056  4829              LDR      r0,|L4.252|
000058  f7fffffe          BL       USART_ClearITPendingBit
00005c  e046              B        |L4.236|
                  |L4.94|
;;;66     	}
;;;67     	else if(USART_GetITStatus(USART2, USART_IT_TC) != RESET)//发送完毕  移位寄存器空
00005e  f2406126          MOV      r1,#0x626
000062  4826              LDR      r0,|L4.252|
000064  f7fffffe          BL       USART_GetITStatus
000068  b1d0              CBZ      r0,|L4.160|
;;;68     	{
;;;69     		if(CirQ_GetLength(sendCDMA_Q) > 0)
00006a  4829              LDR      r0,|L4.272|
00006c  6800              LDR      r0,[r0,#0]  ; sendCDMA_Q
00006e  f7fffffe          BL       CirQ_GetLength
000072  2800              CMP      r0,#0
000074  dd0e              BLE      |L4.148|
;;;70     		{
;;;71     			rxtxState = CirQ_Pop(sendCDMA_Q,&byteSend);
000076  4927              LDR      r1,|L4.276|
000078  4825              LDR      r0,|L4.272|
00007a  6800              LDR      r0,[r0,#0]  ; sendCDMA_Q
00007c  f7fffffe          BL       CirQ_Pop
000080  4920              LDR      r1,|L4.260|
000082  7008              STRB     r0,[r1,#0]
;;;72     			if(rxtxState == OK)
000084  4608              MOV      r0,r1
000086  7800              LDRB     r0,[r0,#0]  ; rxtxState
000088  b920              CBNZ     r0,|L4.148|
;;;73     				USART_SendData(USART2, byteSend);
00008a  4822              LDR      r0,|L4.276|
00008c  7801              LDRB     r1,[r0,#0]  ; byteSend
00008e  481b              LDR      r0,|L4.252|
000090  f7fffffe          BL       USART_SendData
                  |L4.148|
;;;74     		}
;;;75     		else
;;;76     		{
;;;77     			//todo:通知任务发送完成，可以发送下一包数据了
;;;78     		}
;;;79     		USART_ClearITPendingBit(USART2, USART_IT_TC) ;
000094  f2406126          MOV      r1,#0x626
000098  4818              LDR      r0,|L4.252|
00009a  f7fffffe          BL       USART_ClearITPendingBit
00009e  e025              B        |L4.236|
                  |L4.160|
;;;80     	}
;;;81     	else if(USART_GetITStatus(USART2, USART_IT_TXE) != RESET)//空  发送寄存器空
0000a0  f2407127          MOV      r1,#0x727
0000a4  4815              LDR      r0,|L4.252|
0000a6  f7fffffe          BL       USART_GetITStatus
0000aa  b1f8              CBZ      r0,|L4.236|
;;;82     	{
;;;83     		if(CirQ_GetLength(sendCDMA_Q) > 0)
0000ac  4818              LDR      r0,|L4.272|
0000ae  6800              LDR      r0,[r0,#0]  ; sendCDMA_Q
0000b0  f7fffffe          BL       CirQ_GetLength
0000b4  2800              CMP      r0,#0
0000b6  dd0e              BLE      |L4.214|
;;;84     		{
;;;85     			rxtxState = CirQ_Pop(sendCDMA_Q,&byteSend);
0000b8  4916              LDR      r1,|L4.276|
0000ba  4815              LDR      r0,|L4.272|
0000bc  6800              LDR      r0,[r0,#0]  ; sendCDMA_Q
0000be  f7fffffe          BL       CirQ_Pop
0000c2  4910              LDR      r1,|L4.260|
0000c4  7008              STRB     r0,[r1,#0]
;;;86     			if(rxtxState == OK)
0000c6  4608              MOV      r0,r1
0000c8  7800              LDRB     r0,[r0,#0]  ; rxtxState
0000ca  b920              CBNZ     r0,|L4.214|
;;;87     				USART_SendData(USART2, byteSend);
0000cc  4811              LDR      r0,|L4.276|
0000ce  7801              LDRB     r1,[r0,#0]  ; byteSend
0000d0  480a              LDR      r0,|L4.252|
0000d2  f7fffffe          BL       USART_SendData
                  |L4.214|
;;;88     		}
;;;89     		else
;;;90     		{
;;;91     			 //todo:通知任务发送完成，可以发送下一包数据了
;;;92     		}
;;;93     		USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
0000d6  2200              MOVS     r2,#0
0000d8  f2407127          MOV      r1,#0x727
0000dc  4807              LDR      r0,|L4.252|
0000de  f7fffffe          BL       USART_ITConfig
;;;94     		USART_ClearITPendingBit(USART2, USART_IT_TXE) ;
0000e2  f2407127          MOV      r1,#0x727
0000e6  4805              LDR      r0,|L4.252|
0000e8  f7fffffe          BL       USART_ClearITPendingBit
                  |L4.236|
;;;95     	}
;;;96     	OSIntExit();  //中断服务结束，系统进行任务调度
0000ec  f7fffffe          BL       OSIntExit
;;;97     }
0000f0  bd10              POP      {r4,pc}
;;;98     
                          ENDP

0000f2  0000              DCW      0x0000
                  |L4.244|
                          DCD      receCDMA_S
                  |L4.248|
                          DCD      dkfs
                  |L4.252|
                          DCD      0x40004400
                  |L4.256|
                          DCD      byteRece
                  |L4.260|
                          DCD      rxtxState
                  |L4.264|
                          DCD      rxTimeOut
                  |L4.268|
                          DCD      0x40000800
                  |L4.272|
                          DCD      sendCDMA_Q
                  |L4.276|
                          DCD      byteSend

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  adf
                          %        3000

                          AREA ||.data||, DATA, ALIGN=2

                  byteRece
000000  00                DCB      0x00
                  byteSend
000001  000000            DCB      0x00,0x00,0x00
                  dkfs
                          DCD      0x00000000
                  rxTimeOut
000008  0000              DCW      0x0000
                  rxtxState
00000a  0000              DCB      0x00,0x00
                  ptrRece
                          DCD      0x00000000
                  receDatalen
000010  0000              DCW      0x0000
000012  0000              DCB      0x00,0x00
                  pCmp
                          DCD      0x00000000
                  offadf
000018  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\CDMA\\CDMA_Tx_Rx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_CDMA_Tx_Rx_c_b8c990da____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_CDMA_Tx_Rx_c_b8c990da____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_CDMA_Tx_Rx_c_b8c990da____REVSH|
#line 144
|__asm___12_CDMA_Tx_Rx_c_b8c990da____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
