; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\ucos_ii.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=..\obj\ucos_ii.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\SYSTEM -I..\USER -I..\LIB\inc -I..\UCOSII\CONFIG -I..\UCOSII\PORT -I..\UCOSII\CORE -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\ucos_ii.crf ..\UCOSII\CORE\ucos_ii.c]
                          THUMB

                          AREA ||i.OSFlagAccept||, CODE, READONLY, ALIGN=1

                  OSFlagAccept PROC
;;;91     #if OS_FLAG_ACCEPT_EN > 0u
;;;92     OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;93                             OS_FLAGS      flags,
;;;94                             INT8U         wait_type,
;;;95                             INT8U        *perr)
;;;96     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;97         OS_FLAGS      flags_rdy;
;;;98         INT8U         result;
;;;99         BOOLEAN       consume;
;;;100    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;101        OS_CPU_SR     cpu_sr = 0u;
00000c  f04f0b00          MOV      r11,#0
;;;102    #endif
;;;103    
;;;104    
;;;105    
;;;106    #ifdef OS_SAFETY_CRITICAL
;;;107        if (perr == (INT8U *)0) {
;;;108            OS_SAFETY_CRITICAL_EXCEPTION();
;;;109        }
;;;110    #endif
;;;111    
;;;112    #if OS_ARG_CHK_EN > 0u
;;;113        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;114            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;115            return ((OS_FLAGS)0);
;;;116        }
;;;117    #endif
;;;118        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
000010  7820              LDRB     r0,[r4,#0]
000012  2805              CMP      r0,#5
000014  d004              BEQ      |L1.32|
;;;119            *perr = OS_ERR_EVENT_TYPE;
000016  2001              MOVS     r0,#1
000018  7030              STRB     r0,[r6,#0]
;;;120            return ((OS_FLAGS)0);
00001a  2000              MOVS     r0,#0
                  |L1.28|
;;;121        }
;;;122        result = (INT8U)(wait_type & OS_FLAG_CONSUME);
;;;123        if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
;;;124            wait_type &= ~OS_FLAG_CONSUME;
;;;125            consume    = OS_TRUE;
;;;126        } else {
;;;127            consume    = OS_FALSE;
;;;128        }
;;;129    /*$PAGE*/
;;;130        *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
;;;131        OS_ENTER_CRITICAL();
;;;132        switch (wait_type) {
;;;133            case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
;;;134                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
;;;135                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;136                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;137                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
;;;138                     }
;;;139                 } else {
;;;140                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;141                 }
;;;142                 OS_EXIT_CRITICAL();
;;;143                 break;
;;;144    
;;;145            case OS_FLAG_WAIT_SET_ANY:
;;;146                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
;;;147                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
;;;148                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;149                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
;;;150                     }
;;;151                 } else {
;;;152                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;153                 }
;;;154                 OS_EXIT_CRITICAL();
;;;155                 break;
;;;156    
;;;157    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;158            case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
;;;159                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
;;;160                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;161                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;162                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
;;;163                     }
;;;164                 } else {
;;;165                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;166                 }
;;;167                 OS_EXIT_CRITICAL();
;;;168                 break;
;;;169    
;;;170            case OS_FLAG_WAIT_CLR_ANY:
;;;171                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
;;;172                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
;;;173                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;174                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
;;;175                     }
;;;176                 } else {
;;;177                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;178                 }
;;;179                 OS_EXIT_CRITICAL();
;;;180                 break;
;;;181    #endif
;;;182    
;;;183            default:
;;;184                 OS_EXIT_CRITICAL();
;;;185                 flags_rdy = (OS_FLAGS)0;
;;;186                 *perr     = OS_ERR_FLAG_WAIT_TYPE;
;;;187                 break;
;;;188        }
;;;189        return (flags_rdy);
;;;190    }
00001c  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.32|
000020  f0090a80          AND      r10,r9,#0x80          ;122
000024  f1ba0f00          CMP      r10,#0                ;123
000028  d004              BEQ      |L1.52|
00002a  f0290980          BIC      r9,r9,#0x80           ;124
00002e  f04f0801          MOV      r8,#1                 ;125
000032  e001              B        |L1.56|
                  |L1.52|
000034  f04f0800          MOV      r8,#0                 ;127
                  |L1.56|
000038  2000              MOVS     r0,#0                 ;130
00003a  7030              STRB     r0,[r6,#0]            ;130
00003c  f7fffffe          BL       OS_CPU_SR_Save
000040  4683              MOV      r11,r0                ;131
000042  f1b90f00          CMP      r9,#0                 ;132
000046  d02c              BEQ      |L1.162|
000048  f1b90f01          CMP      r9,#1                 ;132
00004c  d03b              BEQ      |L1.198|
00004e  f1b90f02          CMP      r9,#2                 ;132
000052  d003              BEQ      |L1.92|
000054  f1b90f03          CMP      r9,#3                 ;132
000058  d146              BNE      |L1.232|
00005a  e011              B        |L1.128|
                  |L1.92|
00005c  8920              LDRH     r0,[r4,#8]            ;134
00005e  ea000507          AND      r5,r0,r7              ;134
000062  42bd              CMP      r5,r7                 ;135
000064  d106              BNE      |L1.116|
000066  f1b80f01          CMP      r8,#1                 ;136
00006a  d105              BNE      |L1.120|
00006c  8920              LDRH     r0,[r4,#8]            ;137
00006e  43a8              BICS     r0,r0,r5              ;137
000070  8120              STRH     r0,[r4,#8]            ;137
000072  e001              B        |L1.120|
                  |L1.116|
000074  2070              MOVS     r0,#0x70              ;140
000076  7030              STRB     r0,[r6,#0]            ;140
                  |L1.120|
000078  4658              MOV      r0,r11                ;142
00007a  f7fffffe          BL       OS_CPU_SR_Restore
00007e  e03a              B        |L1.246|
                  |L1.128|
000080  8920              LDRH     r0,[r4,#8]            ;146
000082  ea000507          AND      r5,r0,r7              ;146
000086  b135              CBZ      r5,|L1.150|
000088  f1b80f01          CMP      r8,#1                 ;148
00008c  d105              BNE      |L1.154|
00008e  8920              LDRH     r0,[r4,#8]            ;149
000090  43a8              BICS     r0,r0,r5              ;149
000092  8120              STRH     r0,[r4,#8]            ;149
000094  e001              B        |L1.154|
                  |L1.150|
000096  2070              MOVS     r0,#0x70              ;152
000098  7030              STRB     r0,[r6,#0]            ;152
                  |L1.154|
00009a  4658              MOV      r0,r11                ;154
00009c  f7fffffe          BL       OS_CPU_SR_Restore
0000a0  e029              B        |L1.246|
                  |L1.162|
0000a2  8920              LDRH     r0,[r4,#8]            ;159
0000a4  ea270500          BIC      r5,r7,r0              ;159
0000a8  42bd              CMP      r5,r7                 ;160
0000aa  d106              BNE      |L1.186|
0000ac  f1b80f01          CMP      r8,#1                 ;161
0000b0  d105              BNE      |L1.190|
0000b2  8920              LDRH     r0,[r4,#8]            ;162
0000b4  4328              ORRS     r0,r0,r5              ;162
0000b6  8120              STRH     r0,[r4,#8]            ;162
0000b8  e001              B        |L1.190|
                  |L1.186|
0000ba  2070              MOVS     r0,#0x70              ;165
0000bc  7030              STRB     r0,[r6,#0]            ;165
                  |L1.190|
0000be  4658              MOV      r0,r11                ;167
0000c0  f7fffffe          BL       OS_CPU_SR_Restore
0000c4  e017              B        |L1.246|
                  |L1.198|
0000c6  8920              LDRH     r0,[r4,#8]            ;171
0000c8  ea270500          BIC      r5,r7,r0              ;171
0000cc  b135              CBZ      r5,|L1.220|
0000ce  f1b80f01          CMP      r8,#1                 ;173
0000d2  d105              BNE      |L1.224|
0000d4  8920              LDRH     r0,[r4,#8]            ;174
0000d6  4328              ORRS     r0,r0,r5              ;174
0000d8  8120              STRH     r0,[r4,#8]            ;174
0000da  e001              B        |L1.224|
                  |L1.220|
0000dc  2070              MOVS     r0,#0x70              ;177
0000de  7030              STRB     r0,[r6,#0]            ;177
                  |L1.224|
0000e0  4658              MOV      r0,r11                ;179
0000e2  f7fffffe          BL       OS_CPU_SR_Restore
0000e6  e006              B        |L1.246|
                  |L1.232|
0000e8  4658              MOV      r0,r11                ;184
0000ea  f7fffffe          BL       OS_CPU_SR_Restore
0000ee  2500              MOVS     r5,#0                 ;185
0000f0  206f              MOVS     r0,#0x6f              ;186
0000f2  7030              STRB     r0,[r6,#0]            ;186
0000f4  bf00              NOP                            ;187
                  |L1.246|
0000f6  bf00              NOP                            ;143
0000f8  4628              MOV      r0,r5                 ;189
0000fa  e78f              B        |L1.28|
;;;191    #endif
                          ENDP


                          AREA ||i.OSFlagCreate||, CODE, READONLY, ALIGN=2

                  OSFlagCreate PROC
;;;213    
;;;214    OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;215                                INT8U    *perr)
;;;216    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;217        OS_FLAG_GRP *pgrp;
;;;218    #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
;;;219        OS_CPU_SR    cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;220    #endif
;;;221    
;;;222    
;;;223    
;;;224    #ifdef OS_SAFETY_CRITICAL
;;;225        if (perr == (INT8U *)0) {
;;;226            OS_SAFETY_CRITICAL_EXCEPTION();
;;;227        }
;;;228    #endif
;;;229    
;;;230    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;231        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;232            OS_SAFETY_CRITICAL_EXCEPTION();
;;;233        }
;;;234    #endif
;;;235    
;;;236        if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
00000a  4813              LDR      r0,|L2.88|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000e  b120              CBZ      r0,|L2.26|
;;;237            *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
000010  2010              MOVS     r0,#0x10
000012  7028              STRB     r0,[r5,#0]
;;;238            return ((OS_FLAG_GRP *)0);
000014  2000              MOVS     r0,#0
                  |L2.22|
;;;239        }
;;;240        OS_ENTER_CRITICAL();
;;;241        pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
;;;242        if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
;;;243                                                        /* Adjust free list                                */
;;;244            OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
;;;245            pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
;;;246            pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
;;;247            pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
;;;248    #if OS_FLAG_NAME_EN > 0u
;;;249            pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;250    #endif
;;;251            OS_EXIT_CRITICAL();
;;;252            *perr                = OS_ERR_NONE;
;;;253        } else {
;;;254            OS_EXIT_CRITICAL();
;;;255            *perr                = OS_ERR_FLAG_GRP_DEPLETED;
;;;256        }
;;;257        return (pgrp);                                  /* Return pointer to event flag group              */
;;;258    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L2.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;240
000020  480e              LDR      r0,|L2.92|
000022  6804              LDR      r4,[r0,#0]            ;241  ; OSFlagFreeList
000024  b184              CBZ      r4,|L2.72|
000026  6800              LDR      r0,[r0,#0]            ;244  ; OSFlagFreeList
000028  6840              LDR      r0,[r0,#4]            ;244
00002a  490c              LDR      r1,|L2.92|
00002c  6008              STR      r0,[r1,#0]            ;244  ; OSFlagFreeList
00002e  2005              MOVS     r0,#5                 ;245
000030  7020              STRB     r0,[r4,#0]            ;245
000032  8126              STRH     r6,[r4,#8]            ;246
000034  2000              MOVS     r0,#0                 ;247
000036  6060              STR      r0,[r4,#4]            ;247
000038  a009              ADR      r0,|L2.96|
00003a  60e0              STR      r0,[r4,#0xc]          ;249
00003c  4638              MOV      r0,r7                 ;251
00003e  f7fffffe          BL       OS_CPU_SR_Restore
000042  2000              MOVS     r0,#0                 ;252
000044  7028              STRB     r0,[r5,#0]            ;252
000046  e004              B        |L2.82|
                  |L2.72|
000048  4638              MOV      r0,r7                 ;254
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2072              MOVS     r0,#0x72              ;255
000050  7028              STRB     r0,[r5,#0]            ;255
                  |L2.82|
000052  4620              MOV      r0,r4                 ;257
000054  e7df              B        |L2.22|
;;;259    
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      OSIntNesting
                  |L2.92|
                          DCD      OSFlagFreeList
                  |L2.96|
000060  3f00              DCB      "?",0
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.OSFlagDel||, CODE, READONLY, ALIGN=2

                  OSFlagDel PROC
;;;297    #if OS_FLAG_DEL_EN > 0u
;;;298    OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;299                             INT8U         opt,
;;;300                             INT8U        *perr)
;;;301    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;302        BOOLEAN       tasks_waiting;
;;;303        OS_FLAG_NODE *pnode;
;;;304        OS_FLAG_GRP  *pgrp_return;
;;;305    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;306        OS_CPU_SR     cpu_sr = 0u;
00000a  f04f0a00          MOV      r10,#0
;;;307    #endif
;;;308    
;;;309    
;;;310    
;;;311    #ifdef OS_SAFETY_CRITICAL
;;;312        if (perr == (INT8U *)0) {
;;;313            OS_SAFETY_CRITICAL_EXCEPTION();
;;;314        }
;;;315    #endif
;;;316    
;;;317    #if OS_ARG_CHK_EN > 0u
;;;318        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;319            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;320            return (pgrp);
;;;321        }
;;;322    #endif
;;;323        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00000e  4832              LDR      r0,|L3.216|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000012  b120              CBZ      r0,|L3.30|
;;;324            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
000014  200f              MOVS     r0,#0xf
000016  7028              STRB     r0,[r5,#0]
;;;325            return (pgrp);
000018  4620              MOV      r0,r4
                  |L3.26|
;;;326        }
;;;327        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
;;;328            *perr = OS_ERR_EVENT_TYPE;
;;;329            return (pgrp);
;;;330        }
;;;331        OS_ENTER_CRITICAL();
;;;332        if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
;;;333            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;334        } else {
;;;335            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;336        }
;;;337        switch (opt) {
;;;338            case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
;;;339                 if (tasks_waiting == OS_FALSE) {
;;;340    #if OS_FLAG_NAME_EN > 0u
;;;341                     pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;342    #endif
;;;343                     pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;344                     pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
;;;345                     pgrp->OSFlagFlags    = (OS_FLAGS)0;
;;;346                     OSFlagFreeList       = pgrp;
;;;347                     OS_EXIT_CRITICAL();
;;;348                     *perr                = OS_ERR_NONE;
;;;349                     pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
;;;350                 } else {
;;;351                     OS_EXIT_CRITICAL();
;;;352                     *perr                = OS_ERR_TASK_WAITING;
;;;353                     pgrp_return          = pgrp;
;;;354                 }
;;;355                 break;
;;;356    
;;;357            case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
;;;358                 pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
;;;359                 while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
;;;360                     (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
;;;361                     pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
;;;362                 }
;;;363    #if OS_FLAG_NAME_EN > 0u
;;;364                 pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;365    #endif
;;;366                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;367                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
;;;368                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
;;;369                 OSFlagFreeList       = pgrp;
;;;370                 OS_EXIT_CRITICAL();
;;;371                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;372                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;373                 }
;;;374                 *perr = OS_ERR_NONE;
;;;375                 pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
;;;376                 break;
;;;377    
;;;378            default:
;;;379                 OS_EXIT_CRITICAL();
;;;380                 *perr                = OS_ERR_INVALID_OPT;
;;;381                 pgrp_return          = pgrp;
;;;382                 break;
;;;383        }
;;;384        return (pgrp_return);
;;;385    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L3.30|
00001e  7820              LDRB     r0,[r4,#0]            ;327
000020  2805              CMP      r0,#5                 ;327
000022  d003              BEQ      |L3.44|
000024  2001              MOVS     r0,#1                 ;328
000026  7028              STRB     r0,[r5,#0]            ;328
000028  4620              MOV      r0,r4                 ;329
00002a  e7f6              B        |L3.26|
                  |L3.44|
00002c  f7fffffe          BL       OS_CPU_SR_Save
000030  4682              MOV      r10,r0                ;331
000032  6860              LDR      r0,[r4,#4]            ;332
000034  b108              CBZ      r0,|L3.58|
000036  2701              MOVS     r7,#1                 ;333
000038  e000              B        |L3.60|
                  |L3.58|
00003a  2700              MOVS     r7,#0                 ;335
                  |L3.60|
00003c  f1b90f00          CMP      r9,#0                 ;337
000040  d003              BEQ      |L3.74|
000042  f1b90f01          CMP      r9,#1                 ;337
000046  d13c              BNE      |L3.194|
000048  e019              B        |L3.126|
                  |L3.74|
00004a  b98f              CBNZ     r7,|L3.112|
00004c  a023              ADR      r0,|L3.220|
00004e  60e0              STR      r0,[r4,#0xc]          ;341
000050  2000              MOVS     r0,#0                 ;343
000052  7020              STRB     r0,[r4,#0]            ;343
000054  4822              LDR      r0,|L3.224|
000056  6800              LDR      r0,[r0,#0]            ;344  ; OSFlagFreeList
000058  6060              STR      r0,[r4,#4]            ;344
00005a  2000              MOVS     r0,#0                 ;345
00005c  8120              STRH     r0,[r4,#8]            ;345
00005e  4820              LDR      r0,|L3.224|
000060  6004              STR      r4,[r0,#0]            ;346  ; OSFlagFreeList
000062  4650              MOV      r0,r10                ;347
000064  f7fffffe          BL       OS_CPU_SR_Restore
000068  2000              MOVS     r0,#0                 ;348
00006a  7028              STRB     r0,[r5,#0]            ;348
00006c  2600              MOVS     r6,#0                 ;349
00006e  e005              B        |L3.124|
                  |L3.112|
000070  4650              MOV      r0,r10                ;351
000072  f7fffffe          BL       OS_CPU_SR_Restore
000076  2049              MOVS     r0,#0x49              ;352
000078  7028              STRB     r0,[r5,#0]            ;352
00007a  4626              MOV      r6,r4                 ;353
                  |L3.124|
00007c  e028              B        |L3.208|
                  |L3.126|
00007e  f8d48004          LDR      r8,[r4,#4]            ;358
000082  e005              B        |L3.144|
                  |L3.132|
000084  2100              MOVS     r1,#0                 ;360
000086  4640              MOV      r0,r8                 ;360
000088  f7fffffe          BL       OS_FlagTaskRdy
00008c  f8d88000          LDR      r8,[r8,#0]            ;361
                  |L3.144|
000090  f1b80f00          CMP      r8,#0                 ;359
000094  d1f6              BNE      |L3.132|
000096  a011              ADR      r0,|L3.220|
000098  60e0              STR      r0,[r4,#0xc]          ;364
00009a  2000              MOVS     r0,#0                 ;366
00009c  7020              STRB     r0,[r4,#0]            ;366
00009e  4810              LDR      r0,|L3.224|
0000a0  6800              LDR      r0,[r0,#0]            ;367  ; OSFlagFreeList
0000a2  6060              STR      r0,[r4,#4]            ;367
0000a4  2000              MOVS     r0,#0                 ;368
0000a6  8120              STRH     r0,[r4,#8]            ;368
0000a8  480d              LDR      r0,|L3.224|
0000aa  6004              STR      r4,[r0,#0]            ;369  ; OSFlagFreeList
0000ac  4650              MOV      r0,r10                ;370
0000ae  f7fffffe          BL       OS_CPU_SR_Restore
0000b2  2f01              CMP      r7,#1                 ;371
0000b4  d101              BNE      |L3.186|
0000b6  f7fffffe          BL       OS_Sched
                  |L3.186|
0000ba  2000              MOVS     r0,#0                 ;374
0000bc  7028              STRB     r0,[r5,#0]            ;374
0000be  2600              MOVS     r6,#0                 ;375
0000c0  e006              B        |L3.208|
                  |L3.194|
0000c2  4650              MOV      r0,r10                ;379
0000c4  f7fffffe          BL       OS_CPU_SR_Restore
0000c8  2007              MOVS     r0,#7                 ;380
0000ca  7028              STRB     r0,[r5,#0]            ;380
0000cc  4626              MOV      r6,r4                 ;381
0000ce  bf00              NOP                            ;382
                  |L3.208|
0000d0  bf00              NOP                            ;355
0000d2  4630              MOV      r0,r6                 ;384
0000d4  e7a1              B        |L3.26|
;;;386    #endif
                          ENDP

0000d6  0000              DCW      0x0000
                  |L3.216|
                          DCD      OSIntNesting
                  |L3.220|
0000dc  3f00              DCB      "?",0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L3.224|
                          DCD      OSFlagFreeList

                          AREA ||i.OSFlagNameGet||, CODE, READONLY, ALIGN=2

                  OSFlagNameGet PROC
;;;411    #if OS_FLAG_NAME_EN > 0u
;;;412    INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;413                          INT8U        **pname,
;;;414                          INT8U         *perr)
;;;415    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;416        INT8U      len;
;;;417    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;418        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;419    #endif
;;;420    
;;;421    
;;;422    
;;;423    #ifdef OS_SAFETY_CRITICAL
;;;424        if (perr == (INT8U *)0) {
;;;425            OS_SAFETY_CRITICAL_EXCEPTION();
;;;426        }
;;;427    #endif
;;;428    
;;;429    #if OS_ARG_CHK_EN > 0u
;;;430        if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
;;;431            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;432            return (0u);
;;;433        }
;;;434        if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;435            *perr = OS_ERR_PNAME_NULL;
;;;436            return (0u);
;;;437        }
;;;438    #endif
;;;439        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  4810              LDR      r0,|L4.80|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b120              CBZ      r0,|L4.28|
;;;440            *perr = OS_ERR_NAME_GET_ISR;
000012  2011              MOVS     r0,#0x11
000014  7020              STRB     r0,[r4,#0]
;;;441            return (0u);
000016  2000              MOVS     r0,#0
                  |L4.24|
;;;442        }
;;;443        OS_ENTER_CRITICAL();
;;;444        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
;;;445            OS_EXIT_CRITICAL();
;;;446            *perr = OS_ERR_EVENT_TYPE;
;;;447            return (0u);
;;;448        }
;;;449        *pname = pgrp->OSFlagName;
;;;450        len    = OS_StrLen(*pname);
;;;451        OS_EXIT_CRITICAL();
;;;452        *perr  = OS_ERR_NONE;
;;;453        return (len);
;;;454    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L4.28|
00001c  f7fffffe          BL       OS_CPU_SR_Save
000020  4607              MOV      r7,r0                 ;443
000022  7828              LDRB     r0,[r5,#0]            ;444
000024  2805              CMP      r0,#5                 ;444
000026  d006              BEQ      |L4.54|
000028  4638              MOV      r0,r7                 ;445
00002a  f7fffffe          BL       OS_CPU_SR_Restore
00002e  2001              MOVS     r0,#1                 ;446
000030  7020              STRB     r0,[r4,#0]            ;446
000032  2000              MOVS     r0,#0                 ;447
000034  e7f0              B        |L4.24|
                  |L4.54|
000036  68e8              LDR      r0,[r5,#0xc]          ;449
000038  6030              STR      r0,[r6,#0]            ;449
00003a  6830              LDR      r0,[r6,#0]            ;450
00003c  f7fffffe          BL       OS_StrLen
000040  4680              MOV      r8,r0                 ;450
000042  4638              MOV      r0,r7                 ;451
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  2000              MOVS     r0,#0                 ;452
00004a  7020              STRB     r0,[r4,#0]            ;452
00004c  4640              MOV      r0,r8                 ;453
00004e  e7e3              B        |L4.24|
;;;455    #endif
                          ENDP

                  |L4.80|
                          DCD      OSIntNesting

                          AREA ||i.OSFlagNameSet||, CODE, READONLY, ALIGN=2

                  OSFlagNameSet PROC
;;;481    #if OS_FLAG_NAME_EN > 0u
;;;482    void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;483                         INT8U        *pname,
;;;484                         INT8U        *perr)
;;;485    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;486    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;487        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;488    #endif
;;;489    
;;;490    
;;;491    
;;;492    #ifdef OS_SAFETY_CRITICAL
;;;493        if (perr == (INT8U *)0) {
;;;494            OS_SAFETY_CRITICAL_EXCEPTION();
;;;495        }
;;;496    #endif
;;;497    
;;;498    #if OS_ARG_CHK_EN > 0u
;;;499        if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
;;;500            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;501            return;
;;;502        }
;;;503        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;504            *perr = OS_ERR_PNAME_NULL;
;;;505            return;
;;;506        }
;;;507    #endif
;;;508        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  480d              LDR      r0,|L5.68|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b118              CBZ      r0,|L5.26|
;;;509            *perr = OS_ERR_NAME_SET_ISR;
000012  2012              MOVS     r0,#0x12
000014  7020              STRB     r0,[r4,#0]
                  |L5.22|
;;;510            return;
;;;511        }
;;;512        OS_ENTER_CRITICAL();
;;;513        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
;;;514            OS_EXIT_CRITICAL();
;;;515            *perr = OS_ERR_EVENT_TYPE;
;;;516            return;
;;;517        }
;;;518        pgrp->OSFlagName = pname;
;;;519        OS_EXIT_CRITICAL();
;;;520        *perr            = OS_ERR_NONE;
;;;521        return;
;;;522    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L5.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;512
000020  7828              LDRB     r0,[r5,#0]            ;513
000022  2805              CMP      r0,#5                 ;513
000024  d005              BEQ      |L5.50|
000026  4638              MOV      r0,r7                 ;514
000028  f7fffffe          BL       OS_CPU_SR_Restore
00002c  2001              MOVS     r0,#1                 ;515
00002e  7020              STRB     r0,[r4,#0]            ;515
000030  e7f1              B        |L5.22|
                  |L5.50|
000032  60ee              STR      r6,[r5,#0xc]          ;518
000034  4638              MOV      r0,r7                 ;519
000036  f7fffffe          BL       OS_CPU_SR_Restore
00003a  2000              MOVS     r0,#0                 ;520
00003c  7020              STRB     r0,[r4,#0]            ;520
00003e  bf00              NOP                            ;521
000040  e7e9              B        |L5.22|
;;;523    #endif
                          ENDP

000042  0000              DCW      0x0000
                  |L5.68|
                          DCD      OSIntNesting

                          AREA ||i.OSFlagPend||, CODE, READONLY, ALIGN=2

                  OSFlagPend PROC
;;;579    
;;;580    OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;581                          OS_FLAGS      flags,
;;;582                          INT8U         wait_type,
;;;583                          INT32U        timeout,
;;;584                          INT8U        *perr)
;;;585    {
000004  b089              SUB      sp,sp,#0x24
000006  4605              MOV      r5,r0
000008  460f              MOV      r7,r1
00000a  4691              MOV      r9,r2
00000c  469a              MOV      r10,r3
00000e  9e12              LDR      r6,[sp,#0x48]
;;;586        OS_FLAG_NODE  node;
;;;587        OS_FLAGS      flags_rdy;
;;;588        INT8U         result;
;;;589        INT8U         pend_stat;
;;;590        BOOLEAN       consume;
;;;591    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;592        OS_CPU_SR     cpu_sr = 0u;
000010  2000              MOVS     r0,#0
000012  9002              STR      r0,[sp,#8]
;;;593    #endif
;;;594    
;;;595    
;;;596    
;;;597    #ifdef OS_SAFETY_CRITICAL
;;;598        if (perr == (INT8U *)0) {
;;;599            OS_SAFETY_CRITICAL_EXCEPTION();
;;;600        }
;;;601    #endif
;;;602    
;;;603    #if OS_ARG_CHK_EN > 0u
;;;604        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;605            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;606            return ((OS_FLAGS)0);
;;;607        }
;;;608    #endif
;;;609        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000014  488c              LDR      r0,|L6.584|
000016  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000018  b128              CBZ      r0,|L6.38|
;;;610            *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
00001a  2002              MOVS     r0,#2
00001c  7030              STRB     r0,[r6,#0]
;;;611            return ((OS_FLAGS)0);
00001e  2000              MOVS     r0,#0
                  |L6.32|
;;;612        }
;;;613        if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
;;;614            *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
;;;615            return ((OS_FLAGS)0);
;;;616        }
;;;617        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
;;;618            *perr = OS_ERR_EVENT_TYPE;
;;;619            return ((OS_FLAGS)0);
;;;620        }
;;;621        result = (INT8U)(wait_type & OS_FLAG_CONSUME);
;;;622        if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
;;;623            wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
;;;624            consume    = OS_TRUE;
;;;625        } else {
;;;626            consume    = OS_FALSE;
;;;627        }
;;;628    /*$PAGE*/
;;;629        OS_ENTER_CRITICAL();
;;;630        switch (wait_type) {
;;;631            case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
;;;632                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
;;;633                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;634                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;635                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
;;;636                     }
;;;637                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;638                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;639                     *perr                   = OS_ERR_NONE;
;;;640                     return (flags_rdy);
;;;641                 } else {                                      /* Block task until events occur or timeout */
;;;642                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;643                     OS_EXIT_CRITICAL();
;;;644                 }
;;;645                 break;
;;;646    
;;;647            case OS_FLAG_WAIT_SET_ANY:
;;;648                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
;;;649                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
;;;650                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;651                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
;;;652                     }
;;;653                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;654                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;655                     *perr                   = OS_ERR_NONE;
;;;656                     return (flags_rdy);
;;;657                 } else {                                      /* Block task until events occur or timeout */
;;;658                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;659                     OS_EXIT_CRITICAL();
;;;660                 }
;;;661                 break;
;;;662    
;;;663    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;664            case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
;;;665                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
;;;666                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;667                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;668                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
;;;669                     }
;;;670                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;671                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;672                     *perr                   = OS_ERR_NONE;
;;;673                     return (flags_rdy);
;;;674                 } else {                                      /* Block task until events occur or timeout */
;;;675                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;676                     OS_EXIT_CRITICAL();
;;;677                 }
;;;678                 break;
;;;679    
;;;680            case OS_FLAG_WAIT_CLR_ANY:
;;;681                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
;;;682                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
;;;683                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;684                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
;;;685                     }
;;;686                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;687                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;688                     *perr                   = OS_ERR_NONE;
;;;689                     return (flags_rdy);
;;;690                 } else {                                      /* Block task until events occur or timeout */
;;;691                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;692                     OS_EXIT_CRITICAL();
;;;693                 }
;;;694                 break;
;;;695    #endif
;;;696    
;;;697            default:
;;;698                 OS_EXIT_CRITICAL();
;;;699                 flags_rdy = (OS_FLAGS)0;
;;;700                 *perr      = OS_ERR_FLAG_WAIT_TYPE;
;;;701                 return (flags_rdy);
;;;702        }
;;;703    /*$PAGE*/
;;;704        OS_Sched();                                            /* Find next HPT ready to run               */
;;;705        OS_ENTER_CRITICAL();
;;;706        if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
;;;707            pend_stat                = OSTCBCur->OSTCBStatPend;
;;;708            OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;709            OS_FlagUnlink(&node);
;;;710            OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
;;;711            OS_EXIT_CRITICAL();
;;;712            flags_rdy                = (OS_FLAGS)0;
;;;713            switch (pend_stat) {
;;;714                case OS_STAT_PEND_ABORT:
;;;715                     *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
;;;716                     break;
;;;717    
;;;718                case OS_STAT_PEND_TO:
;;;719                default:
;;;720                     *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
;;;721                     break;
;;;722            }
;;;723            return (flags_rdy);
;;;724        }
;;;725        flags_rdy = OSTCBCur->OSTCBFlagsRdy;
;;;726        if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
;;;727            switch (wait_type) {
;;;728                case OS_FLAG_WAIT_SET_ALL:
;;;729                case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
;;;730                     pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
;;;731                     break;
;;;732    
;;;733    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;734                case OS_FLAG_WAIT_CLR_ALL:
;;;735                case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
;;;736                     pgrp->OSFlagFlags |=  flags_rdy;
;;;737                     break;
;;;738    #endif
;;;739                default:
;;;740                     OS_EXIT_CRITICAL();
;;;741                     *perr = OS_ERR_FLAG_WAIT_TYPE;
;;;742                     return ((OS_FLAGS)0);
;;;743            }
;;;744        }
;;;745        OS_EXIT_CRITICAL();
;;;746        *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
;;;747        return (flags_rdy);
;;;748    }
000020  b009              ADD      sp,sp,#0x24
000022  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.38|
000026  4889              LDR      r0,|L6.588|
000028  7800              LDRB     r0,[r0,#0]            ;613  ; OSLockNesting
00002a  b118              CBZ      r0,|L6.52|
00002c  200d              MOVS     r0,#0xd               ;614
00002e  7030              STRB     r0,[r6,#0]            ;614
000030  2000              MOVS     r0,#0                 ;615
000032  e7f5              B        |L6.32|
                  |L6.52|
000034  7828              LDRB     r0,[r5,#0]            ;617
000036  2805              CMP      r0,#5                 ;617
000038  d003              BEQ      |L6.66|
00003a  2001              MOVS     r0,#1                 ;618
00003c  7030              STRB     r0,[r6,#0]            ;618
00003e  2000              MOVS     r0,#0                 ;619
000040  e7ee              B        |L6.32|
                  |L6.66|
000042  f0090b80          AND      r11,r9,#0x80          ;621
000046  f1bb0f00          CMP      r11,#0                ;622
00004a  d004              BEQ      |L6.86|
00004c  f009097f          AND      r9,r9,#0x7f           ;623
000050  f04f0801          MOV      r8,#1                 ;624
000054  e001              B        |L6.90|
                  |L6.86|
000056  f04f0800          MOV      r8,#0                 ;626
                  |L6.90|
00005a  f7fffffe          BL       OS_CPU_SR_Save
00005e  9002              STR      r0,[sp,#8]            ;629
000060  f1b90f00          CMP      r9,#0                 ;630
000064  d04a              BEQ      |L6.252|
000066  f1b90f01          CMP      r9,#1                 ;630
00006a  d068              BEQ      |L6.318|
00006c  f1b90f02          CMP      r9,#2                 ;630
000070  d003              BEQ      |L6.122|
000072  f1b90f03          CMP      r9,#3                 ;630
000076  d176              BNE      |L6.358|
000078  e020              B        |L6.188|
                  |L6.122|
00007a  8928              LDRH     r0,[r5,#8]            ;632
00007c  ea000407          AND      r4,r0,r7              ;632
000080  42bc              CMP      r4,r7                 ;633
000082  d10f              BNE      |L6.164|
000084  f1b80f01          CMP      r8,#1                 ;634
000088  d102              BNE      |L6.144|
00008a  8928              LDRH     r0,[r5,#8]            ;635
00008c  43a0              BICS     r0,r0,r4              ;635
00008e  8128              STRH     r0,[r5,#8]            ;635
                  |L6.144|
000090  486f              LDR      r0,|L6.592|
000092  6800              LDR      r0,[r0,#0]            ;637  ; OSTCBCur
000094  8504              STRH     r4,[r0,#0x28]         ;637
000096  9802              LDR      r0,[sp,#8]            ;638
000098  f7fffffe          BL       OS_CPU_SR_Restore
00009c  2000              MOVS     r0,#0                 ;639
00009e  7030              STRB     r0,[r6,#0]            ;639
0000a0  4620              MOV      r0,r4                 ;640
0000a2  e7bd              B        |L6.32|
                  |L6.164|
0000a4  464b              MOV      r3,r9                 ;642
0000a6  463a              MOV      r2,r7                 ;642
0000a8  a904              ADD      r1,sp,#0x10           ;642
0000aa  4628              MOV      r0,r5                 ;642
0000ac  f8cda000          STR      r10,[sp,#0]           ;642
0000b0  f7fffffe          BL       OS_FlagBlock
0000b4  9802              LDR      r0,[sp,#8]            ;643
0000b6  f7fffffe          BL       OS_CPU_SR_Restore
0000ba  e069              B        |L6.400|
                  |L6.188|
0000bc  8928              LDRH     r0,[r5,#8]            ;648
0000be  ea000407          AND      r4,r0,r7              ;648
0000c2  b17c              CBZ      r4,|L6.228|
0000c4  f1b80f01          CMP      r8,#1                 ;650
0000c8  d102              BNE      |L6.208|
0000ca  8928              LDRH     r0,[r5,#8]            ;651
0000cc  43a0              BICS     r0,r0,r4              ;651
0000ce  8128              STRH     r0,[r5,#8]            ;651
                  |L6.208|
0000d0  485f              LDR      r0,|L6.592|
0000d2  6800              LDR      r0,[r0,#0]            ;653  ; OSTCBCur
0000d4  8504              STRH     r4,[r0,#0x28]         ;653
0000d6  9802              LDR      r0,[sp,#8]            ;654
0000d8  f7fffffe          BL       OS_CPU_SR_Restore
0000dc  2000              MOVS     r0,#0                 ;655
0000de  7030              STRB     r0,[r6,#0]            ;655
0000e0  4620              MOV      r0,r4                 ;656
0000e2  e79d              B        |L6.32|
                  |L6.228|
0000e4  464b              MOV      r3,r9                 ;658
0000e6  463a              MOV      r2,r7                 ;658
0000e8  a904              ADD      r1,sp,#0x10           ;658
0000ea  4628              MOV      r0,r5                 ;658
0000ec  f8cda000          STR      r10,[sp,#0]           ;658
0000f0  f7fffffe          BL       OS_FlagBlock
0000f4  9802              LDR      r0,[sp,#8]            ;659
0000f6  f7fffffe          BL       OS_CPU_SR_Restore
0000fa  e049              B        |L6.400|
                  |L6.252|
0000fc  8928              LDRH     r0,[r5,#8]            ;665
0000fe  ea270400          BIC      r4,r7,r0              ;665
000102  42bc              CMP      r4,r7                 ;666
000104  d10f              BNE      |L6.294|
000106  f1b80f01          CMP      r8,#1                 ;667
00010a  d102              BNE      |L6.274|
00010c  8928              LDRH     r0,[r5,#8]            ;668
00010e  4320              ORRS     r0,r0,r4              ;668
000110  8128              STRH     r0,[r5,#8]            ;668
                  |L6.274|
000112  484f              LDR      r0,|L6.592|
000114  6800              LDR      r0,[r0,#0]            ;670  ; OSTCBCur
000116  8504              STRH     r4,[r0,#0x28]         ;670
000118  9802              LDR      r0,[sp,#8]            ;671
00011a  f7fffffe          BL       OS_CPU_SR_Restore
00011e  2000              MOVS     r0,#0                 ;672
000120  7030              STRB     r0,[r6,#0]            ;672
000122  4620              MOV      r0,r4                 ;673
000124  e77c              B        |L6.32|
                  |L6.294|
000126  464b              MOV      r3,r9                 ;675
000128  463a              MOV      r2,r7                 ;675
00012a  a904              ADD      r1,sp,#0x10           ;675
00012c  4628              MOV      r0,r5                 ;675
00012e  f8cda000          STR      r10,[sp,#0]           ;675
000132  f7fffffe          BL       OS_FlagBlock
000136  9802              LDR      r0,[sp,#8]            ;676
000138  f7fffffe          BL       OS_CPU_SR_Restore
00013c  e028              B        |L6.400|
                  |L6.318|
00013e  8928              LDRH     r0,[r5,#8]            ;681
000140  ea270400          BIC      r4,r7,r0              ;681
000144  b184              CBZ      r4,|L6.360|
000146  f1b80f01          CMP      r8,#1                 ;683
00014a  d102              BNE      |L6.338|
00014c  8928              LDRH     r0,[r5,#8]            ;684
00014e  4320              ORRS     r0,r0,r4              ;684
000150  8128              STRH     r0,[r5,#8]            ;684
                  |L6.338|
000152  483f              LDR      r0,|L6.592|
000154  6800              LDR      r0,[r0,#0]            ;686  ; OSTCBCur
000156  8504              STRH     r4,[r0,#0x28]         ;686
000158  9802              LDR      r0,[sp,#8]            ;687
00015a  f7fffffe          BL       OS_CPU_SR_Restore
00015e  2000              MOVS     r0,#0                 ;688
000160  7030              STRB     r0,[r6,#0]            ;688
000162  4620              MOV      r0,r4                 ;689
000164  e75c              B        |L6.32|
                  |L6.358|
000166  e00b              B        |L6.384|
                  |L6.360|
000168  464b              MOV      r3,r9                 ;691
00016a  463a              MOV      r2,r7                 ;691
00016c  a904              ADD      r1,sp,#0x10           ;691
00016e  4628              MOV      r0,r5                 ;691
000170  f8cda000          STR      r10,[sp,#0]           ;691
000174  f7fffffe          BL       OS_FlagBlock
000178  9802              LDR      r0,[sp,#8]            ;692
00017a  f7fffffe          BL       OS_CPU_SR_Restore
00017e  e007              B        |L6.400|
                  |L6.384|
000180  9802              LDR      r0,[sp,#8]            ;698
000182  f7fffffe          BL       OS_CPU_SR_Restore
000186  2400              MOVS     r4,#0                 ;699
000188  206f              MOVS     r0,#0x6f              ;700
00018a  7030              STRB     r0,[r6,#0]            ;700
00018c  4620              MOV      r0,r4                 ;701
00018e  e747              B        |L6.32|
                  |L6.400|
000190  bf00              NOP                            ;645
000192  f7fffffe          BL       OS_Sched
000196  f7fffffe          BL       OS_CPU_SR_Save
00019a  9002              STR      r0,[sp,#8]            ;705
00019c  482c              LDR      r0,|L6.592|
00019e  6800              LDR      r0,[r0,#0]            ;706  ; OSTCBCur
0001a0  f8900031          LDRB     r0,[r0,#0x31]         ;706
0001a4  b320              CBZ      r0,|L6.496|
0001a6  482a              LDR      r0,|L6.592|
0001a8  6800              LDR      r0,[r0,#0]            ;707  ; OSTCBCur
0001aa  f8900031          LDRB     r0,[r0,#0x31]         ;707
0001ae  9003              STR      r0,[sp,#0xc]          ;707
0001b0  2000              MOVS     r0,#0                 ;708
0001b2  4927              LDR      r1,|L6.592|
0001b4  6809              LDR      r1,[r1,#0]            ;708  ; OSTCBCur
0001b6  f8810031          STRB     r0,[r1,#0x31]         ;708
0001ba  a804              ADD      r0,sp,#0x10           ;709
0001bc  f7fffffe          BL       OS_FlagUnlink
0001c0  2000              MOVS     r0,#0                 ;710
0001c2  4923              LDR      r1,|L6.592|
0001c4  6809              LDR      r1,[r1,#0]            ;710  ; OSTCBCur
0001c6  f8810030          STRB     r0,[r1,#0x30]         ;710
0001ca  9802              LDR      r0,[sp,#8]            ;711
0001cc  f7fffffe          BL       OS_CPU_SR_Restore
0001d0  2400              MOVS     r4,#0                 ;712
0001d2  9803              LDR      r0,[sp,#0xc]          ;713
0001d4  2801              CMP      r0,#1                 ;713
0001d6  d005              BEQ      |L6.484|
0001d8  2802              CMP      r0,#2                 ;713
0001da  d102              BNE      |L6.482|
0001dc  200e              MOVS     r0,#0xe               ;715
0001de  7030              STRB     r0,[r6,#0]            ;715
0001e0  e003              B        |L6.490|
                  |L6.482|
0001e2  bf00              NOP                            ;718
                  |L6.484|
0001e4  200a              MOVS     r0,#0xa               ;720
0001e6  7030              STRB     r0,[r6,#0]            ;720
0001e8  bf00              NOP                            ;721
                  |L6.490|
0001ea  bf00              NOP                            ;716
0001ec  4620              MOV      r0,r4                 ;723
0001ee  e717              B        |L6.32|
                  |L6.496|
0001f0  4817              LDR      r0,|L6.592|
0001f2  6800              LDR      r0,[r0,#0]            ;725  ; OSTCBCur
0001f4  8d04              LDRH     r4,[r0,#0x28]         ;725
0001f6  f1b80f01          CMP      r8,#1                 ;726
0001fa  d11e              BNE      |L6.570|
0001fc  f1b90f00          CMP      r9,#0                 ;727
000200  d00e              BEQ      |L6.544|
000202  f1b90f01          CMP      r9,#1                 ;727
000206  d00c              BEQ      |L6.546|
000208  f1b90f02          CMP      r9,#2                 ;727
00020c  d003              BEQ      |L6.534|
00020e  f1b90f03          CMP      r9,#3                 ;727
000212  d10a              BNE      |L6.554|
000214  e000              B        |L6.536|
                  |L6.534|
000216  bf00              NOP                            ;729
                  |L6.536|
000218  8928              LDRH     r0,[r5,#8]            ;730
00021a  43a0              BICS     r0,r0,r4              ;730
00021c  8128              STRH     r0,[r5,#8]            ;730
00021e  e00b              B        |L6.568|
                  |L6.544|
000220  bf00              NOP                            ;735
                  |L6.546|
000222  8928              LDRH     r0,[r5,#8]            ;736
000224  4320              ORRS     r0,r0,r4              ;736
000226  8128              STRH     r0,[r5,#8]            ;736
000228  e006              B        |L6.568|
                  |L6.554|
00022a  9802              LDR      r0,[sp,#8]            ;740
00022c  f7fffffe          BL       OS_CPU_SR_Restore
000230  206f              MOVS     r0,#0x6f              ;741
000232  7030              STRB     r0,[r6,#0]            ;741
000234  2000              MOVS     r0,#0                 ;742
000236  e6f3              B        |L6.32|
                  |L6.568|
000238  bf00              NOP                            ;731
                  |L6.570|
00023a  9802              LDR      r0,[sp,#8]            ;745
00023c  f7fffffe          BL       OS_CPU_SR_Restore
000240  2000              MOVS     r0,#0                 ;746
000242  7030              STRB     r0,[r6,#0]            ;746
000244  4620              MOV      r0,r4                 ;747
000246  e6eb              B        |L6.32|
;;;749    /*$PAGE*/
                          ENDP

                  |L6.584|
                          DCD      OSIntNesting
                  |L6.588|
                          DCD      OSLockNesting
                  |L6.592|
                          DCD      OSTCBCur

                          AREA ||i.OSFlagPendGetFlagsRdy||, CODE, READONLY, ALIGN=2

                  OSFlagPendGetFlagsRdy PROC
;;;764    
;;;765    OS_FLAGS  OSFlagPendGetFlagsRdy (void)
000000  b570              PUSH     {r4-r6,lr}
;;;766    {
;;;767        OS_FLAGS      flags;
;;;768    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;769        OS_CPU_SR     cpu_sr = 0u;
000002  2500              MOVS     r5,#0
;;;770    #endif
;;;771    
;;;772    
;;;773    
;;;774        OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4605              MOV      r5,r0
;;;775        flags = OSTCBCur->OSTCBFlagsRdy;
00000a  4804              LDR      r0,|L7.28|
00000c  6800              LDR      r0,[r0,#0]  ; OSTCBCur
00000e  8d04              LDRH     r4,[r0,#0x28]
;;;776        OS_EXIT_CRITICAL();
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       OS_CPU_SR_Restore
;;;777        return (flags);
000016  4620              MOV      r0,r4
;;;778    }
000018  bd70              POP      {r4-r6,pc}
;;;779    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      OSTCBCur

                          AREA ||i.OSFlagPost||, CODE, READONLY, ALIGN=1

                  OSFlagPost PROC
;;;821    */
;;;822    OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;823                          OS_FLAGS      flags,
;;;824                          INT8U         opt,
;;;825                          INT8U        *perr)
;;;826    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  461e              MOV      r6,r3
;;;827        OS_FLAG_NODE *pnode;
;;;828        BOOLEAN       sched;
;;;829        OS_FLAGS      flags_cur;
;;;830        OS_FLAGS      flags_rdy;
;;;831        BOOLEAN       rdy;
;;;832    #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
;;;833        OS_CPU_SR     cpu_sr = 0u;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;834    #endif
;;;835    
;;;836    
;;;837    
;;;838    #ifdef OS_SAFETY_CRITICAL
;;;839        if (perr == (INT8U *)0) {
;;;840            OS_SAFETY_CRITICAL_EXCEPTION();
;;;841        }
;;;842    #endif
;;;843    
;;;844    #if OS_ARG_CHK_EN > 0u
;;;845        if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
;;;846            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;847            return ((OS_FLAGS)0);
;;;848        }
;;;849    #endif
;;;850        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
000010  7820              LDRB     r0,[r4,#0]
000012  2805              CMP      r0,#5
000014  d004              BEQ      |L8.32|
;;;851            *perr = OS_ERR_EVENT_TYPE;
000016  2001              MOVS     r0,#1
000018  7030              STRB     r0,[r6,#0]
;;;852            return ((OS_FLAGS)0);
00001a  2000              MOVS     r0,#0
                  |L8.28|
;;;853        }
;;;854    /*$PAGE*/
;;;855        OS_ENTER_CRITICAL();
;;;856        switch (opt) {
;;;857            case OS_FLAG_CLR:
;;;858                 pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
;;;859                 break;
;;;860    
;;;861            case OS_FLAG_SET:
;;;862                 pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
;;;863                 break;
;;;864    
;;;865            default:
;;;866                 OS_EXIT_CRITICAL();                     /* INVALID option                                 */
;;;867                 *perr = OS_ERR_FLAG_INVALID_OPT;
;;;868                 return ((OS_FLAGS)0);
;;;869        }
;;;870        sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
;;;871        pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
;;;872        while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
;;;873            switch (pnode->OSFlagNodeWaitType) {
;;;874                case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
;;;875                     flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;876                     if (flags_rdy == pnode->OSFlagNodeFlags) {
;;;877                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;878                         if (rdy == OS_TRUE) {
;;;879                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;880                         }
;;;881                     }
;;;882                     break;
;;;883    
;;;884                case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
;;;885                     flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;886                     if (flags_rdy != (OS_FLAGS)0) {
;;;887                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;888                         if (rdy == OS_TRUE) {
;;;889                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;890                         }
;;;891                     }
;;;892                     break;
;;;893    
;;;894    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;895                case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
;;;896                     flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
;;;897                     if (flags_rdy == pnode->OSFlagNodeFlags) {
;;;898                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;899                         if (rdy == OS_TRUE) {
;;;900                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;901                         }
;;;902                     }
;;;903                     break;
;;;904    
;;;905                case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
;;;906                     flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
;;;907                     if (flags_rdy != (OS_FLAGS)0) {
;;;908                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;909                         if (rdy == OS_TRUE) {
;;;910                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;911                         }
;;;912                     }
;;;913                     break;
;;;914    #endif
;;;915                default:
;;;916                     OS_EXIT_CRITICAL();
;;;917                     *perr = OS_ERR_FLAG_WAIT_TYPE;
;;;918                     return ((OS_FLAGS)0);
;;;919            }
;;;920            pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
;;;921        }
;;;922        OS_EXIT_CRITICAL();
;;;923        if (sched == OS_TRUE) {
;;;924            OS_Sched();
;;;925        }
;;;926        OS_ENTER_CRITICAL();
;;;927        flags_cur = pgrp->OSFlagFlags;
;;;928        OS_EXIT_CRITICAL();
;;;929        *perr     = OS_ERR_NONE;
;;;930        return (flags_cur);
;;;931    }
00001c  e8bd9ffc          POP      {r2-r12,pc}
                  |L8.32|
000020  f7fffffe          BL       OS_CPU_SR_Save
000024  9000              STR      r0,[sp,#0]            ;855
000026  f1ba0f00          CMP      r10,#0                ;856
00002a  d003              BEQ      |L8.52|
00002c  f1ba0f01          CMP      r10,#1                ;856
000030  d10a              BNE      |L8.72|
000032  e004              B        |L8.62|
                  |L8.52|
000034  8920              LDRH     r0,[r4,#8]            ;858
000036  ea200009          BIC      r0,r0,r9              ;858
00003a  8120              STRH     r0,[r4,#8]            ;858
00003c  e00b              B        |L8.86|
                  |L8.62|
00003e  8920              LDRH     r0,[r4,#8]            ;862
000040  ea400009          ORR      r0,r0,r9              ;862
000044  8120              STRH     r0,[r4,#8]            ;862
000046  e006              B        |L8.86|
                  |L8.72|
000048  9800              LDR      r0,[sp,#0]            ;866
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2071              MOVS     r0,#0x71              ;867
000050  7030              STRB     r0,[r6,#0]            ;867
000052  2000              MOVS     r0,#0                 ;868
000054  e7e2              B        |L8.28|
                  |L8.86|
000056  bf00              NOP                            ;859
000058  f04f0b00          MOV      r11,#0                ;870
00005c  6865              LDR      r5,[r4,#4]            ;871
00005e  e055              B        |L8.268|
                  |L8.96|
000060  7ca8              LDRB     r0,[r5,#0x12]         ;873
000062  b340              CBZ      r0,|L8.182|
000064  2801              CMP      r0,#1                 ;873
000066  d038              BEQ      |L8.218|
000068  2802              CMP      r0,#2                 ;873
00006a  d002              BEQ      |L8.114|
00006c  2803              CMP      r0,#3                 ;873
00006e  d144              BNE      |L8.250|
000070  e011              B        |L8.150|
                  |L8.114|
000072  8920              LDRH     r0,[r4,#8]            ;875
000074  8a29              LDRH     r1,[r5,#0x10]         ;875
000076  ea000701          AND      r7,r0,r1              ;875
00007a  8a28              LDRH     r0,[r5,#0x10]         ;876
00007c  42b8              CMP      r0,r7                 ;876
00007e  d109              BNE      |L8.148|
000080  4639              MOV      r1,r7                 ;877
000082  4628              MOV      r0,r5                 ;877
000084  f7fffffe          BL       OS_FlagTaskRdy
000088  4680              MOV      r8,r0                 ;877
00008a  f1b80f01          CMP      r8,#1                 ;878
00008e  d101              BNE      |L8.148|
000090  f04f0b01          MOV      r11,#1                ;879
                  |L8.148|
000094  e038              B        |L8.264|
                  |L8.150|
000096  8920              LDRH     r0,[r4,#8]            ;885
000098  8a29              LDRH     r1,[r5,#0x10]         ;885
00009a  ea000701          AND      r7,r0,r1              ;885
00009e  b14f              CBZ      r7,|L8.180|
0000a0  4639              MOV      r1,r7                 ;887
0000a2  4628              MOV      r0,r5                 ;887
0000a4  f7fffffe          BL       OS_FlagTaskRdy
0000a8  4680              MOV      r8,r0                 ;887
0000aa  f1b80f01          CMP      r8,#1                 ;888
0000ae  d101              BNE      |L8.180|
0000b0  f04f0b01          MOV      r11,#1                ;889
                  |L8.180|
0000b4  e028              B        |L8.264|
                  |L8.182|
0000b6  8a28              LDRH     r0,[r5,#0x10]         ;896
0000b8  8921              LDRH     r1,[r4,#8]            ;896
0000ba  ea200701          BIC      r7,r0,r1              ;896
0000be  8a28              LDRH     r0,[r5,#0x10]         ;897
0000c0  42b8              CMP      r0,r7                 ;897
0000c2  d109              BNE      |L8.216|
0000c4  4639              MOV      r1,r7                 ;898
0000c6  4628              MOV      r0,r5                 ;898
0000c8  f7fffffe          BL       OS_FlagTaskRdy
0000cc  4680              MOV      r8,r0                 ;898
0000ce  f1b80f01          CMP      r8,#1                 ;899
0000d2  d101              BNE      |L8.216|
0000d4  f04f0b01          MOV      r11,#1                ;900
                  |L8.216|
0000d8  e016              B        |L8.264|
                  |L8.218|
0000da  8a28              LDRH     r0,[r5,#0x10]         ;906
0000dc  8921              LDRH     r1,[r4,#8]            ;906
0000de  ea200701          BIC      r7,r0,r1              ;906
0000e2  b14f              CBZ      r7,|L8.248|
0000e4  4639              MOV      r1,r7                 ;908
0000e6  4628              MOV      r0,r5                 ;908
0000e8  f7fffffe          BL       OS_FlagTaskRdy
0000ec  4680              MOV      r8,r0                 ;908
0000ee  f1b80f01          CMP      r8,#1                 ;909
0000f2  d101              BNE      |L8.248|
0000f4  f04f0b01          MOV      r11,#1                ;910
                  |L8.248|
0000f8  e006              B        |L8.264|
                  |L8.250|
0000fa  9800              LDR      r0,[sp,#0]            ;916
0000fc  f7fffffe          BL       OS_CPU_SR_Restore
000100  206f              MOVS     r0,#0x6f              ;917
000102  7030              STRB     r0,[r6,#0]            ;917
000104  2000              MOVS     r0,#0                 ;918
000106  e789              B        |L8.28|
                  |L8.264|
000108  bf00              NOP                            ;882
00010a  682d              LDR      r5,[r5,#0]            ;920
                  |L8.268|
00010c  2d00              CMP      r5,#0                 ;872
00010e  d1a7              BNE      |L8.96|
000110  9800              LDR      r0,[sp,#0]            ;922
000112  f7fffffe          BL       OS_CPU_SR_Restore
000116  f1bb0f01          CMP      r11,#1                ;923
00011a  d101              BNE      |L8.288|
00011c  f7fffffe          BL       OS_Sched
                  |L8.288|
000120  f7fffffe          BL       OS_CPU_SR_Save
000124  9000              STR      r0,[sp,#0]            ;926
000126  8920              LDRH     r0,[r4,#8]            ;927
000128  9001              STR      r0,[sp,#4]            ;927
00012a  9800              LDR      r0,[sp,#0]            ;928
00012c  f7fffffe          BL       OS_CPU_SR_Restore
000130  2000              MOVS     r0,#0                 ;929
000132  7030              STRB     r0,[r6,#0]            ;929
000134  9801              LDR      r0,[sp,#4]            ;930
000136  e771              B        |L8.28|
;;;932    /*$PAGE*/
                          ENDP


                          AREA ||i.OSFlagQuery||, CODE, READONLY, ALIGN=1

                  OSFlagQuery PROC
;;;952    #if OS_FLAG_QUERY_EN > 0u
;;;953    OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;954                           INT8U        *perr)
;;;955    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;956        OS_FLAGS   flags;
;;;957    #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
;;;958        OS_CPU_SR  cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;959    #endif
;;;960    
;;;961    
;;;962    
;;;963    #ifdef OS_SAFETY_CRITICAL
;;;964        if (perr == (INT8U *)0) {
;;;965            OS_SAFETY_CRITICAL_EXCEPTION();
;;;966        }
;;;967    #endif
;;;968    
;;;969    #if OS_ARG_CHK_EN > 0u
;;;970        if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
;;;971            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;972            return ((OS_FLAGS)0);
;;;973        }
;;;974    #endif
;;;975        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
00000a  7820              LDRB     r0,[r4,#0]
00000c  2805              CMP      r0,#5
00000e  d004              BEQ      |L9.26|
;;;976            *perr = OS_ERR_EVENT_TYPE;
000010  2001              MOVS     r0,#1
000012  7028              STRB     r0,[r5,#0]
;;;977            return ((OS_FLAGS)0);
000014  2000              MOVS     r0,#0
                  |L9.22|
;;;978        }
;;;979        OS_ENTER_CRITICAL();
;;;980        flags = pgrp->OSFlagFlags;
;;;981        OS_EXIT_CRITICAL();
;;;982        *perr = OS_ERR_NONE;
;;;983        return (flags);                               /* Return the current value of the event flags       */
;;;984    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L9.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;979
000020  8926              LDRH     r6,[r4,#8]            ;980
000022  4638              MOV      r0,r7                 ;981
000024  f7fffffe          BL       OS_CPU_SR_Restore
000028  2000              MOVS     r0,#0                 ;982
00002a  7028              STRB     r0,[r5,#0]            ;982
00002c  4630              MOV      r0,r6                 ;983
00002e  e7f2              B        |L9.22|
;;;985    #endif
                          ENDP


                          AREA ||i.OSInit||, CODE, READONLY, ALIGN=1

                  OSInit PROC
;;;569    
;;;570    void  OSInit (void)
000000  b510              PUSH     {r4,lr}
;;;571    {
;;;572        OSInitHookBegin();                                           /* Call port specific initialization code   */
000002  f7fffffe          BL       OSInitHookBegin
;;;573    
;;;574        OS_InitMisc();                                               /* Initialize miscellaneous variables       */
000006  f7fffffe          BL       OS_InitMisc
;;;575    
;;;576        OS_InitRdyList();                                            /* Initialize the Ready List                */
00000a  f7fffffe          BL       OS_InitRdyList
;;;577    
;;;578        OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
00000e  f7fffffe          BL       OS_InitTCBList
;;;579    
;;;580        OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
000012  f7fffffe          BL       OS_InitEventList
;;;581    
;;;582    #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
;;;583        OS_FlagInit();                                               /* Initialize the event flag structures     */
000016  f7fffffe          BL       OS_FlagInit
;;;584    #endif
;;;585    
;;;586    #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
;;;587        OS_MemInit();                                                /* Initialize the memory manager            */
;;;588    #endif
;;;589    
;;;590    #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
;;;591        OS_QInit();                                                  /* Initialize the message queue structures  */
00001a  f7fffffe          BL       OS_QInit
;;;592    #endif
;;;593    
;;;594        OS_InitTaskIdle();                                           /* Create the Idle Task                     */
00001e  f7fffffe          BL       OS_InitTaskIdle
;;;595    #if OS_TASK_STAT_EN > 0u
;;;596        OS_InitTaskStat();                                           /* Create the Statistic Task                */
000022  f7fffffe          BL       OS_InitTaskStat
;;;597    #endif
;;;598    
;;;599    #if OS_TMR_EN > 0u
;;;600        OSTmr_Init();                                                /* Initialize the Timer Manager             */
;;;601    #endif
;;;602    
;;;603        OSInitHookEnd();                                             /* Call port specific init. code            */
000026  f7fffffe          BL       OSInitHookEnd
;;;604    
;;;605    #if OS_DEBUG_EN > 0u
;;;606        OSDebugInit();
;;;607    #endif
;;;608    }
00002a  bd10              POP      {r4,pc}
;;;609    /*$PAGE*/
                          ENDP


                          AREA ||i.OSIntEnter||, CODE, READONLY, ALIGN=2

                  OSIntEnter PROC
;;;634    
;;;635    void  OSIntEnter (void)
000000  4806              LDR      r0,|L11.28|
;;;636    {
;;;637        if (OSRunning == OS_TRUE) {
000002  7800              LDRB     r0,[r0,#0]  ; OSRunning
000004  2801              CMP      r0,#1
000006  d108              BNE      |L11.26|
;;;638            if (OSIntNesting < 255u) {
000008  4805              LDR      r0,|L11.32|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000c  28ff              CMP      r0,#0xff
00000e  d204              BCS      |L11.26|
;;;639                OSIntNesting++;                      /* Increment ISR nesting level                        */
000010  4803              LDR      r0,|L11.32|
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000014  1c40              ADDS     r0,r0,#1
000016  4902              LDR      r1,|L11.32|
000018  7008              STRB     r0,[r1,#0]
                  |L11.26|
;;;640            }
;;;641        }
;;;642    }
00001a  4770              BX       lr
;;;643    /*$PAGE*/
                          ENDP

                  |L11.28|
                          DCD      OSRunning
                  |L11.32|
                          DCD      OSIntNesting

                          AREA ||i.OSIntExit||, CODE, READONLY, ALIGN=2

                  OSIntExit PROC
;;;662    
;;;663    void  OSIntExit (void)
000000  b510              PUSH     {r4,lr}
;;;664    {
;;;665    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;666        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;667    #endif
;;;668    
;;;669    
;;;670    
;;;671        if (OSRunning == OS_TRUE) {
000004  481a              LDR      r0,|L12.112|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d130              BNE      |L12.110|
;;;672            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;673            if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
000012  4818              LDR      r0,|L12.116|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  b120              CBZ      r0,|L12.34|
;;;674                OSIntNesting--;
000018  4816              LDR      r0,|L12.116|
00001a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00001c  1e40              SUBS     r0,r0,#1
00001e  4915              LDR      r1,|L12.116|
000020  7008              STRB     r0,[r1,#0]
                  |L12.34|
;;;675            }
;;;676            if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
000022  4814              LDR      r0,|L12.116|
000024  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000026  b9f8              CBNZ     r0,|L12.104|
;;;677                if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
000028  4813              LDR      r0,|L12.120|
00002a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00002c  b9e0              CBNZ     r0,|L12.104|
;;;678                    OS_SchedNew();
00002e  f7fffffe          BL       OS_SchedNew
;;;679                    OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
000032  4812              LDR      r0,|L12.124|
000034  4912              LDR      r1,|L12.128|
000036  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000038  f8500021          LDR      r0,[r0,r1,LSL #2]
00003c  4911              LDR      r1,|L12.132|
00003e  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;680                    if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
000040  480f              LDR      r0,|L12.128|
000042  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000044  4910              LDR      r1,|L12.136|
000046  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000048  4288              CMP      r0,r1
00004a  d00d              BEQ      |L12.104|
;;;681    #if OS_TASK_PROFILE_EN > 0u
;;;682                        OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
00004c  480d              LDR      r0,|L12.132|
00004e  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000050  6b80              LDR      r0,[r0,#0x38]
000052  1c40              ADDS     r0,r0,#1
000054  490b              LDR      r1,|L12.132|
000056  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000058  6388              STR      r0,[r1,#0x38]
;;;683    #endif
;;;684                        OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
00005a  480c              LDR      r0,|L12.140|
00005c  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
00005e  1c40              ADDS     r0,r0,#1
000060  490a              LDR      r1,|L12.140|
000062  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;685                        OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
000064  f7fffffe          BL       OSIntCtxSw
                  |L12.104|
;;;686                    }
;;;687                }
;;;688            }
;;;689            OS_EXIT_CRITICAL();
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       OS_CPU_SR_Restore
                  |L12.110|
;;;690        }
;;;691    }
00006e  bd10              POP      {r4,pc}
;;;692    /*$PAGE*/
                          ENDP

                  |L12.112|
                          DCD      OSRunning
                  |L12.116|
                          DCD      OSIntNesting
                  |L12.120|
                          DCD      OSLockNesting
                  |L12.124|
                          DCD      OSTCBPrioTbl
                  |L12.128|
                          DCD      OSPrioHighRdy
                  |L12.132|
                          DCD      OSTCBHighRdy
                  |L12.136|
                          DCD      OSPrioCur
                  |L12.140|
                          DCD      OSCtxSwCtr

                          AREA ||i.OSMboxAccept||, CODE, READONLY, ALIGN=1

                  OSMboxAccept PROC
;;;46     #if OS_MBOX_ACCEPT_EN > 0u
;;;47     void  *OSMboxAccept (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;48     {
000002  4604              MOV      r4,r0
;;;49         void      *pmsg;
;;;50     #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
;;;51         OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;52     #endif
;;;53     
;;;54     
;;;55     
;;;56     #if OS_ARG_CHK_EN > 0u
;;;57         if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
;;;58             return ((void *)0);
;;;59         }
;;;60     #endif
;;;61         if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
000006  7820              LDRB     r0,[r4,#0]
000008  2801              CMP      r0,#1
00000a  d001              BEQ      |L13.16|
;;;62             return ((void *)0);
00000c  2000              MOVS     r0,#0
                  |L13.14|
;;;63         }
;;;64         OS_ENTER_CRITICAL();
;;;65         pmsg               = pevent->OSEventPtr;
;;;66         pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
;;;67         OS_EXIT_CRITICAL();
;;;68         return (pmsg);                                        /* Return the message received (or NULL)     */
;;;69     }
00000e  bd70              POP      {r4-r6,pc}
                  |L13.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4606              MOV      r6,r0                 ;64
000016  6865              LDR      r5,[r4,#4]            ;65
000018  2000              MOVS     r0,#0                 ;66
00001a  6060              STR      r0,[r4,#4]            ;66
00001c  4630              MOV      r0,r6                 ;67
00001e  f7fffffe          BL       OS_CPU_SR_Restore
000022  4628              MOV      r0,r5                 ;68
000024  e7f3              B        |L13.14|
;;;70     #endif
                          ENDP


                          AREA ||i.OSMboxCreate||, CODE, READONLY, ALIGN=2

                  OSMboxCreate PROC
;;;87     
;;;88     OS_EVENT  *OSMboxCreate (void *pmsg)
000000  b570              PUSH     {r4-r6,lr}
;;;89     {
000002  4605              MOV      r5,r0
;;;90         OS_EVENT  *pevent;
;;;91     #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;92         OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;93     #endif
;;;94     
;;;95     
;;;96     
;;;97     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;98         if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;99             OS_SAFETY_CRITICAL_EXCEPTION();
;;;100        }
;;;101    #endif
;;;102    
;;;103        if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000006  480f              LDR      r0,|L14.68|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000a  b108              CBZ      r0,|L14.16|
;;;104            return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
00000c  2000              MOVS     r0,#0
                  |L14.14|
;;;105        }
;;;106        OS_ENTER_CRITICAL();
;;;107        pevent = OSEventFreeList;                    /* Get next free event control block                  */
;;;108        if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
;;;109            OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
;;;110        }
;;;111        OS_EXIT_CRITICAL();
;;;112        if (pevent != (OS_EVENT *)0) {
;;;113            pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
;;;114            pevent->OSEventCnt     = 0u;
;;;115            pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
;;;116    #if OS_EVENT_NAME_EN > 0u
;;;117            pevent->OSEventName    = (INT8U *)(void *)"?";
;;;118    #endif
;;;119            OS_EventWaitListInit(pevent);
;;;120        }
;;;121        return (pevent);                             /* Return pointer to event control block              */
;;;122    }
00000e  bd70              POP      {r4-r6,pc}
                  |L14.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4606              MOV      r6,r0                 ;106
000016  480c              LDR      r0,|L14.72|
000018  6804              LDR      r4,[r0,#0]            ;107  ; OSEventFreeList
00001a  6800              LDR      r0,[r0,#0]            ;108  ; OSEventFreeList
00001c  b120              CBZ      r0,|L14.40|
00001e  480a              LDR      r0,|L14.72|
000020  6800              LDR      r0,[r0,#0]            ;109  ; OSEventFreeList
000022  6840              LDR      r0,[r0,#4]            ;109
000024  4908              LDR      r1,|L14.72|
000026  6008              STR      r0,[r1,#0]            ;109  ; OSEventFreeList
                  |L14.40|
000028  4630              MOV      r0,r6                 ;111
00002a  f7fffffe          BL       OS_CPU_SR_Restore
00002e  b13c              CBZ      r4,|L14.64|
000030  2001              MOVS     r0,#1                 ;113
000032  7020              STRB     r0,[r4,#0]            ;113
000034  2000              MOVS     r0,#0                 ;114
000036  8120              STRH     r0,[r4,#8]            ;114
000038  6065              STR      r5,[r4,#4]            ;115
00003a  4620              MOV      r0,r4                 ;119
00003c  f7fffffe          BL       OS_EventWaitListInit
                  |L14.64|
000040  4620              MOV      r0,r4                 ;121
000042  e7e4              B        |L14.14|
;;;123    /*$PAGE*/
                          ENDP

                  |L14.68|
                          DCD      OSIntNesting
                  |L14.72|
                          DCD      OSEventFreeList

                          AREA ||i.OSMboxDel||, CODE, READONLY, ALIGN=2

                  OSMboxDel PROC
;;;160    #if OS_MBOX_DEL_EN > 0u
;;;161    OS_EVENT  *OSMboxDel (OS_EVENT  *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;162                          INT8U      opt,
;;;163                          INT8U     *perr)
;;;164    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;165        BOOLEAN    tasks_waiting;
;;;166        OS_EVENT  *pevent_return;
;;;167    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;168        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0900          MOV      r9,#0
;;;169    #endif
;;;170    
;;;171    
;;;172    
;;;173    #ifdef OS_SAFETY_CRITICAL
;;;174        if (perr == (INT8U *)0) {
;;;175            OS_SAFETY_CRITICAL_EXCEPTION();
;;;176        }
;;;177    #endif
;;;178    
;;;179    #if OS_ARG_CHK_EN > 0u
;;;180        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;181            *perr = OS_ERR_PEVENT_NULL;
;;;182            return (pevent);
;;;183        }
;;;184    #endif
;;;185        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00000e  7820              LDRB     r0,[r4,#0]
000010  2801              CMP      r0,#1
000012  d004              BEQ      |L15.30|
;;;186            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;187            return (pevent);
000018  4620              MOV      r0,r4
                  |L15.26|
;;;188        }
;;;189        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
;;;190            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
;;;191            return (pevent);
;;;192        }
;;;193        OS_ENTER_CRITICAL();
;;;194        if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
;;;195            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;196        } else {
;;;197            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;198        }
;;;199        switch (opt) {
;;;200            case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
;;;201                 if (tasks_waiting == OS_FALSE) {
;;;202    #if OS_EVENT_NAME_EN > 0u
;;;203                     pevent->OSEventName = (INT8U *)(void *)"?";
;;;204    #endif
;;;205                     pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
;;;206                     pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
;;;207                     pevent->OSEventCnt  = 0u;
;;;208                     OSEventFreeList     = pevent;             /* Get next free event control block        */
;;;209                     OS_EXIT_CRITICAL();
;;;210                     *perr               = OS_ERR_NONE;
;;;211                     pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
;;;212                 } else {
;;;213                     OS_EXIT_CRITICAL();
;;;214                     *perr               = OS_ERR_TASK_WAITING;
;;;215                     pevent_return       = pevent;
;;;216                 }
;;;217                 break;
;;;218    
;;;219            case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
;;;220                 while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
;;;221                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;222                 }
;;;223    #if OS_EVENT_NAME_EN > 0u
;;;224                 pevent->OSEventName    = (INT8U *)(void *)"?";
;;;225    #endif
;;;226                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;227                 pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
;;;228                 pevent->OSEventCnt     = 0u;
;;;229                 OSEventFreeList        = pevent;              /* Get next free event control block        */
;;;230                 OS_EXIT_CRITICAL();
;;;231                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;232                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;233                 }
;;;234                 *perr         = OS_ERR_NONE;
;;;235                 pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
;;;236                 break;
;;;237    
;;;238            default:
;;;239                 OS_EXIT_CRITICAL();
;;;240                 *perr         = OS_ERR_INVALID_OPT;
;;;241                 pevent_return = pevent;
;;;242                 break;
;;;243        }
;;;244        return (pevent_return);
;;;245    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L15.30|
00001e  482a              LDR      r0,|L15.200|
000020  7800              LDRB     r0,[r0,#0]            ;189  ; OSIntNesting
000022  b118              CBZ      r0,|L15.44|
000024  200f              MOVS     r0,#0xf               ;190
000026  7028              STRB     r0,[r5,#0]            ;190
000028  4620              MOV      r0,r4                 ;191
00002a  e7f6              B        |L15.26|
                  |L15.44|
00002c  f7fffffe          BL       OS_CPU_SR_Save
000030  4681              MOV      r9,r0                 ;193
000032  7aa0              LDRB     r0,[r4,#0xa]          ;194
000034  b108              CBZ      r0,|L15.58|
000036  2701              MOVS     r7,#1                 ;195
000038  e000              B        |L15.60|
                  |L15.58|
00003a  2700              MOVS     r7,#0                 ;197
                  |L15.60|
00003c  f1b80f00          CMP      r8,#0                 ;199
000040  d003              BEQ      |L15.74|
000042  f1b80f01          CMP      r8,#1                 ;199
000046  d135              BNE      |L15.180|
000048  e017              B        |L15.122|
                  |L15.74|
00004a  b97f              CBNZ     r7,|L15.108|
00004c  2000              MOVS     r0,#0                 ;205
00004e  7020              STRB     r0,[r4,#0]            ;205
000050  481e              LDR      r0,|L15.204|
000052  6800              LDR      r0,[r0,#0]            ;206  ; OSEventFreeList
000054  6060              STR      r0,[r4,#4]            ;206
000056  2000              MOVS     r0,#0                 ;207
000058  8120              STRH     r0,[r4,#8]            ;207
00005a  481c              LDR      r0,|L15.204|
00005c  6004              STR      r4,[r0,#0]            ;208  ; OSEventFreeList
00005e  4648              MOV      r0,r9                 ;209
000060  f7fffffe          BL       OS_CPU_SR_Restore
000064  2000              MOVS     r0,#0                 ;210
000066  7028              STRB     r0,[r5,#0]            ;210
000068  2600              MOVS     r6,#0                 ;211
00006a  e005              B        |L15.120|
                  |L15.108|
00006c  4648              MOV      r0,r9                 ;213
00006e  f7fffffe          BL       OS_CPU_SR_Restore
000072  2049              MOVS     r0,#0x49              ;214
000074  7028              STRB     r0,[r5,#0]            ;214
000076  4626              MOV      r6,r4                 ;215
                  |L15.120|
000078  e023              B        |L15.194|
                  |L15.122|
00007a  e005              B        |L15.136|
                  |L15.124|
00007c  2300              MOVS     r3,#0                 ;221
00007e  2202              MOVS     r2,#2                 ;221
000080  4619              MOV      r1,r3                 ;221
000082  4620              MOV      r0,r4                 ;221
000084  f7fffffe          BL       OS_EventTaskRdy
                  |L15.136|
000088  7aa0              LDRB     r0,[r4,#0xa]          ;220
00008a  2800              CMP      r0,#0                 ;220
00008c  d1f6              BNE      |L15.124|
00008e  7020              STRB     r0,[r4,#0]            ;226
000090  480e              LDR      r0,|L15.204|
000092  6800              LDR      r0,[r0,#0]            ;227  ; OSEventFreeList
000094  6060              STR      r0,[r4,#4]            ;227
000096  2000              MOVS     r0,#0                 ;228
000098  8120              STRH     r0,[r4,#8]            ;228
00009a  480c              LDR      r0,|L15.204|
00009c  6004              STR      r4,[r0,#0]            ;229  ; OSEventFreeList
00009e  4648              MOV      r0,r9                 ;230
0000a0  f7fffffe          BL       OS_CPU_SR_Restore
0000a4  2f01              CMP      r7,#1                 ;231
0000a6  d101              BNE      |L15.172|
0000a8  f7fffffe          BL       OS_Sched
                  |L15.172|
0000ac  2000              MOVS     r0,#0                 ;234
0000ae  7028              STRB     r0,[r5,#0]            ;234
0000b0  2600              MOVS     r6,#0                 ;235
0000b2  e006              B        |L15.194|
                  |L15.180|
0000b4  4648              MOV      r0,r9                 ;239
0000b6  f7fffffe          BL       OS_CPU_SR_Restore
0000ba  2007              MOVS     r0,#7                 ;240
0000bc  7028              STRB     r0,[r5,#0]            ;240
0000be  4626              MOV      r6,r4                 ;241
0000c0  bf00              NOP                            ;242
                  |L15.194|
0000c2  bf00              NOP                            ;217
0000c4  4630              MOV      r0,r6                 ;244
0000c6  e7a8              B        |L15.26|
;;;246    #endif
                          ENDP

                  |L15.200|
                          DCD      OSIntNesting
                  |L15.204|
                          DCD      OSEventFreeList

                          AREA ||i.OSMboxPend||, CODE, READONLY, ALIGN=2

                  OSMboxPend PROC
;;;281    /*$PAGE*/
;;;282    void  *OSMboxPend (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;283                       INT32U     timeout,
;;;284                       INT8U     *perr)
;;;285    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;286        void      *pmsg;
;;;287    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;288        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;289    #endif
;;;290    
;;;291    
;;;292    
;;;293    #ifdef OS_SAFETY_CRITICAL
;;;294        if (perr == (INT8U *)0) {
;;;295            OS_SAFETY_CRITICAL_EXCEPTION();
;;;296        }
;;;297    #endif
;;;298    
;;;299    #if OS_ARG_CHK_EN > 0u
;;;300        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;301            *perr = OS_ERR_PEVENT_NULL;
;;;302            return ((void *)0);
;;;303        }
;;;304    #endif
;;;305        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00000e  7828              LDRB     r0,[r5,#0]
000010  2801              CMP      r0,#1
000012  d004              BEQ      |L16.30|
;;;306            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7020              STRB     r0,[r4,#0]
;;;307            return ((void *)0);
000018  2000              MOVS     r0,#0
                  |L16.26|
;;;308        }
;;;309        if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
;;;310            *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
;;;311            return ((void *)0);
;;;312        }
;;;313        if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
;;;314            *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
;;;315            return ((void *)0);
;;;316        }
;;;317        OS_ENTER_CRITICAL();
;;;318        pmsg = pevent->OSEventPtr;
;;;319        if (pmsg != (void *)0) {                          /* See if there is already a message             */
;;;320            pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
;;;321            OS_EXIT_CRITICAL();
;;;322            *perr = OS_ERR_NONE;
;;;323            return (pmsg);                                /* Return the message received (or NULL)         */
;;;324        }
;;;325        OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
;;;326        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;327        OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
;;;328        OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
;;;329        OS_EXIT_CRITICAL();
;;;330        OS_Sched();                                       /* Find next highest priority task ready to run  */
;;;331        OS_ENTER_CRITICAL();
;;;332        switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
;;;333            case OS_STAT_PEND_OK:
;;;334                 pmsg =  OSTCBCur->OSTCBMsg;
;;;335                *perr =  OS_ERR_NONE;
;;;336                 break;
;;;337    
;;;338            case OS_STAT_PEND_ABORT:
;;;339                 pmsg = (void *)0;
;;;340                *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
;;;341                 break;
;;;342    
;;;343            case OS_STAT_PEND_TO:
;;;344            default:
;;;345                 OS_EventTaskRemove(OSTCBCur, pevent);
;;;346                 pmsg = (void *)0;
;;;347                *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
;;;348                 break;
;;;349        }
;;;350        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
;;;351        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
;;;352        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
;;;353    #if (OS_EVENT_MULTI_EN > 0u)
;;;354        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;355    #endif
;;;356        OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
;;;357        OS_EXIT_CRITICAL();
;;;358        return (pmsg);                                    /* Return received message                       */
;;;359    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L16.30|
00001e  4836              LDR      r0,|L16.248|
000020  7800              LDRB     r0,[r0,#0]            ;309  ; OSIntNesting
000022  b118              CBZ      r0,|L16.44|
000024  2002              MOVS     r0,#2                 ;310
000026  7020              STRB     r0,[r4,#0]            ;310
000028  2000              MOVS     r0,#0                 ;311
00002a  e7f6              B        |L16.26|
                  |L16.44|
00002c  4833              LDR      r0,|L16.252|
00002e  7800              LDRB     r0,[r0,#0]            ;313  ; OSLockNesting
000030  b118              CBZ      r0,|L16.58|
000032  200d              MOVS     r0,#0xd               ;314
000034  7020              STRB     r0,[r4,#0]            ;314
000036  2000              MOVS     r0,#0                 ;315
000038  e7ef              B        |L16.26|
                  |L16.58|
00003a  f7fffffe          BL       OS_CPU_SR_Save
00003e  4680              MOV      r8,r0                 ;317
000040  686e              LDR      r6,[r5,#4]            ;318
000042  b146              CBZ      r6,|L16.86|
000044  2000              MOVS     r0,#0                 ;320
000046  6068              STR      r0,[r5,#4]            ;320
000048  4640              MOV      r0,r8                 ;321
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2000              MOVS     r0,#0                 ;322
000050  7020              STRB     r0,[r4,#0]            ;322
000052  4630              MOV      r0,r6                 ;323
000054  e7e1              B        |L16.26|
                  |L16.86|
000056  482a              LDR      r0,|L16.256|
000058  6800              LDR      r0,[r0,#0]            ;325  ; OSTCBCur
00005a  f8900030          LDRB     r0,[r0,#0x30]         ;325
00005e  f0400002          ORR      r0,r0,#2              ;325
000062  4927              LDR      r1,|L16.256|
000064  6809              LDR      r1,[r1,#0]            ;325  ; OSTCBCur
000066  f8810030          STRB     r0,[r1,#0x30]         ;325
00006a  2000              MOVS     r0,#0                 ;326
00006c  4924              LDR      r1,|L16.256|
00006e  6809              LDR      r1,[r1,#0]            ;326  ; OSTCBCur
000070  f8810031          STRB     r0,[r1,#0x31]         ;326
000074  4822              LDR      r0,|L16.256|
000076  6800              LDR      r0,[r0,#0]            ;327  ; OSTCBCur
000078  62c7              STR      r7,[r0,#0x2c]         ;327
00007a  4628              MOV      r0,r5                 ;328
00007c  f7fffffe          BL       OS_EventTaskWait
000080  4640              MOV      r0,r8                 ;329
000082  f7fffffe          BL       OS_CPU_SR_Restore
000086  f7fffffe          BL       OS_Sched
00008a  f7fffffe          BL       OS_CPU_SR_Save
00008e  4680              MOV      r8,r0                 ;331
000090  481b              LDR      r0,|L16.256|
000092  6800              LDR      r0,[r0,#0]            ;332  ; OSTCBCur
000094  f8900031          LDRB     r0,[r0,#0x31]         ;332
000098  b120              CBZ      r0,|L16.164|
00009a  2801              CMP      r0,#1                 ;332
00009c  d00d              BEQ      |L16.186|
00009e  2802              CMP      r0,#2                 ;332
0000a0  d10a              BNE      |L16.184|
0000a2  e005              B        |L16.176|
                  |L16.164|
0000a4  4816              LDR      r0,|L16.256|
0000a6  6800              LDR      r0,[r0,#0]            ;334  ; OSTCBCur
0000a8  6a06              LDR      r6,[r0,#0x20]         ;334
0000aa  2000              MOVS     r0,#0                 ;335
0000ac  7020              STRB     r0,[r4,#0]            ;335
0000ae  e00d              B        |L16.204|
                  |L16.176|
0000b0  2600              MOVS     r6,#0                 ;339
0000b2  200e              MOVS     r0,#0xe               ;340
0000b4  7020              STRB     r0,[r4,#0]            ;340
0000b6  e009              B        |L16.204|
                  |L16.184|
0000b8  bf00              NOP                            ;343
                  |L16.186|
0000ba  4629              MOV      r1,r5                 ;345
0000bc  4810              LDR      r0,|L16.256|
0000be  6800              LDR      r0,[r0,#0]            ;345  ; OSTCBCur
0000c0  f7fffffe          BL       OS_EventTaskRemove
0000c4  2600              MOVS     r6,#0                 ;346
0000c6  200a              MOVS     r0,#0xa               ;347
0000c8  7020              STRB     r0,[r4,#0]            ;347
0000ca  bf00              NOP                            ;348
                  |L16.204|
0000cc  bf00              NOP                            ;336
0000ce  2000              MOVS     r0,#0                 ;350
0000d0  490b              LDR      r1,|L16.256|
0000d2  6809              LDR      r1,[r1,#0]            ;350  ; OSTCBCur
0000d4  f8810030          STRB     r0,[r1,#0x30]         ;350
0000d8  4909              LDR      r1,|L16.256|
0000da  6809              LDR      r1,[r1,#0]            ;351  ; OSTCBCur
0000dc  f8810031          STRB     r0,[r1,#0x31]         ;351
0000e0  4907              LDR      r1,|L16.256|
0000e2  6809              LDR      r1,[r1,#0]            ;352  ; OSTCBCur
0000e4  61c8              STR      r0,[r1,#0x1c]         ;352
0000e6  4906              LDR      r1,|L16.256|
0000e8  6809              LDR      r1,[r1,#0]            ;356  ; OSTCBCur
0000ea  6208              STR      r0,[r1,#0x20]         ;356
0000ec  4640              MOV      r0,r8                 ;357
0000ee  f7fffffe          BL       OS_CPU_SR_Restore
0000f2  4630              MOV      r0,r6                 ;358
0000f4  e791              B        |L16.26|
;;;360    /*$PAGE*/
                          ENDP

0000f6  0000              DCW      0x0000
                  |L16.248|
                          DCD      OSIntNesting
                  |L16.252|
                          DCD      OSLockNesting
                  |L16.256|
                          DCD      OSTCBCur

                          AREA ||i.OSMboxPendAbort||, CODE, READONLY, ALIGN=1

                  OSMboxPendAbort PROC
;;;393    #if OS_MBOX_PEND_ABORT_EN > 0u
;;;394    INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;395                            INT8U      opt,
;;;396                            INT8U     *perr)
;;;397    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;398        INT8U      nbr_tasks;
;;;399    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;400        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;401    #endif
;;;402    
;;;403    
;;;404    
;;;405    #ifdef OS_SAFETY_CRITICAL
;;;406        if (perr == (INT8U *)0) {
;;;407            OS_SAFETY_CRITICAL_EXCEPTION();
;;;408        }
;;;409    #endif
;;;410    
;;;411    #if OS_ARG_CHK_EN > 0u
;;;412        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;413            *perr = OS_ERR_PEVENT_NULL;
;;;414            return (0u);
;;;415        }
;;;416    #endif
;;;417        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00000e  7820              LDRB     r0,[r4,#0]
000010  2801              CMP      r0,#1
000012  d004              BEQ      |L17.30|
;;;418            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;419            return (0u);
000018  2000              MOVS     r0,#0
                  |L17.26|
;;;420        }
;;;421        OS_ENTER_CRITICAL();
;;;422        if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
;;;423            nbr_tasks = 0u;
;;;424            switch (opt) {
;;;425                case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
;;;426                     while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
;;;427                         (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
;;;428                         nbr_tasks++;
;;;429                     }
;;;430                     break;
;;;431    
;;;432                case OS_PEND_OPT_NONE:
;;;433                default:                                       /* No,  ready HPT       waiting on mailbox  */
;;;434                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
;;;435                     nbr_tasks++;
;;;436                     break;
;;;437            }
;;;438            OS_EXIT_CRITICAL();
;;;439            OS_Sched();                                        /* Find HPT ready to run                    */
;;;440            *perr = OS_ERR_PEND_ABORT;
;;;441            return (nbr_tasks);
;;;442        }
;;;443        OS_EXIT_CRITICAL();
;;;444        *perr = OS_ERR_NONE;
;;;445        return (0u);                                           /* No tasks waiting on mailbox              */
;;;446    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L17.30|
00001e  f7fffffe          BL       OS_CPU_SR_Save
000022  4680              MOV      r8,r0                 ;421
000024  7aa0              LDRB     r0,[r4,#0xa]          ;422
000026  b320              CBZ      r0,|L17.114|
000028  2600              MOVS     r6,#0                 ;423
00002a  b17f              CBZ      r7,|L17.76|
00002c  2f01              CMP      r7,#1                 ;424
00002e  d10c              BNE      |L17.74|
000030  e007              B        |L17.66|
                  |L17.50|
000032  2302              MOVS     r3,#2                 ;427
000034  461a              MOV      r2,r3                 ;427
000036  2100              MOVS     r1,#0                 ;427
000038  4620              MOV      r0,r4                 ;427
00003a  f7fffffe          BL       OS_EventTaskRdy
00003e  1c70              ADDS     r0,r6,#1              ;428
000040  b2c6              UXTB     r6,r0                 ;428
                  |L17.66|
000042  7aa0              LDRB     r0,[r4,#0xa]          ;426
000044  2800              CMP      r0,#0                 ;426
000046  d1f4              BNE      |L17.50|
000048  e009              B        |L17.94|
                  |L17.74|
00004a  bf00              NOP                            ;432
                  |L17.76|
00004c  2302              MOVS     r3,#2                 ;434
00004e  461a              MOV      r2,r3                 ;434
000050  2100              MOVS     r1,#0                 ;434
000052  4620              MOV      r0,r4                 ;434
000054  f7fffffe          BL       OS_EventTaskRdy
000058  1c70              ADDS     r0,r6,#1              ;435
00005a  b2c6              UXTB     r6,r0                 ;435
00005c  bf00              NOP                            ;436
                  |L17.94|
00005e  bf00              NOP                            ;430
000060  4640              MOV      r0,r8                 ;438
000062  f7fffffe          BL       OS_CPU_SR_Restore
000066  f7fffffe          BL       OS_Sched
00006a  200e              MOVS     r0,#0xe               ;440
00006c  7028              STRB     r0,[r5,#0]            ;440
00006e  4630              MOV      r0,r6                 ;441
000070  e7d3              B        |L17.26|
                  |L17.114|
000072  4640              MOV      r0,r8                 ;443
000074  f7fffffe          BL       OS_CPU_SR_Restore
000078  2000              MOVS     r0,#0                 ;444
00007a  7028              STRB     r0,[r5,#0]            ;444
00007c  bf00              NOP                            ;445
00007e  e7cc              B        |L17.26|
;;;447    #endif
                          ENDP


                          AREA ||i.OSMboxPost||, CODE, READONLY, ALIGN=1

                  OSMboxPost PROC
;;;472    #if OS_MBOX_POST_EN > 0u
;;;473    INT8U  OSMboxPost (OS_EVENT  *pevent,
000000  b570              PUSH     {r4-r6,lr}
;;;474                       void      *pmsg)
;;;475    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;476    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;477        OS_CPU_SR  cpu_sr = 0u;
000006  2600              MOVS     r6,#0
;;;478    #endif
;;;479    
;;;480    
;;;481    
;;;482    #if OS_ARG_CHK_EN > 0u
;;;483        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;484            return (OS_ERR_PEVENT_NULL);
;;;485        }
;;;486        if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
;;;487            return (OS_ERR_POST_NULL_PTR);
;;;488        }
;;;489    #endif
;;;490        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
000008  7820              LDRB     r0,[r4,#0]
00000a  2801              CMP      r0,#1
00000c  d001              BEQ      |L18.18|
;;;491            return (OS_ERR_EVENT_TYPE);
00000e  2001              MOVS     r0,#1
                  |L18.16|
;;;492        }
;;;493        OS_ENTER_CRITICAL();
;;;494        if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
;;;495                                                          /* Ready HPT waiting on event                    */
;;;496            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;497            OS_EXIT_CRITICAL();
;;;498            OS_Sched();                                   /* Find highest priority task ready to run       */
;;;499            return (OS_ERR_NONE);
;;;500        }
;;;501        if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
;;;502            OS_EXIT_CRITICAL();
;;;503            return (OS_ERR_MBOX_FULL);
;;;504        }
;;;505        pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
;;;506        OS_EXIT_CRITICAL();
;;;507        return (OS_ERR_NONE);
;;;508    }
000010  bd70              POP      {r4-r6,pc}
                  |L18.18|
000012  f7fffffe          BL       OS_CPU_SR_Save
000016  4606              MOV      r6,r0                 ;493
000018  7aa0              LDRB     r0,[r4,#0xa]          ;494
00001a  b160              CBZ      r0,|L18.54|
00001c  2300              MOVS     r3,#0                 ;496
00001e  2202              MOVS     r2,#2                 ;496
000020  4629              MOV      r1,r5                 ;496
000022  4620              MOV      r0,r4                 ;496
000024  f7fffffe          BL       OS_EventTaskRdy
000028  4630              MOV      r0,r6                 ;497
00002a  f7fffffe          BL       OS_CPU_SR_Restore
00002e  f7fffffe          BL       OS_Sched
000032  2000              MOVS     r0,#0                 ;499
000034  e7ec              B        |L18.16|
                  |L18.54|
000036  6860              LDR      r0,[r4,#4]            ;501
000038  b120              CBZ      r0,|L18.68|
00003a  4630              MOV      r0,r6                 ;502
00003c  f7fffffe          BL       OS_CPU_SR_Restore
000040  2014              MOVS     r0,#0x14              ;503
000042  e7e5              B        |L18.16|
                  |L18.68|
000044  6065              STR      r5,[r4,#4]            ;505
000046  4630              MOV      r0,r6                 ;506
000048  f7fffffe          BL       OS_CPU_SR_Restore
00004c  2000              MOVS     r0,#0                 ;507
00004e  e7df              B        |L18.16|
;;;509    #endif
                          ENDP


                          AREA ||i.OSMboxPostOpt||, CODE, READONLY, ALIGN=1

                  OSMboxPostOpt PROC
;;;544    #if OS_MBOX_POST_OPT_EN > 0u
;;;545    INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;546                          void      *pmsg,
;;;547                          INT8U      opt)
;;;548    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;549    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;550        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;551    #endif
;;;552    
;;;553    
;;;554    
;;;555    #if OS_ARG_CHK_EN > 0u
;;;556        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;557            return (OS_ERR_PEVENT_NULL);
;;;558        }
;;;559        if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
;;;560            return (OS_ERR_POST_NULL_PTR);
;;;561        }
;;;562    #endif
;;;563        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00000c  7820              LDRB     r0,[r4,#0]
00000e  2801              CMP      r0,#1
000010  d002              BEQ      |L19.24|
;;;564            return (OS_ERR_EVENT_TYPE);
000012  2001              MOVS     r0,#1
                  |L19.20|
;;;565        }
;;;566        OS_ENTER_CRITICAL();
;;;567        if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
;;;568            if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
;;;569                while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
;;;570                    (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;571                }
;;;572            } else {                                      /* No,  Post to HPT waiting on mbox              */
;;;573                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;574            }
;;;575            OS_EXIT_CRITICAL();
;;;576            if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
;;;577                OS_Sched();                               /* Find HPT ready to run                         */
;;;578            }
;;;579            return (OS_ERR_NONE);
;;;580        }
;;;581        if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
;;;582            OS_EXIT_CRITICAL();
;;;583            return (OS_ERR_MBOX_FULL);
;;;584        }
;;;585        pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
;;;586        OS_EXIT_CRITICAL();
;;;587        return (OS_ERR_NONE);
;;;588    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L19.24|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4607              MOV      r7,r0                 ;566
00001e  7aa0              LDRB     r0,[r4,#0xa]          ;567
000020  b1e8              CBZ      r0,|L19.94|
000022  f0050001          AND      r0,r5,#1              ;568
000026  b150              CBZ      r0,|L19.62|
000028  e005              B        |L19.54|
                  |L19.42|
00002a  2300              MOVS     r3,#0                 ;570
00002c  2202              MOVS     r2,#2                 ;570
00002e  4631              MOV      r1,r6                 ;570
000030  4620              MOV      r0,r4                 ;570
000032  f7fffffe          BL       OS_EventTaskRdy
                  |L19.54|
000036  7aa0              LDRB     r0,[r4,#0xa]          ;569
000038  2800              CMP      r0,#0                 ;569
00003a  d1f6              BNE      |L19.42|
00003c  e005              B        |L19.74|
                  |L19.62|
00003e  2300              MOVS     r3,#0                 ;573
000040  2202              MOVS     r2,#2                 ;573
000042  4631              MOV      r1,r6                 ;573
000044  4620              MOV      r0,r4                 ;573
000046  f7fffffe          BL       OS_EventTaskRdy
                  |L19.74|
00004a  4638              MOV      r0,r7                 ;575
00004c  f7fffffe          BL       OS_CPU_SR_Restore
000050  f0050004          AND      r0,r5,#4              ;576
000054  b908              CBNZ     r0,|L19.90|
000056  f7fffffe          BL       OS_Sched
                  |L19.90|
00005a  2000              MOVS     r0,#0                 ;579
00005c  e7da              B        |L19.20|
                  |L19.94|
00005e  6860              LDR      r0,[r4,#4]            ;581
000060  b120              CBZ      r0,|L19.108|
000062  4638              MOV      r0,r7                 ;582
000064  f7fffffe          BL       OS_CPU_SR_Restore
000068  2014              MOVS     r0,#0x14              ;583
00006a  e7d3              B        |L19.20|
                  |L19.108|
00006c  6066              STR      r6,[r4,#4]            ;585
00006e  4638              MOV      r0,r7                 ;586
000070  f7fffffe          BL       OS_CPU_SR_Restore
000074  2000              MOVS     r0,#0                 ;587
000076  e7cd              B        |L19.20|
;;;589    #endif
                          ENDP


                          AREA ||i.OSMboxQuery||, CODE, READONLY, ALIGN=1

                  OSMboxQuery PROC
;;;610    #if OS_MBOX_QUERY_EN > 0u
;;;611    INT8U  OSMboxQuery (OS_EVENT      *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;612                        OS_MBOX_DATA  *p_mbox_data)
;;;613    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;614        INT8U       i;
;;;615        OS_PRIO    *psrc;
;;;616        OS_PRIO    *pdest;
;;;617    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;618        OS_CPU_SR   cpu_sr = 0u;
000008  f04f0900          MOV      r9,#0
;;;619    #endif
;;;620    
;;;621    
;;;622    
;;;623    #if OS_ARG_CHK_EN > 0u
;;;624        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;625            return (OS_ERR_PEVENT_NULL);
;;;626        }
;;;627        if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
;;;628            return (OS_ERR_PDATA_NULL);
;;;629        }
;;;630    #endif
;;;631        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00000c  7820              LDRB     r0,[r4,#0]
00000e  2801              CMP      r0,#1
000010  d002              BEQ      |L20.24|
;;;632            return (OS_ERR_EVENT_TYPE);
000012  2001              MOVS     r0,#1
                  |L20.20|
;;;633        }
;;;634        OS_ENTER_CRITICAL();
;;;635        p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
;;;636        psrc                    = &pevent->OSEventTbl[0];
;;;637        pdest                   = &p_mbox_data->OSEventTbl[0];
;;;638        for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
;;;639            *pdest++ = *psrc++;
;;;640        }
;;;641        p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
;;;642        OS_EXIT_CRITICAL();
;;;643        return (OS_ERR_NONE);
;;;644    }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L20.24|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4681              MOV      r9,r0                 ;634
00001e  7aa0              LDRB     r0,[r4,#0xa]          ;635
000020  7328              STRB     r0,[r5,#0xc]          ;635
000022  f104070b          ADD      r7,r4,#0xb            ;636
000026  f1050804          ADD      r8,r5,#4              ;637
00002a  2600              MOVS     r6,#0                 ;638
00002c  e005              B        |L20.58|
                  |L20.46|
00002e  f8170b01          LDRB     r0,[r7],#1            ;639
000032  f8080b01          STRB     r0,[r8],#1            ;639
000036  1c70              ADDS     r0,r6,#1              ;638
000038  b2c6              UXTB     r6,r0                 ;638
                  |L20.58|
00003a  2e08              CMP      r6,#8                 ;638
00003c  d3f7              BCC      |L20.46|
00003e  6860              LDR      r0,[r4,#4]            ;641
000040  6028              STR      r0,[r5,#0]            ;641
000042  4648              MOV      r0,r9                 ;642
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  2000              MOVS     r0,#0                 ;643
00004a  e7e3              B        |L20.20|
;;;645    #endif                                                     /* OS_MBOX_QUERY_EN                         */
                          ENDP


                          AREA ||i.OSMutexAccept||, CODE, READONLY, ALIGN=2

                  OSMutexAccept PROC
;;;83     #if OS_MUTEX_ACCEPT_EN > 0u
;;;84     BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;85                             INT8U     *perr)
;;;86     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;87         INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
;;;88     #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
;;;89         OS_CPU_SR  cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;90     #endif
;;;91     
;;;92     
;;;93     
;;;94     #ifdef OS_SAFETY_CRITICAL
;;;95         if (perr == (INT8U *)0) {
;;;96             OS_SAFETY_CRITICAL_EXCEPTION();
;;;97         }
;;;98     #endif
;;;99     
;;;100    #if OS_ARG_CHK_EN > 0u
;;;101        if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
;;;102            *perr = OS_ERR_PEVENT_NULL;
;;;103            return (OS_FALSE);
;;;104        }
;;;105    #endif
;;;106        if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
00000a  7820              LDRB     r0,[r4,#0]
00000c  2804              CMP      r0,#4
00000e  d004              BEQ      |L21.26|
;;;107            *perr = OS_ERR_EVENT_TYPE;
000010  2001              MOVS     r0,#1
000012  7028              STRB     r0,[r5,#0]
;;;108            return (OS_FALSE);
000014  2000              MOVS     r0,#0
                  |L21.22|
;;;109        }
;;;110        if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
;;;111            *perr = OS_ERR_PEND_ISR;
;;;112            return (OS_FALSE);
;;;113        }
;;;114        OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
;;;115        pip = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PIP from mutex                           */
;;;116        if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
;;;117            pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
;;;118            pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
;;;119            pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
;;;120            if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
;;;121                OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
;;;122                *perr = OS_ERR_PIP_LOWER;
;;;123            } else {
;;;124                OS_EXIT_CRITICAL();
;;;125                *perr = OS_ERR_NONE;
;;;126            }
;;;127            return (OS_TRUE);
;;;128        }
;;;129        OS_EXIT_CRITICAL();
;;;130        *perr = OS_ERR_NONE;
;;;131        return (OS_FALSE);
;;;132    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L21.26|
00001a  481b              LDR      r0,|L21.136|
00001c  7800              LDRB     r0,[r0,#0]            ;110  ; OSIntNesting
00001e  b118              CBZ      r0,|L21.40|
000020  2002              MOVS     r0,#2                 ;111
000022  7028              STRB     r0,[r5,#0]            ;111
000024  2000              MOVS     r0,#0                 ;112
000026  e7f6              B        |L21.22|
                  |L21.40|
000028  f7fffffe          BL       OS_CPU_SR_Save
00002c  4607              MOV      r7,r0                 ;114
00002e  8920              LDRH     r0,[r4,#8]            ;115
000030  1206              ASRS     r6,r0,#8              ;115
000032  7a20              LDRB     r0,[r4,#8]            ;116
000034  28ff              CMP      r0,#0xff              ;116
000036  d120              BNE      |L21.122|
000038  8920              LDRH     r0,[r4,#8]            ;117
00003a  f400407f          AND      r0,r0,#0xff00         ;117
00003e  8120              STRH     r0,[r4,#8]            ;117
000040  8920              LDRH     r0,[r4,#8]            ;118
000042  4912              LDR      r1,|L21.140|
000044  6809              LDR      r1,[r1,#0]            ;118  ; OSTCBCur
000046  f8911032          LDRB     r1,[r1,#0x32]         ;118
00004a  4308              ORRS     r0,r0,r1              ;118
00004c  8120              STRH     r0,[r4,#8]            ;118
00004e  480f              LDR      r0,|L21.140|
000050  6800              LDR      r0,[r0,#0]            ;119  ; OSTCBCur
000052  6060              STR      r0,[r4,#4]            ;119
000054  480d              LDR      r0,|L21.140|
000056  6800              LDR      r0,[r0,#0]            ;120  ; OSTCBCur
000058  f8900032          LDRB     r0,[r0,#0x32]         ;120
00005c  42b0              CMP      r0,r6                 ;120
00005e  dc05              BGT      |L21.108|
000060  4638              MOV      r0,r7                 ;121
000062  f7fffffe          BL       OS_CPU_SR_Restore
000066  2078              MOVS     r0,#0x78              ;122
000068  7028              STRB     r0,[r5,#0]            ;122
00006a  e004              B        |L21.118|
                  |L21.108|
00006c  4638              MOV      r0,r7                 ;124
00006e  f7fffffe          BL       OS_CPU_SR_Restore
000072  2000              MOVS     r0,#0                 ;125
000074  7028              STRB     r0,[r5,#0]            ;125
                  |L21.118|
000076  2001              MOVS     r0,#1                 ;127
000078  e7cd              B        |L21.22|
                  |L21.122|
00007a  4638              MOV      r0,r7                 ;129
00007c  f7fffffe          BL       OS_CPU_SR_Restore
000080  2000              MOVS     r0,#0                 ;130
000082  7028              STRB     r0,[r5,#0]            ;130
000084  bf00              NOP                            ;131
000086  e7c6              B        |L21.22|
;;;133    #endif
                          ENDP

                  |L21.136|
                          DCD      OSIntNesting
                  |L21.140|
                          DCD      OSTCBCur

                          AREA ||i.OSMutexCreate||, CODE, READONLY, ALIGN=2

                  OSMutexCreate PROC
;;;169    
;;;170    OS_EVENT  *OSMutexCreate (INT8U   prio,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;171                              INT8U  *perr)
;;;172    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;173        OS_EVENT  *pevent;
;;;174    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;175        OS_CPU_SR  cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;176    #endif
;;;177    
;;;178    
;;;179    
;;;180    #ifdef OS_SAFETY_CRITICAL
;;;181        if (perr == (INT8U *)0) {
;;;182            OS_SAFETY_CRITICAL_EXCEPTION();
;;;183        }
;;;184    #endif
;;;185    
;;;186    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;187        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;188            OS_SAFETY_CRITICAL_EXCEPTION();
;;;189        }
;;;190    #endif
;;;191    
;;;192    #if OS_ARG_CHK_EN > 0u
;;;193        if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
;;;194            *perr = OS_ERR_PRIO_INVALID;
;;;195            return ((OS_EVENT *)0);
;;;196        }
;;;197    #endif
;;;198        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00000a  481f              LDR      r0,|L22.136|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000e  b120              CBZ      r0,|L22.26|
;;;199            *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
000010  2010              MOVS     r0,#0x10
000012  7030              STRB     r0,[r6,#0]
;;;200            return ((OS_EVENT *)0);
000014  2000              MOVS     r0,#0
                  |L22.22|
;;;201        }
;;;202        OS_ENTER_CRITICAL();
;;;203        if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
;;;204            OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
;;;205            *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
;;;206            return ((OS_EVENT *)0);
;;;207        }
;;;208        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
;;;209        pevent             = OSEventFreeList;                  /* Get next free event control block        */
;;;210        if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
;;;211            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
;;;212            OS_EXIT_CRITICAL();
;;;213            *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
;;;214            return (pevent);
;;;215        }
;;;216        OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
;;;217        OS_EXIT_CRITICAL();
;;;218        pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
;;;219        pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.  */
;;;220        pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
;;;221    #if OS_EVENT_NAME_EN > 0u
;;;222        pevent->OSEventName    = (INT8U *)(void *)"?";
;;;223    #endif
;;;224        OS_EventWaitListInit(pevent);
;;;225        *perr                  = OS_ERR_NONE;
;;;226        return (pevent);
;;;227    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L22.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;202
000020  481a              LDR      r0,|L22.140|
000022  f8500025          LDR      r0,[r0,r5,LSL #2]     ;203
000026  b130              CBZ      r0,|L22.54|
000028  4638              MOV      r0,r7                 ;204
00002a  f7fffffe          BL       OS_CPU_SR_Restore
00002e  2028              MOVS     r0,#0x28              ;205
000030  7030              STRB     r0,[r6,#0]            ;205
000032  2000              MOVS     r0,#0                 ;206
000034  e7ef              B        |L22.22|
                  |L22.54|
000036  2001              MOVS     r0,#1                 ;208
000038  4914              LDR      r1,|L22.140|
00003a  f8410025          STR      r0,[r1,r5,LSL #2]     ;208
00003e  4814              LDR      r0,|L22.144|
000040  6804              LDR      r4,[r0,#0]            ;209  ; OSEventFreeList
000042  b94c              CBNZ     r4,|L22.88|
000044  2000              MOVS     r0,#0                 ;211
000046  f8410025          STR      r0,[r1,r5,LSL #2]     ;211
00004a  4638              MOV      r0,r7                 ;212
00004c  f7fffffe          BL       OS_CPU_SR_Restore
000050  2004              MOVS     r0,#4                 ;213
000052  7030              STRB     r0,[r6,#0]            ;213
000054  4620              MOV      r0,r4                 ;214
000056  e7de              B        |L22.22|
                  |L22.88|
000058  480d              LDR      r0,|L22.144|
00005a  6800              LDR      r0,[r0,#0]            ;216  ; OSEventFreeList
00005c  6840              LDR      r0,[r0,#4]            ;216
00005e  490c              LDR      r1,|L22.144|
000060  6008              STR      r0,[r1,#0]            ;216  ; OSEventFreeList
000062  4638              MOV      r0,r7                 ;217
000064  f7fffffe          BL       OS_CPU_SR_Restore
000068  2004              MOVS     r0,#4                 ;218
00006a  7020              STRB     r0,[r4,#0]            ;218
00006c  20ff              MOVS     r0,#0xff              ;219
00006e  ea402005          ORR      r0,r0,r5,LSL #8       ;219
000072  8120              STRH     r0,[r4,#8]            ;219
000074  2000              MOVS     r0,#0                 ;220
000076  6060              STR      r0,[r4,#4]            ;220
000078  4620              MOV      r0,r4                 ;224
00007a  f7fffffe          BL       OS_EventWaitListInit
00007e  2000              MOVS     r0,#0                 ;225
000080  7030              STRB     r0,[r6,#0]            ;225
000082  4620              MOV      r0,r4                 ;226
000084  e7c7              B        |L22.22|
;;;228    
                          ENDP

000086  0000              DCW      0x0000
                  |L22.136|
                          DCD      OSIntNesting
                  |L22.140|
                          DCD      OSTCBPrioTbl
                  |L22.144|
                          DCD      OSEventFreeList

                          AREA ||i.OSMutexDel||, CODE, READONLY, ALIGN=2

                  OSMutexDel PROC
;;;270    #if OS_MUTEX_DEL_EN > 0u
;;;271    OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;272                           INT8U      opt,
;;;273                           INT8U     *perr)
;;;274    {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4615              MOV      r5,r2
;;;275        BOOLEAN    tasks_waiting;
;;;276        OS_EVENT  *pevent_return;
;;;277        INT8U      pip;                                        /* Priority inheritance priority            */
;;;278        INT8U      prio;
;;;279        OS_TCB    *ptcb;
;;;280    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;281        OS_CPU_SR  cpu_sr = 0u;
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;282    #endif
;;;283    
;;;284    
;;;285    
;;;286    #ifdef OS_SAFETY_CRITICAL
;;;287        if (perr == (INT8U *)0) {
;;;288            OS_SAFETY_CRITICAL_EXCEPTION();
;;;289        }
;;;290    #endif
;;;291    
;;;292    #if OS_ARG_CHK_EN > 0u
;;;293        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;294            *perr = OS_ERR_PEVENT_NULL;
;;;295            return (pevent);
;;;296        }
;;;297    #endif
;;;298        if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
00000e  7820              LDRB     r0,[r4,#0]
000010  2804              CMP      r0,#4
000012  d004              BEQ      |L23.30|
;;;299            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;300            return (pevent);
000018  4620              MOV      r0,r4
                  |L23.26|
;;;301        }
;;;302        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
;;;303            *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
;;;304            return (pevent);
;;;305        }
;;;306        OS_ENTER_CRITICAL();
;;;307        if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
;;;308            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;309        } else {
;;;310            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;311        }
;;;312        switch (opt) {
;;;313            case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
;;;314                 if (tasks_waiting == OS_FALSE) {
;;;315    #if OS_EVENT_NAME_EN > 0u
;;;316                     pevent->OSEventName = (INT8U *)(void *)"?";
;;;317    #endif
;;;318                     pip                 = (INT8U)(pevent->OSEventCnt >> 8u);
;;;319                     OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
;;;320                     pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
;;;321                     pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
;;;322                     pevent->OSEventCnt  = 0u;
;;;323                     OSEventFreeList     = pevent;
;;;324                     OS_EXIT_CRITICAL();
;;;325                     *perr               = OS_ERR_NONE;
;;;326                     pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
;;;327                 } else {
;;;328                     OS_EXIT_CRITICAL();
;;;329                     *perr               = OS_ERR_TASK_WAITING;
;;;330                     pevent_return       = pevent;
;;;331                 }
;;;332                 break;
;;;333    
;;;334            case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
;;;335                 pip  = (INT8U)(pevent->OSEventCnt >> 8u);                    /* Get PIP of mutex          */
;;;336                 prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
;;;337                 ptcb = (OS_TCB *)pevent->OSEventPtr;
;;;338                 if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
;;;339                     if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
;;;340                         OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
;;;341                     }
;;;342                 }
;;;343                 while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
;;;344                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
;;;345                 }
;;;346    #if OS_EVENT_NAME_EN > 0u
;;;347                 pevent->OSEventName = (INT8U *)(void *)"?";
;;;348    #endif
;;;349                 pip                 = (INT8U)(pevent->OSEventCnt >> 8u);
;;;350                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
;;;351                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
;;;352                 pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
;;;353                 pevent->OSEventCnt  = 0u;
;;;354                 OSEventFreeList     = pevent;                 /* Get next free event control block        */
;;;355                 OS_EXIT_CRITICAL();
;;;356                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;357                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;358                 }
;;;359                 *perr         = OS_ERR_NONE;
;;;360                 pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
;;;361                 break;
;;;362    
;;;363            default:
;;;364                 OS_EXIT_CRITICAL();
;;;365                 *perr         = OS_ERR_INVALID_OPT;
;;;366                 pevent_return = pevent;
;;;367                 break;
;;;368        }
;;;369        return (pevent_return);
;;;370    }
00001a  e8bd8ff8          POP      {r3-r11,pc}
                  |L23.30|
00001e  483b              LDR      r0,|L23.268|
000020  7800              LDRB     r0,[r0,#0]            ;302  ; OSIntNesting
000022  b118              CBZ      r0,|L23.44|
000024  200f              MOVS     r0,#0xf               ;303
000026  7028              STRB     r0,[r5,#0]            ;303
000028  4620              MOV      r0,r4                 ;304
00002a  e7f6              B        |L23.26|
                  |L23.44|
00002c  f7fffffe          BL       OS_CPU_SR_Save
000030  9000              STR      r0,[sp,#0]            ;306
000032  7aa0              LDRB     r0,[r4,#0xa]          ;307
000034  b110              CBZ      r0,|L23.60|
000036  f04f0801          MOV      r8,#1                 ;308
00003a  e001              B        |L23.64|
                  |L23.60|
00003c  f04f0800          MOV      r8,#0                 ;310
                  |L23.64|
000040  f1ba0f00          CMP      r10,#0                ;312
000044  d003              BEQ      |L23.78|
000046  f1ba0f01          CMP      r10,#1                ;312
00004a  d154              BNE      |L23.246|
00004c  e01e              B        |L23.140|
                  |L23.78|
00004e  f1b80f00          CMP      r8,#0                 ;314
000052  d114              BNE      |L23.126|
000054  8920              LDRH     r0,[r4,#8]            ;318
000056  1207              ASRS     r7,r0,#8              ;318
000058  2000              MOVS     r0,#0                 ;319
00005a  492d              LDR      r1,|L23.272|
00005c  f8410027          STR      r0,[r1,r7,LSL #2]     ;319
000060  7020              STRB     r0,[r4,#0]            ;320
000062  482c              LDR      r0,|L23.276|
000064  6800              LDR      r0,[r0,#0]            ;321  ; OSEventFreeList
000066  6060              STR      r0,[r4,#4]            ;321
000068  2000              MOVS     r0,#0                 ;322
00006a  8120              STRH     r0,[r4,#8]            ;322
00006c  4829              LDR      r0,|L23.276|
00006e  6004              STR      r4,[r0,#0]            ;323  ; OSEventFreeList
000070  9800              LDR      r0,[sp,#0]            ;324
000072  f7fffffe          BL       OS_CPU_SR_Restore
000076  2000              MOVS     r0,#0                 ;325
000078  7028              STRB     r0,[r5,#0]            ;325
00007a  2600              MOVS     r6,#0                 ;326
00007c  e005              B        |L23.138|
                  |L23.126|
00007e  9800              LDR      r0,[sp,#0]            ;328
000080  f7fffffe          BL       OS_CPU_SR_Restore
000084  2049              MOVS     r0,#0x49              ;329
000086  7028              STRB     r0,[r5,#0]            ;329
000088  4626              MOV      r6,r4                 ;330
                  |L23.138|
00008a  e03b              B        |L23.260|
                  |L23.140|
00008c  8920              LDRH     r0,[r4,#8]            ;335
00008e  1207              ASRS     r7,r0,#8              ;335
000090  f894b008          LDRB     r11,[r4,#8]           ;336
000094  f8d49004          LDR      r9,[r4,#4]            ;337
000098  f1b90f00          CMP      r9,#0                 ;338
00009c  d007              BEQ      |L23.174|
00009e  f8990032          LDRB     r0,[r9,#0x32]         ;339
0000a2  42b8              CMP      r0,r7                 ;339
0000a4  d103              BNE      |L23.174|
0000a6  4659              MOV      r1,r11                ;340
0000a8  4648              MOV      r0,r9                 ;340
0000aa  f7fffffe          BL       OSMutex_RdyAtPrio
                  |L23.174|
0000ae  e005              B        |L23.188|
                  |L23.176|
0000b0  2300              MOVS     r3,#0                 ;344
0000b2  2210              MOVS     r2,#0x10              ;344
0000b4  4619              MOV      r1,r3                 ;344
0000b6  4620              MOV      r0,r4                 ;344
0000b8  f7fffffe          BL       OS_EventTaskRdy
                  |L23.188|
0000bc  7aa0              LDRB     r0,[r4,#0xa]          ;343
0000be  2800              CMP      r0,#0                 ;343
0000c0  d1f6              BNE      |L23.176|
0000c2  8920              LDRH     r0,[r4,#8]            ;349
0000c4  1207              ASRS     r7,r0,#8              ;349
0000c6  2000              MOVS     r0,#0                 ;350
0000c8  4911              LDR      r1,|L23.272|
0000ca  f8410027          STR      r0,[r1,r7,LSL #2]     ;350
0000ce  7020              STRB     r0,[r4,#0]            ;351
0000d0  4810              LDR      r0,|L23.276|
0000d2  6800              LDR      r0,[r0,#0]            ;352  ; OSEventFreeList
0000d4  6060              STR      r0,[r4,#4]            ;352
0000d6  2000              MOVS     r0,#0                 ;353
0000d8  8120              STRH     r0,[r4,#8]            ;353
0000da  480e              LDR      r0,|L23.276|
0000dc  6004              STR      r4,[r0,#0]            ;354  ; OSEventFreeList
0000de  9800              LDR      r0,[sp,#0]            ;355
0000e0  f7fffffe          BL       OS_CPU_SR_Restore
0000e4  f1b80f01          CMP      r8,#1                 ;356
0000e8  d101              BNE      |L23.238|
0000ea  f7fffffe          BL       OS_Sched
                  |L23.238|
0000ee  2000              MOVS     r0,#0                 ;359
0000f0  7028              STRB     r0,[r5,#0]            ;359
0000f2  2600              MOVS     r6,#0                 ;360
0000f4  e006              B        |L23.260|
                  |L23.246|
0000f6  9800              LDR      r0,[sp,#0]            ;364
0000f8  f7fffffe          BL       OS_CPU_SR_Restore
0000fc  2007              MOVS     r0,#7                 ;365
0000fe  7028              STRB     r0,[r5,#0]            ;365
000100  4626              MOV      r6,r4                 ;366
000102  bf00              NOP                            ;367
                  |L23.260|
000104  bf00              NOP                            ;332
000106  4630              MOV      r0,r6                 ;369
000108  e787              B        |L23.26|
;;;371    #endif
                          ENDP

00010a  0000              DCW      0x0000
                  |L23.268|
                          DCD      OSIntNesting
                  |L23.272|
                          DCD      OSTCBPrioTbl
                  |L23.276|
                          DCD      OSEventFreeList

                          AREA ||i.OSMutexPend||, CODE, READONLY, ALIGN=2

                  OSMutexPend PROC
;;;413    
;;;414    void  OSMutexPend (OS_EVENT  *pevent,
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;415                       INT32U     timeout,
;;;416                       INT8U     *perr)
;;;417    {
000004  b082              SUB      sp,sp,#8
000006  4605              MOV      r5,r0
000008  4617              MOV      r7,r2
;;;418        INT8U      pip;                                        /* Priority Inheritance Priority (PIP)      */
;;;419        INT8U      mprio;                                      /* Mutex owner priority                     */
;;;420        BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
;;;421        OS_TCB    *ptcb;
;;;422        OS_EVENT  *pevent2;
;;;423        INT8U      y;
;;;424    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;425        OS_CPU_SR  cpu_sr = 0u;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;426    #endif
;;;427    
;;;428    
;;;429    
;;;430    #ifdef OS_SAFETY_CRITICAL
;;;431        if (perr == (INT8U *)0) {
;;;432            OS_SAFETY_CRITICAL_EXCEPTION();
;;;433        }
;;;434    #endif
;;;435    
;;;436    #if OS_ARG_CHK_EN > 0u
;;;437        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;438            *perr = OS_ERR_PEVENT_NULL;
;;;439            return;
;;;440        }
;;;441    #endif
;;;442        if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
00000e  7828              LDRB     r0,[r5,#0]
000010  2804              CMP      r0,#4
000012  d004              BEQ      |L24.30|
;;;443            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7038              STRB     r0,[r7,#0]
                  |L24.24|
;;;444            return;
;;;445        }
;;;446        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
;;;447            *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
;;;448            return;
;;;449        }
;;;450        if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
;;;451            *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
;;;452            return;
;;;453        }
;;;454    /*$PAGE*/
;;;455        OS_ENTER_CRITICAL();
;;;456        pip = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PIP from mutex                       */
;;;457                                                               /* Is Mutex available?                      */
;;;458        if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
;;;459            pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
;;;460            pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
;;;461            pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
;;;462            if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
;;;463                OS_EXIT_CRITICAL();                            /*      ... than current task!              */
;;;464                *perr = OS_ERR_PIP_LOWER;
;;;465            } else {
;;;466                OS_EXIT_CRITICAL();
;;;467                *perr = OS_ERR_NONE;
;;;468            }
;;;469            return;
;;;470        }
;;;471        mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
;;;472        ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
;;;473        if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
;;;474            if (mprio > OSTCBCur->OSTCBPrio) {
;;;475                y = ptcb->OSTCBY;
;;;476                if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {          /*     See if mutex owner is ready   */
;;;477                    OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;         /*     Yes, Remove owner from Rdy ...*/
;;;478                    if (OSRdyTbl[y] == 0u) {                          /*          ... list at current prio */
;;;479                        OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
;;;480                    }
;;;481                    rdy = OS_TRUE;
;;;482                } else {
;;;483                    pevent2 = ptcb->OSTCBEventPtr;
;;;484                    if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
;;;485                        y = ptcb->OSTCBY;
;;;486                        pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
;;;487                        if (pevent2->OSEventTbl[y] == 0u) {
;;;488                            pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
;;;489                        }
;;;490                    }
;;;491                    rdy = OS_FALSE;                            /* No                                       */
;;;492                }
;;;493                ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
;;;494    #if OS_LOWEST_PRIO <= 63u
;;;495                ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
;;;496                ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
;;;497    #else
;;;498                ptcb->OSTCBY    = (INT8U)((INT8U)(ptcb->OSTCBPrio >> 4u) & 0xFFu);
;;;499                ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
;;;500    #endif
;;;501                ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
;;;502                ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
;;;503    
;;;504                if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
;;;505                    OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
;;;506                    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;507                } else {
;;;508                    pevent2 = ptcb->OSTCBEventPtr;
;;;509                    if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
;;;510                        pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
;;;511                        pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;512                    }
;;;513                }
;;;514                OSTCBPrioTbl[pip] = ptcb;
;;;515            }
;;;516        }
;;;517        OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
;;;518        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;519        OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
;;;520        OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
;;;521        OS_EXIT_CRITICAL();
;;;522        OS_Sched();                                       /* Find next highest priority task ready         */
;;;523        OS_ENTER_CRITICAL();
;;;524        switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
;;;525            case OS_STAT_PEND_OK:
;;;526                 *perr = OS_ERR_NONE;
;;;527                 break;
;;;528    
;;;529            case OS_STAT_PEND_ABORT:
;;;530                 *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
;;;531                 break;
;;;532    
;;;533            case OS_STAT_PEND_TO:
;;;534            default:
;;;535                 OS_EventTaskRemove(OSTCBCur, pevent);
;;;536                 *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
;;;537                 break;
;;;538        }
;;;539        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
;;;540        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
;;;541        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
;;;542    #if (OS_EVENT_MULTI_EN > 0u)
;;;543        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;544    #endif
;;;545        OS_EXIT_CRITICAL();
;;;546    }
000018  b005              ADD      sp,sp,#0x14
00001a  e8bd8ff0          POP      {r4-r11,pc}
                  |L24.30|
00001e  4880              LDR      r0,|L24.544|
000020  7800              LDRB     r0,[r0,#0]            ;446  ; OSIntNesting
000022  b110              CBZ      r0,|L24.42|
000024  2002              MOVS     r0,#2                 ;447
000026  7038              STRB     r0,[r7,#0]            ;447
000028  e7f6              B        |L24.24|
                  |L24.42|
00002a  487e              LDR      r0,|L24.548|
00002c  7800              LDRB     r0,[r0,#0]            ;450  ; OSLockNesting
00002e  b110              CBZ      r0,|L24.54|
000030  200d              MOVS     r0,#0xd               ;451
000032  7038              STRB     r0,[r7,#0]            ;451
000034  e7f0              B        |L24.24|
                  |L24.54|
000036  f7fffffe          BL       OS_CPU_SR_Save
00003a  9001              STR      r0,[sp,#4]            ;455
00003c  8928              LDRH     r0,[r5,#8]            ;456
00003e  ea4f2920          ASR      r9,r0,#8              ;456
000042  7a28              LDRB     r0,[r5,#8]            ;458
000044  28ff              CMP      r0,#0xff              ;458
000046  d11f              BNE      |L24.136|
000048  8928              LDRH     r0,[r5,#8]            ;459
00004a  f400407f          AND      r0,r0,#0xff00         ;459
00004e  8128              STRH     r0,[r5,#8]            ;459
000050  8928              LDRH     r0,[r5,#8]            ;460
000052  4975              LDR      r1,|L24.552|
000054  6809              LDR      r1,[r1,#0]            ;460  ; OSTCBCur
000056  f8911032          LDRB     r1,[r1,#0x32]         ;460
00005a  4308              ORRS     r0,r0,r1              ;460
00005c  8128              STRH     r0,[r5,#8]            ;460
00005e  4872              LDR      r0,|L24.552|
000060  6800              LDR      r0,[r0,#0]            ;461  ; OSTCBCur
000062  6068              STR      r0,[r5,#4]            ;461
000064  4870              LDR      r0,|L24.552|
000066  6800              LDR      r0,[r0,#0]            ;462  ; OSTCBCur
000068  f8900032          LDRB     r0,[r0,#0x32]         ;462
00006c  4548              CMP      r0,r9                 ;462
00006e  dc05              BGT      |L24.124|
000070  9801              LDR      r0,[sp,#4]            ;463
000072  f7fffffe          BL       OS_CPU_SR_Restore
000076  2078              MOVS     r0,#0x78              ;464
000078  7038              STRB     r0,[r7,#0]            ;464
00007a  e004              B        |L24.134|
                  |L24.124|
00007c  9801              LDR      r0,[sp,#4]            ;466
00007e  f7fffffe          BL       OS_CPU_SR_Restore
000082  2000              MOVS     r0,#0                 ;467
000084  7038              STRB     r0,[r7,#0]            ;467
                  |L24.134|
000086  e7c7              B        |L24.24|
                  |L24.136|
000088  f895b008          LDRB     r11,[r5,#8]           ;471
00008c  686c              LDR      r4,[r5,#4]            ;472
00008e  f8940032          LDRB     r0,[r4,#0x32]         ;473
000092  4548              CMP      r0,r9                 ;473
000094  dd7a              BLE      |L24.396|
000096  4864              LDR      r0,|L24.552|
000098  6800              LDR      r0,[r0,#0]            ;474  ; OSTCBCur
00009a  f8900032          LDRB     r0,[r0,#0x32]         ;474
00009e  4558              CMP      r0,r11                ;474
0000a0  da74              BGE      |L24.396|
0000a2  f8948034          LDRB     r8,[r4,#0x34]         ;475
0000a6  4861              LDR      r0,|L24.556|
0000a8  f8100008          LDRB     r0,[r0,r8]            ;476
0000ac  f8941035          LDRB     r1,[r4,#0x35]         ;476
0000b0  4008              ANDS     r0,r0,r1              ;476
0000b2  b1b0              CBZ      r0,|L24.226|
0000b4  485d              LDR      r0,|L24.556|
0000b6  f8100008          LDRB     r0,[r0,r8]            ;477
0000ba  f8941035          LDRB     r1,[r4,#0x35]         ;477
0000be  4388              BICS     r0,r0,r1              ;477
0000c0  495a              LDR      r1,|L24.556|
0000c2  f8010008          STRB     r0,[r1,r8]            ;477
0000c6  4608              MOV      r0,r1                 ;478
0000c8  f8100008          LDRB     r0,[r0,r8]            ;478
0000cc  b930              CBNZ     r0,|L24.220|
0000ce  f8941036          LDRB     r1,[r4,#0x36]         ;479
0000d2  4857              LDR      r0,|L24.560|
0000d4  7800              LDRB     r0,[r0,#0]            ;479  ; OSRdyGrp
0000d6  4388              BICS     r0,r0,r1              ;479
0000d8  4955              LDR      r1,|L24.560|
0000da  7008              STRB     r0,[r1,#0]            ;479
                  |L24.220|
0000dc  f04f0a01          MOV      r10,#1                ;481
0000e0  e019              B        |L24.278|
                  |L24.226|
0000e2  69e6              LDR      r6,[r4,#0x1c]         ;483
0000e4  b1ae              CBZ      r6,|L24.274|
0000e6  f8948034          LDRB     r8,[r4,#0x34]         ;485
0000ea  f106000b          ADD      r0,r6,#0xb            ;486
0000ee  f8100008          LDRB     r0,[r0,r8]            ;486
0000f2  f8941035          LDRB     r1,[r4,#0x35]         ;486
0000f6  4388              BICS     r0,r0,r1              ;486
0000f8  f106010b          ADD      r1,r6,#0xb            ;486
0000fc  f8010008          STRB     r0,[r1,r8]            ;486
000100  4608              MOV      r0,r1                 ;487
000102  f8100008          LDRB     r0,[r0,r8]            ;487
000106  b920              CBNZ     r0,|L24.274|
000108  7ab0              LDRB     r0,[r6,#0xa]          ;488
00010a  f8941036          LDRB     r1,[r4,#0x36]         ;488
00010e  4388              BICS     r0,r0,r1              ;488
000110  72b0              STRB     r0,[r6,#0xa]          ;488
                  |L24.274|
000112  f04f0a00          MOV      r10,#0                ;491
                  |L24.278|
000116  f8049f32          STRB     r9,[r4,#0x32]!        ;493
00011a  7820              LDRB     r0,[r4,#0]            ;495
00011c  10c0              ASRS     r0,r0,#3              ;495
00011e  70a0              STRB     r0,[r4,#2]            ;495
000120  7820              LDRB     r0,[r4,#0]            ;496
000122  f0000007          AND      r0,r0,#7              ;496
000126  7060              STRB     r0,[r4,#1]            ;496
000128  78a1              LDRB     r1,[r4,#2]            ;501
00012a  2001              MOVS     r0,#1                 ;501
00012c  4088              LSLS     r0,r0,r1              ;501
00012e  7120              STRB     r0,[r4,#4]            ;501
000130  7861              LDRB     r1,[r4,#1]            ;502
000132  2001              MOVS     r0,#1                 ;502
000134  4088              LSLS     r0,r0,r1              ;502
000136  70e0              STRB     r0,[r4,#3]            ;502
000138  3c32              SUBS     r4,r4,#0x32           ;502
00013a  f1ba0f01          CMP      r10,#1                ;504
00013e  d110              BNE      |L24.354|
000140  3434              ADDS     r4,r4,#0x34           ;505
000142  78a0              LDRB     r0,[r4,#2]            ;505
000144  493a              LDR      r1,|L24.560|
000146  7809              LDRB     r1,[r1,#0]            ;505  ; OSRdyGrp
000148  4308              ORRS     r0,r0,r1              ;505
00014a  4939              LDR      r1,|L24.560|
00014c  7008              STRB     r0,[r1,#0]            ;505
00014e  7820              LDRB     r0,[r4,#0]            ;506
000150  4936              LDR      r1,|L24.556|
000152  5c08              LDRB     r0,[r1,r0]            ;506
000154  7861              LDRB     r1,[r4,#1]            ;506
000156  4308              ORRS     r0,r0,r1              ;506
000158  f8141934          LDRB     r1,[r4],#-0x34        ;506
00015c  4a33              LDR      r2,|L24.556|
00015e  5450              STRB     r0,[r2,r1]            ;506
000160  e011              B        |L24.390|
                  |L24.354|
000162  69e6              LDR      r6,[r4,#0x1c]         ;508
000164  b17e              CBZ      r6,|L24.390|
000166  7ab0              LDRB     r0,[r6,#0xa]          ;510
000168  3434              ADDS     r4,r4,#0x34           ;510
00016a  78a1              LDRB     r1,[r4,#2]            ;510
00016c  4308              ORRS     r0,r0,r1              ;510
00016e  72b0              STRB     r0,[r6,#0xa]          ;510
000170  7821              LDRB     r1,[r4,#0]            ;511
000172  f106000b          ADD      r0,r6,#0xb            ;511
000176  5c40              LDRB     r0,[r0,r1]            ;511
000178  7861              LDRB     r1,[r4,#1]            ;511
00017a  4308              ORRS     r0,r0,r1              ;511
00017c  f8142934          LDRB     r2,[r4],#-0x34        ;511
000180  f106010b          ADD      r1,r6,#0xb            ;511
000184  5488              STRB     r0,[r1,r2]            ;511
                  |L24.390|
000186  482b              LDR      r0,|L24.564|
000188  f8404029          STR      r4,[r0,r9,LSL #2]     ;514
                  |L24.396|
00018c  4826              LDR      r0,|L24.552|
00018e  6800              LDR      r0,[r0,#0]            ;517  ; OSTCBCur
000190  f8900030          LDRB     r0,[r0,#0x30]         ;517
000194  f0400010          ORR      r0,r0,#0x10           ;517
000198  4923              LDR      r1,|L24.552|
00019a  6809              LDR      r1,[r1,#0]            ;517  ; OSTCBCur
00019c  f8810030          STRB     r0,[r1,#0x30]         ;517
0001a0  2000              MOVS     r0,#0                 ;518
0001a2  4921              LDR      r1,|L24.552|
0001a4  6809              LDR      r1,[r1,#0]            ;518  ; OSTCBCur
0001a6  f8810031          STRB     r0,[r1,#0x31]         ;518
0001aa  491f              LDR      r1,|L24.552|
0001ac  9803              LDR      r0,[sp,#0xc]          ;519
0001ae  6809              LDR      r1,[r1,#0]            ;519  ; OSTCBCur
0001b0  62c8              STR      r0,[r1,#0x2c]         ;519
0001b2  4628              MOV      r0,r5                 ;520
0001b4  f7fffffe          BL       OS_EventTaskWait
0001b8  9801              LDR      r0,[sp,#4]            ;521
0001ba  f7fffffe          BL       OS_CPU_SR_Restore
0001be  f7fffffe          BL       OS_Sched
0001c2  f7fffffe          BL       OS_CPU_SR_Save
0001c6  9001              STR      r0,[sp,#4]            ;523
0001c8  4817              LDR      r0,|L24.552|
0001ca  6800              LDR      r0,[r0,#0]            ;524  ; OSTCBCur
0001cc  f8900031          LDRB     r0,[r0,#0x31]         ;524
0001d0  b120              CBZ      r0,|L24.476|
0001d2  2801              CMP      r0,#1                 ;524
0001d4  d009              BEQ      |L24.490|
0001d6  2802              CMP      r0,#2                 ;524
0001d8  d106              BNE      |L24.488|
0001da  e002              B        |L24.482|
                  |L24.476|
0001dc  2000              MOVS     r0,#0                 ;526
0001de  7038              STRB     r0,[r7,#0]            ;526
0001e0  e00b              B        |L24.506|
                  |L24.482|
0001e2  200e              MOVS     r0,#0xe               ;530
0001e4  7038              STRB     r0,[r7,#0]            ;530
0001e6  e008              B        |L24.506|
                  |L24.488|
0001e8  bf00              NOP                            ;533
                  |L24.490|
0001ea  4629              MOV      r1,r5                 ;535
0001ec  480e              LDR      r0,|L24.552|
0001ee  6800              LDR      r0,[r0,#0]            ;535  ; OSTCBCur
0001f0  f7fffffe          BL       OS_EventTaskRemove
0001f4  200a              MOVS     r0,#0xa               ;536
0001f6  7038              STRB     r0,[r7,#0]            ;536
0001f8  bf00              NOP                            ;537
                  |L24.506|
0001fa  bf00              NOP                            ;527
0001fc  2000              MOVS     r0,#0                 ;539
0001fe  490a              LDR      r1,|L24.552|
000200  6809              LDR      r1,[r1,#0]            ;539  ; OSTCBCur
000202  f8810030          STRB     r0,[r1,#0x30]         ;539
000206  4908              LDR      r1,|L24.552|
000208  6809              LDR      r1,[r1,#0]            ;540  ; OSTCBCur
00020a  f8810031          STRB     r0,[r1,#0x31]         ;540
00020e  4906              LDR      r1,|L24.552|
000210  6809              LDR      r1,[r1,#0]            ;541  ; OSTCBCur
000212  61c8              STR      r0,[r1,#0x1c]         ;541
000214  9801              LDR      r0,[sp,#4]            ;545
000216  f7fffffe          BL       OS_CPU_SR_Restore
00021a  bf00              NOP      
00021c  e6fc              B        |L24.24|
;;;547    /*$PAGE*/
                          ENDP

00021e  0000              DCW      0x0000
                  |L24.544|
                          DCD      OSIntNesting
                  |L24.548|
                          DCD      OSLockNesting
                  |L24.552|
                          DCD      OSTCBCur
                  |L24.556|
                          DCD      OSRdyTbl
                  |L24.560|
                          DCD      OSRdyGrp
                  |L24.564|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSMutexPost||, CODE, READONLY, ALIGN=2

                  OSMutexPost PROC
;;;571    
;;;572    INT8U  OSMutexPost (OS_EVENT *pevent)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;573    {
000004  4604              MOV      r4,r0
;;;574        INT8U      pip;                                   /* Priority inheritance priority                 */
;;;575        INT8U      prio;
;;;576    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;577        OS_CPU_SR  cpu_sr = 0u;
000006  2700              MOVS     r7,#0
;;;578    #endif
;;;579    
;;;580    
;;;581    
;;;582        if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
000008  482c              LDR      r0,|L25.188|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000c  b110              CBZ      r0,|L25.20|
;;;583            return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
00000e  2005              MOVS     r0,#5
                  |L25.16|
;;;584        }
;;;585    #if OS_ARG_CHK_EN > 0u
;;;586        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;587            return (OS_ERR_PEVENT_NULL);
;;;588        }
;;;589    #endif
;;;590        if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
;;;591            return (OS_ERR_EVENT_TYPE);
;;;592        }
;;;593        OS_ENTER_CRITICAL();
;;;594        pip  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority inheritance priority of mutex    */
;;;595        prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
;;;596        if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
;;;597            OS_EXIT_CRITICAL();
;;;598            return (OS_ERR_NOT_MUTEX_OWNER);
;;;599        }
;;;600        if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
;;;601            OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
;;;602        }
;;;603        OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
;;;604        if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
;;;605                                                          /* Yes, Make HPT waiting for mutex ready         */
;;;606            prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
;;;607            pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
;;;608            pevent->OSEventCnt |= prio;
;;;609            pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
;;;610            if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
;;;611                OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
;;;612                OS_Sched();                               /*      Find highest priority task ready to run  */
;;;613                return (OS_ERR_PIP_LOWER);
;;;614            } else {
;;;615                OS_EXIT_CRITICAL();
;;;616                OS_Sched();                               /*      Find highest priority task ready to run  */
;;;617                return (OS_ERR_NONE);
;;;618            }
;;;619        }
;;;620        pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
;;;621        pevent->OSEventPtr  = (void *)0;
;;;622        OS_EXIT_CRITICAL();
;;;623        return (OS_ERR_NONE);
;;;624    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L25.20|
000014  7820              LDRB     r0,[r4,#0]            ;590
000016  2804              CMP      r0,#4                 ;590
000018  d001              BEQ      |L25.30|
00001a  2001              MOVS     r0,#1                 ;591
00001c  e7f8              B        |L25.16|
                  |L25.30|
00001e  f7fffffe          BL       OS_CPU_SR_Save
000022  4607              MOV      r7,r0                 ;593
000024  8920              LDRH     r0,[r4,#8]            ;594
000026  1206              ASRS     r6,r0,#8              ;594
000028  7a25              LDRB     r5,[r4,#8]            ;595
00002a  4925              LDR      r1,|L25.192|
00002c  6860              LDR      r0,[r4,#4]            ;596
00002e  6809              LDR      r1,[r1,#0]            ;596  ; OSTCBCur
000030  4288              CMP      r0,r1                 ;596
000032  d004              BEQ      |L25.62|
000034  4638              MOV      r0,r7                 ;597
000036  f7fffffe          BL       OS_CPU_SR_Restore
00003a  2064              MOVS     r0,#0x64              ;598
00003c  e7e8              B        |L25.16|
                  |L25.62|
00003e  4820              LDR      r0,|L25.192|
000040  6800              LDR      r0,[r0,#0]            ;600  ; OSTCBCur
000042  f8900032          LDRB     r0,[r0,#0x32]         ;600
000046  42b0              CMP      r0,r6                 ;600
000048  d104              BNE      |L25.84|
00004a  4629              MOV      r1,r5                 ;601
00004c  481c              LDR      r0,|L25.192|
00004e  6800              LDR      r0,[r0,#0]            ;601  ; OSTCBCur
000050  f7fffffe          BL       OSMutex_RdyAtPrio
                  |L25.84|
000054  2001              MOVS     r0,#1                 ;603
000056  491b              LDR      r1,|L25.196|
000058  f8410026          STR      r0,[r1,r6,LSL #2]     ;603
00005c  7aa0              LDRB     r0,[r4,#0xa]          ;604
00005e  b308              CBZ      r0,|L25.164|
000060  2300              MOVS     r3,#0                 ;606
000062  2210              MOVS     r2,#0x10              ;606
000064  4619              MOV      r1,r3                 ;606
000066  4620              MOV      r0,r4                 ;606
000068  f7fffffe          BL       OS_EventTaskRdy
00006c  4605              MOV      r5,r0                 ;606
00006e  8920              LDRH     r0,[r4,#8]            ;607
000070  f400407f          AND      r0,r0,#0xff00         ;607
000074  8120              STRH     r0,[r4,#8]            ;607
000076  8920              LDRH     r0,[r4,#8]            ;608
000078  4328              ORRS     r0,r0,r5              ;608
00007a  8120              STRH     r0,[r4,#8]            ;608
00007c  4811              LDR      r0,|L25.196|
00007e  f8500025          LDR      r0,[r0,r5,LSL #2]     ;609
000082  6060              STR      r0,[r4,#4]            ;609
000084  42b5              CMP      r5,r6                 ;610
000086  dc06              BGT      |L25.150|
000088  4638              MOV      r0,r7                 ;611
00008a  f7fffffe          BL       OS_CPU_SR_Restore
00008e  f7fffffe          BL       OS_Sched
000092  2078              MOVS     r0,#0x78              ;613
000094  e7bc              B        |L25.16|
                  |L25.150|
000096  4638              MOV      r0,r7                 ;615
000098  f7fffffe          BL       OS_CPU_SR_Restore
00009c  f7fffffe          BL       OS_Sched
0000a0  2000              MOVS     r0,#0                 ;617
0000a2  e7b5              B        |L25.16|
                  |L25.164|
0000a4  8920              LDRH     r0,[r4,#8]            ;620
0000a6  f04000ff          ORR      r0,r0,#0xff           ;620
0000aa  8120              STRH     r0,[r4,#8]            ;620
0000ac  2000              MOVS     r0,#0                 ;621
0000ae  6060              STR      r0,[r4,#4]            ;621
0000b0  4638              MOV      r0,r7                 ;622
0000b2  f7fffffe          BL       OS_CPU_SR_Restore
0000b6  2000              MOVS     r0,#0                 ;623
0000b8  e7aa              B        |L25.16|
;;;625    /*$PAGE*/
                          ENDP

0000ba  0000              DCW      0x0000
                  |L25.188|
                          DCD      OSIntNesting
                  |L25.192|
                          DCD      OSTCBCur
                  |L25.196|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSMutexQuery||, CODE, READONLY, ALIGN=2

                  OSMutexQuery PROC
;;;644    #if OS_MUTEX_QUERY_EN > 0u
;;;645    INT8U  OSMutexQuery (OS_EVENT       *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;646                         OS_MUTEX_DATA  *p_mutex_data)
;;;647    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;648        INT8U       i;
;;;649        OS_PRIO    *psrc;
;;;650        OS_PRIO    *pdest;
;;;651    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;652        OS_CPU_SR   cpu_sr = 0u;
000008  f04f0900          MOV      r9,#0
;;;653    #endif
;;;654    
;;;655    
;;;656    
;;;657        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00000c  4817              LDR      r0,|L26.108|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b110              CBZ      r0,|L26.24|
;;;658            return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
000012  2006              MOVS     r0,#6
                  |L26.20|
;;;659        }
;;;660    #if OS_ARG_CHK_EN > 0u
;;;661        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;662            return (OS_ERR_PEVENT_NULL);
;;;663        }
;;;664        if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
;;;665            return (OS_ERR_PDATA_NULL);
;;;666        }
;;;667    #endif
;;;668        if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
;;;669            return (OS_ERR_EVENT_TYPE);
;;;670        }
;;;671        OS_ENTER_CRITICAL();
;;;672        p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8u);
;;;673        p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
;;;674        if (p_mutex_data->OSOwnerPrio == 0xFFu) {
;;;675            p_mutex_data->OSValue = OS_TRUE;
;;;676        } else {
;;;677            p_mutex_data->OSValue = OS_FALSE;
;;;678        }
;;;679        p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
;;;680        psrc                      = &pevent->OSEventTbl[0];
;;;681        pdest                     = &p_mutex_data->OSEventTbl[0];
;;;682        for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
;;;683            *pdest++ = *psrc++;
;;;684        }
;;;685        OS_EXIT_CRITICAL();
;;;686        return (OS_ERR_NONE);
;;;687    }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L26.24|
000018  7828              LDRB     r0,[r5,#0]            ;668
00001a  2804              CMP      r0,#4                 ;668
00001c  d001              BEQ      |L26.34|
00001e  2001              MOVS     r0,#1                 ;669
000020  e7f8              B        |L26.20|
                  |L26.34|
000022  f7fffffe          BL       OS_CPU_SR_Save
000026  4681              MOV      r9,r0                 ;671
000028  8928              LDRH     r0,[r5,#8]            ;672
00002a  1200              ASRS     r0,r0,#8              ;672
00002c  72e0              STRB     r0,[r4,#0xb]          ;672
00002e  7a28              LDRB     r0,[r5,#8]            ;673
000030  72a0              STRB     r0,[r4,#0xa]          ;673
000032  7aa0              LDRB     r0,[r4,#0xa]          ;674
000034  28ff              CMP      r0,#0xff              ;674
000036  d102              BNE      |L26.62|
000038  2001              MOVS     r0,#1                 ;675
00003a  7260              STRB     r0,[r4,#9]            ;675
00003c  e001              B        |L26.66|
                  |L26.62|
00003e  2000              MOVS     r0,#0                 ;677
000040  7260              STRB     r0,[r4,#9]            ;677
                  |L26.66|
000042  7aa8              LDRB     r0,[r5,#0xa]          ;679
000044  7220              STRB     r0,[r4,#8]            ;679
000046  f105080b          ADD      r8,r5,#0xb            ;680
00004a  4626              MOV      r6,r4                 ;681
00004c  2700              MOVS     r7,#0                 ;682
00004e  e005              B        |L26.92|
                  |L26.80|
000050  f8180b01          LDRB     r0,[r8],#1            ;683
000054  f8060b01          STRB     r0,[r6],#1            ;683
000058  1c78              ADDS     r0,r7,#1              ;682
00005a  b2c7              UXTB     r7,r0                 ;682
                  |L26.92|
00005c  2f08              CMP      r7,#8                 ;682
00005e  d3f7              BCC      |L26.80|
000060  4648              MOV      r0,r9                 ;685
000062  f7fffffe          BL       OS_CPU_SR_Restore
000066  2000              MOVS     r0,#0                 ;686
000068  e7d4              B        |L26.20|
;;;688    #endif                                                     /* OS_MUTEX_QUERY_EN                        */
                          ENDP

00006a  0000              DCW      0x0000
                  |L26.108|
                          DCD      OSIntNesting

                          AREA ||i.OSMutex_RdyAtPrio||, CODE, READONLY, ALIGN=2

                  OSMutex_RdyAtPrio PROC
;;;704    
;;;705    static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
000000  b530              PUSH     {r4,r5,lr}
;;;706                                     INT8U    prio)
;;;707    {
;;;708        INT8U  y;
;;;709    
;;;710    
;;;711        y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
000002  f8902034          LDRB     r2,[r0,#0x34]
;;;712        OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
000006  4b1b              LDR      r3,|L27.116|
000008  5c9b              LDRB     r3,[r3,r2]
00000a  f8904035          LDRB     r4,[r0,#0x35]
00000e  43a3              BICS     r3,r3,r4
000010  4c18              LDR      r4,|L27.116|
000012  54a3              STRB     r3,[r4,r2]
;;;713        if (OSRdyTbl[y] == 0u) {
000014  4623              MOV      r3,r4
000016  5c9b              LDRB     r3,[r3,r2]
000018  b933              CBNZ     r3,|L27.40|
;;;714            OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00001a  f8904036          LDRB     r4,[r0,#0x36]
00001e  4b16              LDR      r3,|L27.120|
000020  781b              LDRB     r3,[r3,#0]  ; OSRdyGrp
000022  43a3              BICS     r3,r3,r4
000024  4c14              LDR      r4,|L27.120|
000026  7023              STRB     r3,[r4,#0]
                  |L27.40|
;;;715        }
;;;716        ptcb->OSTCBPrio         = prio;
000028  f8001f32          STRB     r1,[r0,#0x32]!
;;;717        OSPrioCur               = prio;                        /* The current task is now at this priority */
00002c  4b13              LDR      r3,|L27.124|
00002e  7019              STRB     r1,[r3,#0]
;;;718    #if OS_LOWEST_PRIO <= 63u
;;;719        ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
000030  f3c103c2          UBFX     r3,r1,#3,#3
000034  7083              STRB     r3,[r0,#2]
;;;720        ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
000036  f0010307          AND      r3,r1,#7
00003a  7043              STRB     r3,[r0,#1]
;;;721    #else
;;;722        ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 4u) & 0x0Fu);
;;;723        ptcb->OSTCBX            = (INT8U) (prio & 0x0Fu);
;;;724    #endif
;;;725        ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
00003c  7884              LDRB     r4,[r0,#2]
00003e  2301              MOVS     r3,#1
000040  40a3              LSLS     r3,r3,r4
000042  7103              STRB     r3,[r0,#4]
;;;726        ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
000044  7844              LDRB     r4,[r0,#1]
000046  2301              MOVS     r3,#1
000048  40a3              LSLS     r3,r3,r4
00004a  70c3              STRB     r3,[r0,#3]
;;;727        OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
00004c  7903              LDRB     r3,[r0,#4]
00004e  4c0a              LDR      r4,|L27.120|
000050  7824              LDRB     r4,[r4,#0]  ; OSRdyGrp
000052  4323              ORRS     r3,r3,r4
000054  4c08              LDR      r4,|L27.120|
000056  7023              STRB     r3,[r4,#0]
;;;728        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000058  7883              LDRB     r3,[r0,#2]
00005a  4c06              LDR      r4,|L27.116|
00005c  5ce3              LDRB     r3,[r4,r3]
00005e  78c4              LDRB     r4,[r0,#3]
000060  4323              ORRS     r3,r3,r4
000062  7884              LDRB     r4,[r0,#2]
000064  3832              SUBS     r0,r0,#0x32
000066  4d03              LDR      r5,|L27.116|
000068  552b              STRB     r3,[r5,r4]
;;;729        OSTCBPrioTbl[prio]      = ptcb;
00006a  4b05              LDR      r3,|L27.128|
00006c  f8430021          STR      r0,[r3,r1,LSL #2]
;;;730    
;;;731    }
000070  bd30              POP      {r4,r5,pc}
;;;732    
                          ENDP

000072  0000              DCW      0x0000
                  |L27.116|
                          DCD      OSRdyTbl
                  |L27.120|
                          DCD      OSRdyGrp
                  |L27.124|
                          DCD      OSPrioCur
                  |L27.128|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSQAccept||, CODE, READONLY, ALIGN=1

                  OSQAccept PROC
;;;60     #if OS_Q_ACCEPT_EN > 0u
;;;61     void  *OSQAccept (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;62                       INT8U     *perr)
;;;63     {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;64         void      *pmsg;
;;;65         OS_Q      *pq;
;;;66     #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;67         OS_CPU_SR  cpu_sr = 0u;
000008  f04f0800          MOV      r8,#0
;;;68     #endif
;;;69     
;;;70     
;;;71     
;;;72     #ifdef OS_SAFETY_CRITICAL
;;;73         if (perr == (INT8U *)0) {
;;;74             OS_SAFETY_CRITICAL_EXCEPTION();
;;;75         }
;;;76     #endif
;;;77     
;;;78     #if OS_ARG_CHK_EN > 0u
;;;79         if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
;;;80             *perr = OS_ERR_PEVENT_NULL;
;;;81             return ((void *)0);
;;;82         }
;;;83     #endif
;;;84         if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
00000c  7830              LDRB     r0,[r6,#0]
00000e  2802              CMP      r0,#2
000010  d004              BEQ      |L28.28|
;;;85             *perr = OS_ERR_EVENT_TYPE;
000012  2001              MOVS     r0,#1
000014  7028              STRB     r0,[r5,#0]
;;;86             return ((void *)0);
000016  2000              MOVS     r0,#0
                  |L28.24|
;;;87         }
;;;88         OS_ENTER_CRITICAL();
;;;89         pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
;;;90         if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
;;;91             pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
;;;92             pq->OSQEntries--;                        /* Update the number of entries in the queue          */
;;;93             if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
;;;94                 pq->OSQOut = pq->OSQStart;
;;;95             }
;;;96             *perr = OS_ERR_NONE;
;;;97         } else {
;;;98             *perr = OS_ERR_Q_EMPTY;
;;;99             pmsg  = (void *)0;                       /* Queue is empty                                     */
;;;100        }
;;;101        OS_EXIT_CRITICAL();
;;;102        return (pmsg);                               /* Return message received (or NULL)                  */
;;;103    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L28.28|
00001c  f7fffffe          BL       OS_CPU_SR_Save
000020  4680              MOV      r8,r0                 ;88
000022  6874              LDR      r4,[r6,#4]            ;89
000024  8ae0              LDRH     r0,[r4,#0x16]         ;90
000026  b178              CBZ      r0,|L28.72|
000028  6921              LDR      r1,[r4,#0x10]         ;91
00002a  1d08              ADDS     r0,r1,#4              ;91
00002c  6120              STR      r0,[r4,#0x10]         ;91
00002e  680f              LDR      r7,[r1,#0]            ;91
000030  8ae0              LDRH     r0,[r4,#0x16]         ;92
000032  1e40              SUBS     r0,r0,#1              ;92
000034  82e0              STRH     r0,[r4,#0x16]         ;92
000036  68a1              LDR      r1,[r4,#8]            ;93
000038  6920              LDR      r0,[r4,#0x10]         ;93
00003a  4288              CMP      r0,r1                 ;93
00003c  d101              BNE      |L28.66|
00003e  6860              LDR      r0,[r4,#4]            ;94
000040  6120              STR      r0,[r4,#0x10]         ;94
                  |L28.66|
000042  2000              MOVS     r0,#0                 ;96
000044  7028              STRB     r0,[r5,#0]            ;96
000046  e002              B        |L28.78|
                  |L28.72|
000048  201f              MOVS     r0,#0x1f              ;98
00004a  7028              STRB     r0,[r5,#0]            ;98
00004c  2700              MOVS     r7,#0                 ;99
                  |L28.78|
00004e  4640              MOV      r0,r8                 ;101
000050  f7fffffe          BL       OS_CPU_SR_Restore
000054  4638              MOV      r0,r7                 ;102
000056  e7df              B        |L28.24|
;;;104    #endif
                          ENDP


                          AREA ||i.OSQCreate||, CODE, READONLY, ALIGN=2

                  OSQCreate PROC
;;;124    
;;;125    OS_EVENT  *OSQCreate (void    **start,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;126                          INT16U    size)
;;;127    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;128        OS_EVENT  *pevent;
;;;129        OS_Q      *pq;
;;;130    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;131        OS_CPU_SR  cpu_sr = 0u;
000008  f04f0800          MOV      r8,#0
;;;132    #endif
;;;133    
;;;134    
;;;135    
;;;136    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;137        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;138            OS_SAFETY_CRITICAL_EXCEPTION();
;;;139        }
;;;140    #endif
;;;141    
;;;142        if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
00000c  481f              LDR      r0,|L29.140|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b110              CBZ      r0,|L29.24|
;;;143            return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
000012  2000              MOVS     r0,#0
                  |L29.20|
;;;144        }
;;;145        OS_ENTER_CRITICAL();
;;;146        pevent = OSEventFreeList;                    /* Get next free event control block                  */
;;;147        if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
;;;148            OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
;;;149        }
;;;150        OS_EXIT_CRITICAL();
;;;151        if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
;;;152            OS_ENTER_CRITICAL();
;;;153            pq = OSQFreeList;                        /* Get a free queue control block                     */
;;;154            if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
;;;155                OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
;;;156                OS_EXIT_CRITICAL();
;;;157                pq->OSQStart           = start;               /*      Initialize the queue                 */
;;;158                pq->OSQEnd             = &start[size];
;;;159                pq->OSQIn              = start;
;;;160                pq->OSQOut             = start;
;;;161                pq->OSQSize            = size;
;;;162                pq->OSQEntries         = 0u;
;;;163                pevent->OSEventType    = OS_EVENT_TYPE_Q;
;;;164                pevent->OSEventCnt     = 0u;
;;;165                pevent->OSEventPtr     = pq;
;;;166    #if OS_EVENT_NAME_EN > 0u
;;;167                pevent->OSEventName    = (INT8U *)(void *)"?";
;;;168    #endif
;;;169                OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
;;;170            } else {
;;;171                pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
;;;172                OSEventFreeList    = pevent;
;;;173                OS_EXIT_CRITICAL();
;;;174                pevent = (OS_EVENT *)0;
;;;175            }
;;;176        }
;;;177        return (pevent);
;;;178    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L29.24|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4680              MOV      r8,r0                 ;145
00001e  481c              LDR      r0,|L29.144|
000020  6805              LDR      r5,[r0,#0]            ;146  ; OSEventFreeList
000022  6800              LDR      r0,[r0,#0]            ;147  ; OSEventFreeList
000024  b120              CBZ      r0,|L29.48|
000026  481a              LDR      r0,|L29.144|
000028  6800              LDR      r0,[r0,#0]            ;148  ; OSEventFreeList
00002a  6840              LDR      r0,[r0,#4]            ;148
00002c  4918              LDR      r1,|L29.144|
00002e  6008              STR      r0,[r1,#0]            ;148  ; OSEventFreeList
                  |L29.48|
000030  4640              MOV      r0,r8                 ;150
000032  f7fffffe          BL       OS_CPU_SR_Restore
000036  b33d              CBZ      r5,|L29.136|
000038  f7fffffe          BL       OS_CPU_SR_Save
00003c  4680              MOV      r8,r0                 ;152
00003e  4815              LDR      r0,|L29.148|
000040  6804              LDR      r4,[r0,#0]            ;153  ; OSQFreeList
000042  b1c4              CBZ      r4,|L29.118|
000044  6800              LDR      r0,[r0,#0]            ;155  ; OSQFreeList
000046  6800              LDR      r0,[r0,#0]            ;155
000048  4912              LDR      r1,|L29.148|
00004a  6008              STR      r0,[r1,#0]            ;155  ; OSQFreeList
00004c  4640              MOV      r0,r8                 ;156
00004e  f7fffffe          BL       OS_CPU_SR_Restore
000052  6066              STR      r6,[r4,#4]            ;157
000054  eb060087          ADD      r0,r6,r7,LSL #2       ;158
000058  60a0              STR      r0,[r4,#8]            ;158
00005a  60e6              STR      r6,[r4,#0xc]          ;159
00005c  6126              STR      r6,[r4,#0x10]         ;160
00005e  82a7              STRH     r7,[r4,#0x14]         ;161
000060  2000              MOVS     r0,#0                 ;162
000062  82e0              STRH     r0,[r4,#0x16]         ;162
000064  2002              MOVS     r0,#2                 ;163
000066  7028              STRB     r0,[r5,#0]            ;163
000068  2000              MOVS     r0,#0                 ;164
00006a  8128              STRH     r0,[r5,#8]            ;164
00006c  606c              STR      r4,[r5,#4]            ;165
00006e  4628              MOV      r0,r5                 ;169
000070  f7fffffe          BL       OS_EventWaitListInit
000074  e008              B        |L29.136|
                  |L29.118|
000076  4806              LDR      r0,|L29.144|
000078  6800              LDR      r0,[r0,#0]            ;171  ; OSEventFreeList
00007a  6068              STR      r0,[r5,#4]            ;171
00007c  4804              LDR      r0,|L29.144|
00007e  6005              STR      r5,[r0,#0]            ;172  ; OSEventFreeList
000080  4640              MOV      r0,r8                 ;173
000082  f7fffffe          BL       OS_CPU_SR_Restore
000086  2500              MOVS     r5,#0                 ;174
                  |L29.136|
000088  4628              MOV      r0,r5                 ;177
00008a  e7c3              B        |L29.20|
;;;179    /*$PAGE*/
                          ENDP

                  |L29.140|
                          DCD      OSIntNesting
                  |L29.144|
                          DCD      OSEventFreeList
                  |L29.148|
                          DCD      OSQFreeList

                          AREA ||i.OSQDel||, CODE, READONLY, ALIGN=2

                  OSQDel PROC
;;;221    #if OS_Q_DEL_EN > 0u
;;;222    OS_EVENT  *OSQDel (OS_EVENT  *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;223                       INT8U      opt,
;;;224                       INT8U     *perr)
;;;225    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;226        BOOLEAN    tasks_waiting;
;;;227        OS_EVENT  *pevent_return;
;;;228        OS_Q      *pq;
;;;229    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;230        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0a00          MOV      r10,#0
;;;231    #endif
;;;232    
;;;233    
;;;234    
;;;235    #ifdef OS_SAFETY_CRITICAL
;;;236        if (perr == (INT8U *)0) {
;;;237            OS_SAFETY_CRITICAL_EXCEPTION();
;;;238        }
;;;239    #endif
;;;240    
;;;241    #if OS_ARG_CHK_EN > 0u
;;;242        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;243            *perr = OS_ERR_PEVENT_NULL;
;;;244            return (pevent);
;;;245        }
;;;246    #endif
;;;247        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
00000e  7820              LDRB     r0,[r4,#0]
000010  2802              CMP      r0,#2
000012  d004              BEQ      |L30.30|
;;;248            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;249            return (pevent);
000018  4620              MOV      r0,r4
                  |L30.26|
;;;250        }
;;;251        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
;;;252            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
;;;253            return (pevent);
;;;254        }
;;;255        OS_ENTER_CRITICAL();
;;;256        if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
;;;257            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;258        } else {
;;;259            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;260        }
;;;261        switch (opt) {
;;;262            case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
;;;263                 if (tasks_waiting == OS_FALSE) {
;;;264    #if OS_EVENT_NAME_EN > 0u
;;;265                     pevent->OSEventName    = (INT8U *)(void *)"?";
;;;266    #endif
;;;267                     pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
;;;268                     pq->OSQPtr             = OSQFreeList;
;;;269                     OSQFreeList            = pq;
;;;270                     pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;271                     pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
;;;272                     pevent->OSEventCnt     = 0u;
;;;273                     OSEventFreeList        = pevent;          /* Get next free event control block        */
;;;274                     OS_EXIT_CRITICAL();
;;;275                     *perr                  = OS_ERR_NONE;
;;;276                     pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
;;;277                 } else {
;;;278                     OS_EXIT_CRITICAL();
;;;279                     *perr                  = OS_ERR_TASK_WAITING;
;;;280                     pevent_return          = pevent;
;;;281                 }
;;;282                 break;
;;;283    
;;;284            case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
;;;285                 while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
;;;286                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
;;;287                 }
;;;288    #if OS_EVENT_NAME_EN > 0u
;;;289                 pevent->OSEventName    = (INT8U *)(void *)"?";
;;;290    #endif
;;;291                 pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
;;;292                 pq->OSQPtr             = OSQFreeList;
;;;293                 OSQFreeList            = pq;
;;;294                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;295                 pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
;;;296                 pevent->OSEventCnt     = 0u;
;;;297                 OSEventFreeList        = pevent;              /* Get next free event control block        */
;;;298                 OS_EXIT_CRITICAL();
;;;299                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;300                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;301                 }
;;;302                 *perr                  = OS_ERR_NONE;
;;;303                 pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
;;;304                 break;
;;;305    
;;;306            default:
;;;307                 OS_EXIT_CRITICAL();
;;;308                 *perr                  = OS_ERR_INVALID_OPT;
;;;309                 pevent_return          = pevent;
;;;310                 break;
;;;311        }
;;;312        return (pevent_return);
;;;313    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L30.30|
00001e  4833              LDR      r0,|L30.236|
000020  7800              LDRB     r0,[r0,#0]            ;251  ; OSIntNesting
000022  b118              CBZ      r0,|L30.44|
000024  200f              MOVS     r0,#0xf               ;252
000026  7028              STRB     r0,[r5,#0]            ;252
000028  4620              MOV      r0,r4                 ;253
00002a  e7f6              B        |L30.26|
                  |L30.44|
00002c  f7fffffe          BL       OS_CPU_SR_Save
000030  4682              MOV      r10,r0                ;255
000032  7aa0              LDRB     r0,[r4,#0xa]          ;256
000034  b110              CBZ      r0,|L30.60|
000036  f04f0801          MOV      r8,#1                 ;257
00003a  e001              B        |L30.64|
                  |L30.60|
00003c  f04f0800          MOV      r8,#0                 ;259
                  |L30.64|
000040  f1b90f00          CMP      r9,#0                 ;261
000044  d003              BEQ      |L30.78|
000046  f1b90f01          CMP      r9,#1                 ;261
00004a  d145              BNE      |L30.216|
00004c  e01f              B        |L30.142|
                  |L30.78|
00004e  f1b80f00          CMP      r8,#0                 ;263
000052  d115              BNE      |L30.128|
000054  6866              LDR      r6,[r4,#4]            ;267
000056  4826              LDR      r0,|L30.240|
000058  6800              LDR      r0,[r0,#0]            ;268  ; OSQFreeList
00005a  6030              STR      r0,[r6,#0]            ;268
00005c  4824              LDR      r0,|L30.240|
00005e  6006              STR      r6,[r0,#0]            ;269  ; OSQFreeList
000060  2000              MOVS     r0,#0                 ;270
000062  7020              STRB     r0,[r4,#0]            ;270
000064  4823              LDR      r0,|L30.244|
000066  6800              LDR      r0,[r0,#0]            ;271  ; OSEventFreeList
000068  6060              STR      r0,[r4,#4]            ;271
00006a  2000              MOVS     r0,#0                 ;272
00006c  8120              STRH     r0,[r4,#8]            ;272
00006e  4821              LDR      r0,|L30.244|
000070  6004              STR      r4,[r0,#0]            ;273  ; OSEventFreeList
000072  4650              MOV      r0,r10                ;274
000074  f7fffffe          BL       OS_CPU_SR_Restore
000078  2000              MOVS     r0,#0                 ;275
00007a  7028              STRB     r0,[r5,#0]            ;275
00007c  2700              MOVS     r7,#0                 ;276
00007e  e005              B        |L30.140|
                  |L30.128|
000080  4650              MOV      r0,r10                ;278
000082  f7fffffe          BL       OS_CPU_SR_Restore
000086  2049              MOVS     r0,#0x49              ;279
000088  7028              STRB     r0,[r5,#0]            ;279
00008a  4627              MOV      r7,r4                 ;280
                  |L30.140|
00008c  e02b              B        |L30.230|
                  |L30.142|
00008e  e005              B        |L30.156|
                  |L30.144|
000090  2300              MOVS     r3,#0                 ;286
000092  2204              MOVS     r2,#4                 ;286
000094  4619              MOV      r1,r3                 ;286
000096  4620              MOV      r0,r4                 ;286
000098  f7fffffe          BL       OS_EventTaskRdy
                  |L30.156|
00009c  7aa0              LDRB     r0,[r4,#0xa]          ;285
00009e  2800              CMP      r0,#0                 ;285
0000a0  d1f6              BNE      |L30.144|
0000a2  6866              LDR      r6,[r4,#4]            ;291
0000a4  4812              LDR      r0,|L30.240|
0000a6  6800              LDR      r0,[r0,#0]            ;292  ; OSQFreeList
0000a8  6030              STR      r0,[r6,#0]            ;292
0000aa  4811              LDR      r0,|L30.240|
0000ac  6006              STR      r6,[r0,#0]            ;293  ; OSQFreeList
0000ae  2000              MOVS     r0,#0                 ;294
0000b0  7020              STRB     r0,[r4,#0]            ;294
0000b2  4810              LDR      r0,|L30.244|
0000b4  6800              LDR      r0,[r0,#0]            ;295  ; OSEventFreeList
0000b6  6060              STR      r0,[r4,#4]            ;295
0000b8  2000              MOVS     r0,#0                 ;296
0000ba  8120              STRH     r0,[r4,#8]            ;296
0000bc  480d              LDR      r0,|L30.244|
0000be  6004              STR      r4,[r0,#0]            ;297  ; OSEventFreeList
0000c0  4650              MOV      r0,r10                ;298
0000c2  f7fffffe          BL       OS_CPU_SR_Restore
0000c6  f1b80f01          CMP      r8,#1                 ;299
0000ca  d101              BNE      |L30.208|
0000cc  f7fffffe          BL       OS_Sched
                  |L30.208|
0000d0  2000              MOVS     r0,#0                 ;302
0000d2  7028              STRB     r0,[r5,#0]            ;302
0000d4  2700              MOVS     r7,#0                 ;303
0000d6  e006              B        |L30.230|
                  |L30.216|
0000d8  4650              MOV      r0,r10                ;307
0000da  f7fffffe          BL       OS_CPU_SR_Restore
0000de  2007              MOVS     r0,#7                 ;308
0000e0  7028              STRB     r0,[r5,#0]            ;308
0000e2  4627              MOV      r7,r4                 ;309
0000e4  bf00              NOP                            ;310
                  |L30.230|
0000e6  bf00              NOP                            ;282
0000e8  4638              MOV      r0,r7                 ;312
0000ea  e796              B        |L30.26|
;;;314    #endif
                          ENDP

                  |L30.236|
                          DCD      OSIntNesting
                  |L30.240|
                          DCD      OSQFreeList
                  |L30.244|
                          DCD      OSEventFreeList

                          AREA ||i.OSQFlush||, CODE, READONLY, ALIGN=1

                  OSQFlush PROC
;;;336    #if OS_Q_FLUSH_EN > 0u
;;;337    INT8U  OSQFlush (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;338    {
000002  4605              MOV      r5,r0
;;;339        OS_Q      *pq;
;;;340    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;341        OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;342    #endif
;;;343    
;;;344    
;;;345    
;;;346    #if OS_ARG_CHK_EN > 0u
;;;347        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;348            return (OS_ERR_PEVENT_NULL);
;;;349        }
;;;350        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
;;;351            return (OS_ERR_EVENT_TYPE);
;;;352        }
;;;353    #endif
;;;354        OS_ENTER_CRITICAL();
000006  f7fffffe          BL       OS_CPU_SR_Save
00000a  4606              MOV      r6,r0
;;;355        pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
00000c  686c              LDR      r4,[r5,#4]
;;;356        pq->OSQIn      = pq->OSQStart;
00000e  6860              LDR      r0,[r4,#4]
000010  60e0              STR      r0,[r4,#0xc]
;;;357        pq->OSQOut     = pq->OSQStart;
000012  6860              LDR      r0,[r4,#4]
000014  6120              STR      r0,[r4,#0x10]
;;;358        pq->OSQEntries = 0u;
000016  2000              MOVS     r0,#0
000018  82e0              STRH     r0,[r4,#0x16]
;;;359        OS_EXIT_CRITICAL();
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       OS_CPU_SR_Restore
;;;360        return (OS_ERR_NONE);
000020  2000              MOVS     r0,#0
;;;361    }
000022  bd70              POP      {r4-r6,pc}
;;;362    #endif
                          ENDP


                          AREA ||i.OSQPend||, CODE, READONLY, ALIGN=2

                  OSQPend PROC
;;;400    
;;;401    void  *OSQPend (OS_EVENT  *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;402                    INT32U     timeout,
;;;403                    INT8U     *perr)
;;;404    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;405        void      *pmsg;
;;;406        OS_Q      *pq;
;;;407    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;408        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0900          MOV      r9,#0
;;;409    #endif
;;;410    
;;;411    
;;;412    
;;;413    #ifdef OS_SAFETY_CRITICAL
;;;414        if (perr == (INT8U *)0) {
;;;415            OS_SAFETY_CRITICAL_EXCEPTION();
;;;416        }
;;;417    #endif
;;;418    
;;;419    #if OS_ARG_CHK_EN > 0u
;;;420        if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
;;;421            *perr = OS_ERR_PEVENT_NULL;
;;;422            return ((void *)0);
;;;423        }
;;;424    #endif
;;;425        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
00000e  7838              LDRB     r0,[r7,#0]
000010  2802              CMP      r0,#2
000012  d004              BEQ      |L32.30|
;;;426            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;427            return ((void *)0);
000018  2000              MOVS     r0,#0
                  |L32.26|
;;;428        }
;;;429        if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
;;;430            *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
;;;431            return ((void *)0);
;;;432        }
;;;433        if (OSLockNesting > 0u) {                    /* See if called with scheduler locked ...            */
;;;434            *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
;;;435            return ((void *)0);
;;;436        }
;;;437        OS_ENTER_CRITICAL();
;;;438        pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
;;;439        if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
;;;440            pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
;;;441            pq->OSQEntries--;                        /* Update the number of entries in the queue          */
;;;442            if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
;;;443                pq->OSQOut = pq->OSQStart;
;;;444            }
;;;445            OS_EXIT_CRITICAL();
;;;446            *perr = OS_ERR_NONE;
;;;447            return (pmsg);                           /* Return message received                            */
;;;448        }
;;;449        OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
;;;450        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;451        OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
;;;452        OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
;;;453        OS_EXIT_CRITICAL();
;;;454        OS_Sched();                                  /* Find next highest priority task ready to run       */
;;;455        OS_ENTER_CRITICAL();
;;;456        switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
;;;457            case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
;;;458                 pmsg =  OSTCBCur->OSTCBMsg;
;;;459                *perr =  OS_ERR_NONE;
;;;460                 break;
;;;461    
;;;462            case OS_STAT_PEND_ABORT:
;;;463                 pmsg = (void *)0;
;;;464                *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
;;;465                 break;
;;;466    
;;;467            case OS_STAT_PEND_TO:
;;;468            default:
;;;469                 OS_EventTaskRemove(OSTCBCur, pevent);
;;;470                 pmsg = (void *)0;
;;;471                *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
;;;472                 break;
;;;473        }
;;;474        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
;;;475        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
;;;476        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
;;;477    #if (OS_EVENT_MULTI_EN > 0u)
;;;478        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;479    #endif
;;;480        OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
;;;481        OS_EXIT_CRITICAL();
;;;482        return (pmsg);                                    /* Return received message                       */
;;;483    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L32.30|
00001e  483c              LDR      r0,|L32.272|
000020  7800              LDRB     r0,[r0,#0]            ;429  ; OSIntNesting
000022  b118              CBZ      r0,|L32.44|
000024  2002              MOVS     r0,#2                 ;430
000026  7028              STRB     r0,[r5,#0]            ;430
000028  2000              MOVS     r0,#0                 ;431
00002a  e7f6              B        |L32.26|
                  |L32.44|
00002c  4839              LDR      r0,|L32.276|
00002e  7800              LDRB     r0,[r0,#0]            ;433  ; OSLockNesting
000030  b118              CBZ      r0,|L32.58|
000032  200d              MOVS     r0,#0xd               ;434
000034  7028              STRB     r0,[r5,#0]            ;434
000036  2000              MOVS     r0,#0                 ;435
000038  e7ef              B        |L32.26|
                  |L32.58|
00003a  f7fffffe          BL       OS_CPU_SR_Save
00003e  4681              MOV      r9,r0                 ;437
000040  687c              LDR      r4,[r7,#4]            ;438
000042  8ae0              LDRH     r0,[r4,#0x16]         ;439
000044  b198              CBZ      r0,|L32.110|
000046  6921              LDR      r1,[r4,#0x10]         ;440
000048  1d08              ADDS     r0,r1,#4              ;440
00004a  6120              STR      r0,[r4,#0x10]         ;440
00004c  680e              LDR      r6,[r1,#0]            ;440
00004e  8ae0              LDRH     r0,[r4,#0x16]         ;441
000050  1e40              SUBS     r0,r0,#1              ;441
000052  82e0              STRH     r0,[r4,#0x16]         ;441
000054  68a1              LDR      r1,[r4,#8]            ;442
000056  6920              LDR      r0,[r4,#0x10]         ;442
000058  4288              CMP      r0,r1                 ;442
00005a  d101              BNE      |L32.96|
00005c  6860              LDR      r0,[r4,#4]            ;443
00005e  6120              STR      r0,[r4,#0x10]         ;443
                  |L32.96|
000060  4648              MOV      r0,r9                 ;445
000062  f7fffffe          BL       OS_CPU_SR_Restore
000066  2000              MOVS     r0,#0                 ;446
000068  7028              STRB     r0,[r5,#0]            ;446
00006a  4630              MOV      r0,r6                 ;447
00006c  e7d5              B        |L32.26|
                  |L32.110|
00006e  482a              LDR      r0,|L32.280|
000070  6800              LDR      r0,[r0,#0]            ;449  ; OSTCBCur
000072  f8900030          LDRB     r0,[r0,#0x30]         ;449
000076  f0400004          ORR      r0,r0,#4              ;449
00007a  4927              LDR      r1,|L32.280|
00007c  6809              LDR      r1,[r1,#0]            ;449  ; OSTCBCur
00007e  f8810030          STRB     r0,[r1,#0x30]         ;449
000082  2000              MOVS     r0,#0                 ;450
000084  4924              LDR      r1,|L32.280|
000086  6809              LDR      r1,[r1,#0]            ;450  ; OSTCBCur
000088  f8810031          STRB     r0,[r1,#0x31]         ;450
00008c  4822              LDR      r0,|L32.280|
00008e  6800              LDR      r0,[r0,#0]            ;451  ; OSTCBCur
000090  f8c0802c          STR      r8,[r0,#0x2c]         ;451
000094  4638              MOV      r0,r7                 ;452
000096  f7fffffe          BL       OS_EventTaskWait
00009a  4648              MOV      r0,r9                 ;453
00009c  f7fffffe          BL       OS_CPU_SR_Restore
0000a0  f7fffffe          BL       OS_Sched
0000a4  f7fffffe          BL       OS_CPU_SR_Save
0000a8  4681              MOV      r9,r0                 ;455
0000aa  481b              LDR      r0,|L32.280|
0000ac  6800              LDR      r0,[r0,#0]            ;456  ; OSTCBCur
0000ae  f8900031          LDRB     r0,[r0,#0x31]         ;456
0000b2  b120              CBZ      r0,|L32.190|
0000b4  2801              CMP      r0,#1                 ;456
0000b6  d00d              BEQ      |L32.212|
0000b8  2802              CMP      r0,#2                 ;456
0000ba  d10a              BNE      |L32.210|
0000bc  e005              B        |L32.202|
                  |L32.190|
0000be  4816              LDR      r0,|L32.280|
0000c0  6800              LDR      r0,[r0,#0]            ;458  ; OSTCBCur
0000c2  6a06              LDR      r6,[r0,#0x20]         ;458
0000c4  2000              MOVS     r0,#0                 ;459
0000c6  7028              STRB     r0,[r5,#0]            ;459
0000c8  e00d              B        |L32.230|
                  |L32.202|
0000ca  2600              MOVS     r6,#0                 ;463
0000cc  200e              MOVS     r0,#0xe               ;464
0000ce  7028              STRB     r0,[r5,#0]            ;464
0000d0  e009              B        |L32.230|
                  |L32.210|
0000d2  bf00              NOP                            ;467
                  |L32.212|
0000d4  4639              MOV      r1,r7                 ;469
0000d6  4810              LDR      r0,|L32.280|
0000d8  6800              LDR      r0,[r0,#0]            ;469  ; OSTCBCur
0000da  f7fffffe          BL       OS_EventTaskRemove
0000de  2600              MOVS     r6,#0                 ;470
0000e0  200a              MOVS     r0,#0xa               ;471
0000e2  7028              STRB     r0,[r5,#0]            ;471
0000e4  bf00              NOP                            ;472
                  |L32.230|
0000e6  bf00              NOP                            ;460
0000e8  2000              MOVS     r0,#0                 ;474
0000ea  490b              LDR      r1,|L32.280|
0000ec  6809              LDR      r1,[r1,#0]            ;474  ; OSTCBCur
0000ee  f8810030          STRB     r0,[r1,#0x30]         ;474
0000f2  4909              LDR      r1,|L32.280|
0000f4  6809              LDR      r1,[r1,#0]            ;475  ; OSTCBCur
0000f6  f8810031          STRB     r0,[r1,#0x31]         ;475
0000fa  4907              LDR      r1,|L32.280|
0000fc  6809              LDR      r1,[r1,#0]            ;476  ; OSTCBCur
0000fe  61c8              STR      r0,[r1,#0x1c]         ;476
000100  4905              LDR      r1,|L32.280|
000102  6809              LDR      r1,[r1,#0]            ;480  ; OSTCBCur
000104  6208              STR      r0,[r1,#0x20]         ;480
000106  4648              MOV      r0,r9                 ;481
000108  f7fffffe          BL       OS_CPU_SR_Restore
00010c  4630              MOV      r0,r6                 ;482
00010e  e784              B        |L32.26|
;;;484    /*$PAGE*/
                          ENDP

                  |L32.272|
                          DCD      OSIntNesting
                  |L32.276|
                          DCD      OSLockNesting
                  |L32.280|
                          DCD      OSTCBCur

                          AREA ||i.OSQPendAbort||, CODE, READONLY, ALIGN=1

                  OSQPendAbort PROC
;;;517    #if OS_Q_PEND_ABORT_EN > 0u
;;;518    INT8U  OSQPendAbort (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;519                         INT8U      opt,
;;;520                         INT8U     *perr)
;;;521    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;522        INT8U      nbr_tasks;
;;;523    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;524        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;525    #endif
;;;526    
;;;527    
;;;528    
;;;529    #ifdef OS_SAFETY_CRITICAL
;;;530        if (perr == (INT8U *)0) {
;;;531            OS_SAFETY_CRITICAL_EXCEPTION();
;;;532        }
;;;533    #endif
;;;534    
;;;535    #if OS_ARG_CHK_EN > 0u
;;;536        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;537            *perr = OS_ERR_PEVENT_NULL;
;;;538            return (0u);
;;;539        }
;;;540    #endif
;;;541        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
00000e  7820              LDRB     r0,[r4,#0]
000010  2802              CMP      r0,#2
000012  d004              BEQ      |L33.30|
;;;542            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;543            return (0u);
000018  2000              MOVS     r0,#0
                  |L33.26|
;;;544        }
;;;545        OS_ENTER_CRITICAL();
;;;546        if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
;;;547            nbr_tasks = 0u;
;;;548            switch (opt) {
;;;549                case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
;;;550                     while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
;;;551                         (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
;;;552                         nbr_tasks++;
;;;553                     }
;;;554                     break;
;;;555    
;;;556                case OS_PEND_OPT_NONE:
;;;557                default:                                       /* No,  ready HPT       waiting on queue    */
;;;558                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
;;;559                     nbr_tasks++;
;;;560                     break;
;;;561            }
;;;562            OS_EXIT_CRITICAL();
;;;563            OS_Sched();                                        /* Find HPT ready to run                    */
;;;564            *perr = OS_ERR_PEND_ABORT;
;;;565            return (nbr_tasks);
;;;566        }
;;;567        OS_EXIT_CRITICAL();
;;;568        *perr = OS_ERR_NONE;
;;;569        return (0u);                                           /* No tasks waiting on queue                */
;;;570    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L33.30|
00001e  f7fffffe          BL       OS_CPU_SR_Save
000022  4680              MOV      r8,r0                 ;545
000024  7aa0              LDRB     r0,[r4,#0xa]          ;546
000026  b320              CBZ      r0,|L33.114|
000028  2600              MOVS     r6,#0                 ;547
00002a  b17f              CBZ      r7,|L33.76|
00002c  2f01              CMP      r7,#1                 ;548
00002e  d10c              BNE      |L33.74|
000030  e007              B        |L33.66|
                  |L33.50|
000032  2302              MOVS     r3,#2                 ;551
000034  2204              MOVS     r2,#4                 ;551
000036  2100              MOVS     r1,#0                 ;551
000038  4620              MOV      r0,r4                 ;551
00003a  f7fffffe          BL       OS_EventTaskRdy
00003e  1c70              ADDS     r0,r6,#1              ;552
000040  b2c6              UXTB     r6,r0                 ;552
                  |L33.66|
000042  7aa0              LDRB     r0,[r4,#0xa]          ;550
000044  2800              CMP      r0,#0                 ;550
000046  d1f4              BNE      |L33.50|
000048  e009              B        |L33.94|
                  |L33.74|
00004a  bf00              NOP                            ;556
                  |L33.76|
00004c  2302              MOVS     r3,#2                 ;558
00004e  2204              MOVS     r2,#4                 ;558
000050  2100              MOVS     r1,#0                 ;558
000052  4620              MOV      r0,r4                 ;558
000054  f7fffffe          BL       OS_EventTaskRdy
000058  1c70              ADDS     r0,r6,#1              ;559
00005a  b2c6              UXTB     r6,r0                 ;559
00005c  bf00              NOP                            ;560
                  |L33.94|
00005e  bf00              NOP                            ;554
000060  4640              MOV      r0,r8                 ;562
000062  f7fffffe          BL       OS_CPU_SR_Restore
000066  f7fffffe          BL       OS_Sched
00006a  200e              MOVS     r0,#0xe               ;564
00006c  7028              STRB     r0,[r5,#0]            ;564
00006e  4630              MOV      r0,r6                 ;565
000070  e7d3              B        |L33.26|
                  |L33.114|
000072  4640              MOV      r0,r8                 ;567
000074  f7fffffe          BL       OS_CPU_SR_Restore
000078  2000              MOVS     r0,#0                 ;568
00007a  7028              STRB     r0,[r5,#0]            ;568
00007c  bf00              NOP                            ;569
00007e  e7cc              B        |L33.26|
;;;571    #endif
                          ENDP


                          AREA ||i.OSQPost||, CODE, READONLY, ALIGN=1

                  OSQPost PROC
;;;593    #if OS_Q_POST_EN > 0u
;;;594    INT8U  OSQPost (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;595                    void      *pmsg)
;;;596    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;597        OS_Q      *pq;
;;;598    #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
;;;599        OS_CPU_SR  cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;600    #endif
;;;601    
;;;602    
;;;603    
;;;604    #if OS_ARG_CHK_EN > 0u
;;;605        if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
;;;606            return (OS_ERR_PEVENT_NULL);
;;;607        }
;;;608    #endif
;;;609        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
00000a  7828              LDRB     r0,[r5,#0]
00000c  2802              CMP      r0,#2
00000e  d002              BEQ      |L34.22|
;;;610            return (OS_ERR_EVENT_TYPE);
000010  2001              MOVS     r0,#1
                  |L34.18|
;;;611        }
;;;612        OS_ENTER_CRITICAL();
;;;613        if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
;;;614                                                           /* Ready highest priority task waiting on event */
;;;615            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
;;;616            OS_EXIT_CRITICAL();
;;;617            OS_Sched();                                    /* Find highest priority task ready to run      */
;;;618            return (OS_ERR_NONE);
;;;619        }
;;;620        pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
;;;621        if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
;;;622            OS_EXIT_CRITICAL();
;;;623            return (OS_ERR_Q_FULL);
;;;624        }
;;;625        *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
;;;626        pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
;;;627        if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
;;;628            pq->OSQIn = pq->OSQStart;
;;;629        }
;;;630        OS_EXIT_CRITICAL();
;;;631        return (OS_ERR_NONE);
;;;632    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L34.22|
000016  f7fffffe          BL       OS_CPU_SR_Save
00001a  4607              MOV      r7,r0                 ;612
00001c  7aa8              LDRB     r0,[r5,#0xa]          ;613
00001e  b160              CBZ      r0,|L34.58|
000020  2300              MOVS     r3,#0                 ;615
000022  2204              MOVS     r2,#4                 ;615
000024  4631              MOV      r1,r6                 ;615
000026  4628              MOV      r0,r5                 ;615
000028  f7fffffe          BL       OS_EventTaskRdy
00002c  4638              MOV      r0,r7                 ;616
00002e  f7fffffe          BL       OS_CPU_SR_Restore
000032  f7fffffe          BL       OS_Sched
000036  2000              MOVS     r0,#0                 ;618
000038  e7eb              B        |L34.18|
                  |L34.58|
00003a  686c              LDR      r4,[r5,#4]            ;620
00003c  8ae0              LDRH     r0,[r4,#0x16]         ;621
00003e  8aa1              LDRH     r1,[r4,#0x14]         ;621
000040  4288              CMP      r0,r1                 ;621
000042  db04              BLT      |L34.78|
000044  4638              MOV      r0,r7                 ;622
000046  f7fffffe          BL       OS_CPU_SR_Restore
00004a  201e              MOVS     r0,#0x1e              ;623
00004c  e7e1              B        |L34.18|
                  |L34.78|
00004e  68e1              LDR      r1,[r4,#0xc]          ;625
000050  1d08              ADDS     r0,r1,#4              ;625
000052  60e0              STR      r0,[r4,#0xc]          ;625
000054  600e              STR      r6,[r1,#0]            ;625
000056  8ae0              LDRH     r0,[r4,#0x16]         ;626
000058  1c40              ADDS     r0,r0,#1              ;626
00005a  82e0              STRH     r0,[r4,#0x16]         ;626
00005c  e9d41002          LDRD     r1,r0,[r4,#8]         ;627
000060  4288              CMP      r0,r1                 ;627
000062  d101              BNE      |L34.104|
000064  6860              LDR      r0,[r4,#4]            ;628
000066  60e0              STR      r0,[r4,#0xc]          ;628
                  |L34.104|
000068  4638              MOV      r0,r7                 ;630
00006a  f7fffffe          BL       OS_CPU_SR_Restore
00006e  2000              MOVS     r0,#0                 ;631
000070  e7cf              B        |L34.18|
;;;633    #endif
                          ENDP


                          AREA ||i.OSQPostFront||, CODE, READONLY, ALIGN=1

                  OSQPostFront PROC
;;;656    #if OS_Q_POST_FRONT_EN > 0u
;;;657    INT8U  OSQPostFront (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;658                         void      *pmsg)
;;;659    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;660        OS_Q      *pq;
;;;661    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;662        OS_CPU_SR  cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;663    #endif
;;;664    
;;;665    
;;;666    
;;;667    #if OS_ARG_CHK_EN > 0u
;;;668        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;669            return (OS_ERR_PEVENT_NULL);
;;;670        }
;;;671    #endif
;;;672        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
00000a  7828              LDRB     r0,[r5,#0]
00000c  2802              CMP      r0,#2
00000e  d002              BEQ      |L35.22|
;;;673            return (OS_ERR_EVENT_TYPE);
000010  2001              MOVS     r0,#1
                  |L35.18|
;;;674        }
;;;675        OS_ENTER_CRITICAL();
;;;676        if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
;;;677                                                          /* Ready highest priority task waiting on event  */
;;;678            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
;;;679            OS_EXIT_CRITICAL();
;;;680            OS_Sched();                                   /* Find highest priority task ready to run       */
;;;681            return (OS_ERR_NONE);
;;;682        }
;;;683        pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
;;;684        if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
;;;685            OS_EXIT_CRITICAL();
;;;686            return (OS_ERR_Q_FULL);
;;;687        }
;;;688        if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
;;;689            pq->OSQOut = pq->OSQEnd;
;;;690        }
;;;691        pq->OSQOut--;
;;;692        *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
;;;693        pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
;;;694        OS_EXIT_CRITICAL();
;;;695        return (OS_ERR_NONE);
;;;696    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L35.22|
000016  f7fffffe          BL       OS_CPU_SR_Save
00001a  4607              MOV      r7,r0                 ;675
00001c  7aa8              LDRB     r0,[r5,#0xa]          ;676
00001e  b160              CBZ      r0,|L35.58|
000020  2300              MOVS     r3,#0                 ;678
000022  2204              MOVS     r2,#4                 ;678
000024  4631              MOV      r1,r6                 ;678
000026  4628              MOV      r0,r5                 ;678
000028  f7fffffe          BL       OS_EventTaskRdy
00002c  4638              MOV      r0,r7                 ;679
00002e  f7fffffe          BL       OS_CPU_SR_Restore
000032  f7fffffe          BL       OS_Sched
000036  2000              MOVS     r0,#0                 ;681
000038  e7eb              B        |L35.18|
                  |L35.58|
00003a  686c              LDR      r4,[r5,#4]            ;683
00003c  8ae0              LDRH     r0,[r4,#0x16]         ;684
00003e  8aa1              LDRH     r1,[r4,#0x14]         ;684
000040  4288              CMP      r0,r1                 ;684
000042  db04              BLT      |L35.78|
000044  4638              MOV      r0,r7                 ;685
000046  f7fffffe          BL       OS_CPU_SR_Restore
00004a  201e              MOVS     r0,#0x1e              ;686
00004c  e7e1              B        |L35.18|
                  |L35.78|
00004e  6861              LDR      r1,[r4,#4]            ;688
000050  6920              LDR      r0,[r4,#0x10]         ;688
000052  4288              CMP      r0,r1                 ;688
000054  d101              BNE      |L35.90|
000056  68a0              LDR      r0,[r4,#8]            ;689
000058  6120              STR      r0,[r4,#0x10]         ;689
                  |L35.90|
00005a  6920              LDR      r0,[r4,#0x10]         ;691
00005c  1f00              SUBS     r0,r0,#4              ;691
00005e  6120              STR      r0,[r4,#0x10]         ;691
000060  6920              LDR      r0,[r4,#0x10]         ;692
000062  6006              STR      r6,[r0,#0]            ;692
000064  8ae0              LDRH     r0,[r4,#0x16]         ;693
000066  1c40              ADDS     r0,r0,#1              ;693
000068  82e0              STRH     r0,[r4,#0x16]         ;693
00006a  4638              MOV      r0,r7                 ;694
00006c  f7fffffe          BL       OS_CPU_SR_Restore
000070  2000              MOVS     r0,#0                 ;695
000072  e7ce              B        |L35.18|
;;;697    #endif
                          ENDP


                          AREA ||i.OSQPostOpt||, CODE, READONLY, ALIGN=1

                  OSQPostOpt PROC
;;;728    #if OS_Q_POST_OPT_EN > 0u
;;;729    INT8U  OSQPostOpt (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;730                       void      *pmsg,
;;;731                       INT8U      opt)
;;;732    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;733        OS_Q      *pq;
;;;734    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;735        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;736    #endif
;;;737    
;;;738    
;;;739    
;;;740    #if OS_ARG_CHK_EN > 0u
;;;741        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;742            return (OS_ERR_PEVENT_NULL);
;;;743        }
;;;744    #endif
;;;745        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
00000e  7828              LDRB     r0,[r5,#0]
000010  2802              CMP      r0,#2
000012  d002              BEQ      |L36.26|
;;;746            return (OS_ERR_EVENT_TYPE);
000014  2001              MOVS     r0,#1
                  |L36.22|
;;;747        }
;;;748        OS_ENTER_CRITICAL();
;;;749        if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
;;;750            if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
;;;751                while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
;;;752                    (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
;;;753                }
;;;754            } else {                                      /* No,  Post to HPT waiting on queue             */
;;;755                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
;;;756            }
;;;757            OS_EXIT_CRITICAL();
;;;758            if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {	  /* See if scheduler needs to be invoked          */
;;;759                OS_Sched();                               /* Find highest priority task ready to run       */
;;;760            }
;;;761            return (OS_ERR_NONE);
;;;762        }
;;;763        pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
;;;764        if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
;;;765            OS_EXIT_CRITICAL();
;;;766            return (OS_ERR_Q_FULL);
;;;767        }
;;;768        if ((opt & OS_POST_OPT_FRONT) != 0x00u) {         /* Do we post to the FRONT of the queue?         */
;;;769            if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
;;;770                pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
;;;771            }
;;;772            pq->OSQOut--;
;;;773            *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
;;;774        } else {                                          /* No,  Post as FIFO                             */
;;;775            *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
;;;776            if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
;;;777                pq->OSQIn = pq->OSQStart;
;;;778            }
;;;779        }
;;;780        pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
;;;781        OS_EXIT_CRITICAL();
;;;782        return (OS_ERR_NONE);
;;;783    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L36.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4680              MOV      r8,r0                 ;748
000020  7aa8              LDRB     r0,[r5,#0xa]          ;749
000022  b1e8              CBZ      r0,|L36.96|
000024  f0060001          AND      r0,r6,#1              ;750
000028  b150              CBZ      r0,|L36.64|
00002a  e005              B        |L36.56|
                  |L36.44|
00002c  2300              MOVS     r3,#0                 ;752
00002e  2204              MOVS     r2,#4                 ;752
000030  4639              MOV      r1,r7                 ;752
000032  4628              MOV      r0,r5                 ;752
000034  f7fffffe          BL       OS_EventTaskRdy
                  |L36.56|
000038  7aa8              LDRB     r0,[r5,#0xa]          ;751
00003a  2800              CMP      r0,#0                 ;751
00003c  d1f6              BNE      |L36.44|
00003e  e005              B        |L36.76|
                  |L36.64|
000040  2300              MOVS     r3,#0                 ;755
000042  2204              MOVS     r2,#4                 ;755
000044  4639              MOV      r1,r7                 ;755
000046  4628              MOV      r0,r5                 ;755
000048  f7fffffe          BL       OS_EventTaskRdy
                  |L36.76|
00004c  4640              MOV      r0,r8                 ;757
00004e  f7fffffe          BL       OS_CPU_SR_Restore
000052  f0060004          AND      r0,r6,#4              ;758
000056  b908              CBNZ     r0,|L36.92|
000058  f7fffffe          BL       OS_Sched
                  |L36.92|
00005c  2000              MOVS     r0,#0                 ;761
00005e  e7da              B        |L36.22|
                  |L36.96|
000060  686c              LDR      r4,[r5,#4]            ;763
000062  8ae0              LDRH     r0,[r4,#0x16]         ;764
000064  8aa1              LDRH     r1,[r4,#0x14]         ;764
000066  4288              CMP      r0,r1                 ;764
000068  db04              BLT      |L36.116|
00006a  4640              MOV      r0,r8                 ;765
00006c  f7fffffe          BL       OS_CPU_SR_Restore
000070  201e              MOVS     r0,#0x1e              ;766
000072  e7d0              B        |L36.22|
                  |L36.116|
000074  f0060002          AND      r0,r6,#2              ;768
000078  b158              CBZ      r0,|L36.146|
00007a  6861              LDR      r1,[r4,#4]            ;769
00007c  6920              LDR      r0,[r4,#0x10]         ;769
00007e  4288              CMP      r0,r1                 ;769
000080  d101              BNE      |L36.134|
000082  68a0              LDR      r0,[r4,#8]            ;770
000084  6120              STR      r0,[r4,#0x10]         ;770
                  |L36.134|
000086  6920              LDR      r0,[r4,#0x10]         ;772
000088  1f00              SUBS     r0,r0,#4              ;772
00008a  6120              STR      r0,[r4,#0x10]         ;772
00008c  6920              LDR      r0,[r4,#0x10]         ;773
00008e  6007              STR      r7,[r0,#0]            ;773
000090  e009              B        |L36.166|
                  |L36.146|
000092  68e1              LDR      r1,[r4,#0xc]          ;775
000094  1d08              ADDS     r0,r1,#4              ;775
000096  60e0              STR      r0,[r4,#0xc]          ;775
000098  600f              STR      r7,[r1,#0]            ;775
00009a  e9d41002          LDRD     r1,r0,[r4,#8]         ;776
00009e  4288              CMP      r0,r1                 ;776
0000a0  d101              BNE      |L36.166|
0000a2  6860              LDR      r0,[r4,#4]            ;777
0000a4  60e0              STR      r0,[r4,#0xc]          ;777
                  |L36.166|
0000a6  8ae0              LDRH     r0,[r4,#0x16]         ;780
0000a8  1c40              ADDS     r0,r0,#1              ;780
0000aa  82e0              STRH     r0,[r4,#0x16]         ;780
0000ac  4640              MOV      r0,r8                 ;781
0000ae  f7fffffe          BL       OS_CPU_SR_Restore
0000b2  2000              MOVS     r0,#0                 ;782
0000b4  e7af              B        |L36.22|
;;;784    #endif
                          ENDP


                          AREA ||i.OSQQuery||, CODE, READONLY, ALIGN=1

                  OSQQuery PROC
;;;804    #if OS_Q_QUERY_EN > 0u
;;;805    INT8U  OSQQuery (OS_EVENT  *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;806                     OS_Q_DATA *p_q_data)
;;;807    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;808        OS_Q       *pq;
;;;809        INT8U       i;
;;;810        OS_PRIO    *psrc;
;;;811        OS_PRIO    *pdest;
;;;812    #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
;;;813        OS_CPU_SR   cpu_sr = 0u;
000008  f04f0a00          MOV      r10,#0
;;;814    #endif
;;;815    
;;;816    
;;;817    
;;;818    #if OS_ARG_CHK_EN > 0u
;;;819        if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
;;;820            return (OS_ERR_PEVENT_NULL);
;;;821        }
;;;822        if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
;;;823            return (OS_ERR_PDATA_NULL);
;;;824        }
;;;825    #endif
;;;826        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
00000c  7828              LDRB     r0,[r5,#0]
00000e  2802              CMP      r0,#2
000010  d002              BEQ      |L37.24|
;;;827            return (OS_ERR_EVENT_TYPE);
000012  2001              MOVS     r0,#1
                  |L37.20|
;;;828        }
;;;829        OS_ENTER_CRITICAL();
;;;830        p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
;;;831        psrc                 = &pevent->OSEventTbl[0];
;;;832        pdest                = &p_q_data->OSEventTbl[0];
;;;833        for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
;;;834            *pdest++ = *psrc++;
;;;835        }
;;;836        pq = (OS_Q *)pevent->OSEventPtr;
;;;837        if (pq->OSQEntries > 0u) {
;;;838            p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
;;;839        } else {
;;;840            p_q_data->OSMsg = (void *)0;
;;;841        }
;;;842        p_q_data->OSNMsgs = pq->OSQEntries;
;;;843        p_q_data->OSQSize = pq->OSQSize;
;;;844        OS_EXIT_CRITICAL();
;;;845        return (OS_ERR_NONE);
;;;846    }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L37.24|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4682              MOV      r10,r0                ;829
00001e  7aa8              LDRB     r0,[r5,#0xa]          ;830
000020  7420              STRB     r0,[r4,#0x10]         ;830
000022  f105080b          ADD      r8,r5,#0xb            ;831
000026  f1040908          ADD      r9,r4,#8              ;832
00002a  2700              MOVS     r7,#0                 ;833
00002c  e005              B        |L37.58|
                  |L37.46|
00002e  f8180b01          LDRB     r0,[r8],#1            ;834
000032  f8090b01          STRB     r0,[r9],#1            ;834
000036  1c78              ADDS     r0,r7,#1              ;833
000038  b2c7              UXTB     r7,r0                 ;833
                  |L37.58|
00003a  2f08              CMP      r7,#8                 ;833
00003c  d3f7              BCC      |L37.46|
00003e  686e              LDR      r6,[r5,#4]            ;836
000040  8af0              LDRH     r0,[r6,#0x16]         ;837
000042  b118              CBZ      r0,|L37.76|
000044  6930              LDR      r0,[r6,#0x10]         ;838
000046  6800              LDR      r0,[r0,#0]            ;838
000048  6020              STR      r0,[r4,#0]            ;838
00004a  e001              B        |L37.80|
                  |L37.76|
00004c  2000              MOVS     r0,#0                 ;840
00004e  6020              STR      r0,[r4,#0]            ;840
                  |L37.80|
000050  8af0              LDRH     r0,[r6,#0x16]         ;842
000052  80a0              STRH     r0,[r4,#4]            ;842
000054  8ab0              LDRH     r0,[r6,#0x14]         ;843
000056  80e0              STRH     r0,[r4,#6]            ;843
000058  4650              MOV      r0,r10                ;844
00005a  f7fffffe          BL       OS_CPU_SR_Restore
00005e  2000              MOVS     r0,#0                 ;845
000060  e7d8              B        |L37.20|
;;;847    #endif                                                 /* OS_Q_QUERY_EN                                */
                          ENDP


                          AREA ||i.OSSchedLock||, CODE, READONLY, ALIGN=2

                  OSSchedLock PROC
;;;735    #if OS_SCHED_LOCK_EN > 0u
;;;736    void  OSSchedLock (void)
000000  b510              PUSH     {r4,lr}
;;;737    {
;;;738    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;739        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;740    #endif
;;;741    
;;;742    
;;;743    
;;;744        if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
000004  480b              LDR      r0,|L38.52|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d111              BNE      |L38.48|
;;;745            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;746            if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
000012  4809              LDR      r0,|L38.56|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  b940              CBNZ     r0,|L38.42|
;;;747                if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
000018  4808              LDR      r0,|L38.60|
00001a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00001c  28ff              CMP      r0,#0xff
00001e  d204              BCS      |L38.42|
;;;748                    OSLockNesting++;                 /* Increment lock nesting level                       */
000020  4806              LDR      r0,|L38.60|
000022  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000024  1c40              ADDS     r0,r0,#1
000026  4905              LDR      r1,|L38.60|
000028  7008              STRB     r0,[r1,#0]
                  |L38.42|
;;;749                }
;;;750            }
;;;751            OS_EXIT_CRITICAL();
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       OS_CPU_SR_Restore
                  |L38.48|
;;;752        }
;;;753    }
000030  bd10              POP      {r4,pc}
;;;754    #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L38.52|
                          DCD      OSRunning
                  |L38.56|
                          DCD      OSIntNesting
                  |L38.60|
                          DCD      OSLockNesting

                          AREA ||i.OSSchedUnlock||, CODE, READONLY, ALIGN=2

                  OSSchedUnlock PROC
;;;772    #if OS_SCHED_LOCK_EN > 0u
;;;773    void  OSSchedUnlock (void)
000000  b510              PUSH     {r4,lr}
;;;774    {
;;;775    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;776        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;777    #endif
;;;778    
;;;779    
;;;780    
;;;781        if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
000004  4813              LDR      r0,|L39.84|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d121              BNE      |L39.80|
;;;782            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;783            if (OSLockNesting > 0u) {                          /* Do not decrement if already 0            */
000012  4811              LDR      r0,|L39.88|
000014  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000016  b1c0              CBZ      r0,|L39.74|
;;;784                OSLockNesting--;                               /* Decrement lock nesting level             */
000018  480f              LDR      r0,|L39.88|
00001a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00001c  1e40              SUBS     r0,r0,#1
00001e  490e              LDR      r1,|L39.88|
000020  7008              STRB     r0,[r1,#0]
;;;785                if (OSLockNesting == 0u) {                     /* See if scheduler is enabled and ...      */
000022  4608              MOV      r0,r1
000024  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000026  b960              CBNZ     r0,|L39.66|
;;;786                    if (OSIntNesting == 0u) {                  /* ... not in an ISR                        */
000028  480c              LDR      r0,|L39.92|
00002a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00002c  b928              CBNZ     r0,|L39.58|
;;;787                        OS_EXIT_CRITICAL();
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       OS_CPU_SR_Restore
;;;788                        OS_Sched();                            /* See if a HPT is ready                    */
000034  f7fffffe          BL       OS_Sched
000038  e00a              B        |L39.80|
                  |L39.58|
;;;789                    } else {
;;;790                        OS_EXIT_CRITICAL();
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       OS_CPU_SR_Restore
000040  e006              B        |L39.80|
                  |L39.66|
;;;791                    }
;;;792                } else {
;;;793                    OS_EXIT_CRITICAL();
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  e002              B        |L39.80|
                  |L39.74|
;;;794                }
;;;795            } else {
;;;796                OS_EXIT_CRITICAL();
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       OS_CPU_SR_Restore
                  |L39.80|
;;;797            }
;;;798        }
;;;799    }
000050  bd10              POP      {r4,pc}
;;;800    #endif
                          ENDP

000052  0000              DCW      0x0000
                  |L39.84|
                          DCD      OSRunning
                  |L39.88|
                          DCD      OSLockNesting
                  |L39.92|
                          DCD      OSIntNesting

                          AREA ||i.OSSemAccept||, CODE, READONLY, ALIGN=1

                  OSSemAccept PROC
;;;48     #if OS_SEM_ACCEPT_EN > 0u
;;;49     INT16U  OSSemAccept (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;50     {
000002  4604              MOV      r4,r0
;;;51         INT16U     cnt;
;;;52     #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;53         OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;54     #endif
;;;55     
;;;56     
;;;57     
;;;58     #if OS_ARG_CHK_EN > 0u
;;;59         if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;60             return (0u);
;;;61         }
;;;62     #endif
;;;63         if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000006  7820              LDRB     r0,[r4,#0]
000008  2803              CMP      r0,#3
00000a  d001              BEQ      |L40.16|
;;;64             return (0u);
00000c  2000              MOVS     r0,#0
                  |L40.14|
;;;65         }
;;;66         OS_ENTER_CRITICAL();
;;;67         cnt = pevent->OSEventCnt;
;;;68         if (cnt > 0u) {                                   /* See if resource is available                  */
;;;69             pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
;;;70         }
;;;71         OS_EXIT_CRITICAL();
;;;72         return (cnt);                                     /* Return semaphore count                        */
;;;73     }
00000e  bd70              POP      {r4-r6,pc}
                  |L40.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4606              MOV      r6,r0                 ;66
000016  8925              LDRH     r5,[r4,#8]            ;67
000018  b115              CBZ      r5,|L40.32|
00001a  8920              LDRH     r0,[r4,#8]            ;69
00001c  1e40              SUBS     r0,r0,#1              ;69
00001e  8120              STRH     r0,[r4,#8]            ;69
                  |L40.32|
000020  4630              MOV      r0,r6                 ;71
000022  f7fffffe          BL       OS_CPU_SR_Restore
000026  4628              MOV      r0,r5                 ;72
000028  e7f1              B        |L40.14|
;;;74     #endif
                          ENDP


                          AREA ||i.OSSemCreate||, CODE, READONLY, ALIGN=2

                  OSSemCreate PROC
;;;93     
;;;94     OS_EVENT  *OSSemCreate (INT16U cnt)
000000  b570              PUSH     {r4-r6,lr}
;;;95     {
000002  4605              MOV      r5,r0
;;;96         OS_EVENT  *pevent;
;;;97     #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;98         OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;99     #endif
;;;100    
;;;101    
;;;102    
;;;103    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;104        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;105            OS_SAFETY_CRITICAL_EXCEPTION();
;;;106        }
;;;107    #endif
;;;108    
;;;109        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000006  480f              LDR      r0,|L41.68|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000a  b108              CBZ      r0,|L41.16|
;;;110            return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
00000c  2000              MOVS     r0,#0
                  |L41.14|
;;;111        }
;;;112        OS_ENTER_CRITICAL();
;;;113        pevent = OSEventFreeList;                              /* Get next free event control block        */
;;;114        if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
;;;115            OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
;;;116        }
;;;117        OS_EXIT_CRITICAL();
;;;118        if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
;;;119            pevent->OSEventType    = OS_EVENT_TYPE_SEM;
;;;120            pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
;;;121            pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
;;;122    #if OS_EVENT_NAME_EN > 0u
;;;123            pevent->OSEventName    = (INT8U *)(void *)"?";
;;;124    #endif
;;;125            OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
;;;126        }
;;;127        return (pevent);
;;;128    }
00000e  bd70              POP      {r4-r6,pc}
                  |L41.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4606              MOV      r6,r0                 ;112
000016  480c              LDR      r0,|L41.72|
000018  6804              LDR      r4,[r0,#0]            ;113  ; OSEventFreeList
00001a  6800              LDR      r0,[r0,#0]            ;114  ; OSEventFreeList
00001c  b120              CBZ      r0,|L41.40|
00001e  480a              LDR      r0,|L41.72|
000020  6800              LDR      r0,[r0,#0]            ;115  ; OSEventFreeList
000022  6840              LDR      r0,[r0,#4]            ;115
000024  4908              LDR      r1,|L41.72|
000026  6008              STR      r0,[r1,#0]            ;115  ; OSEventFreeList
                  |L41.40|
000028  4630              MOV      r0,r6                 ;117
00002a  f7fffffe          BL       OS_CPU_SR_Restore
00002e  b13c              CBZ      r4,|L41.64|
000030  2003              MOVS     r0,#3                 ;119
000032  7020              STRB     r0,[r4,#0]            ;119
000034  8125              STRH     r5,[r4,#8]            ;120
000036  2000              MOVS     r0,#0                 ;121
000038  6060              STR      r0,[r4,#4]            ;121
00003a  4620              MOV      r0,r4                 ;125
00003c  f7fffffe          BL       OS_EventWaitListInit
                  |L41.64|
000040  4620              MOV      r0,r4                 ;127
000042  e7e4              B        |L41.14|
;;;129    
                          ENDP

                  |L41.68|
                          DCD      OSIntNesting
                  |L41.72|
                          DCD      OSEventFreeList

                          AREA ||i.OSSemDel||, CODE, READONLY, ALIGN=2

                  OSSemDel PROC
;;;168    #if OS_SEM_DEL_EN > 0u
;;;169    OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;170                         INT8U      opt,
;;;171                         INT8U     *perr)
;;;172    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;173        BOOLEAN    tasks_waiting;
;;;174        OS_EVENT  *pevent_return;
;;;175    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;176        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0900          MOV      r9,#0
;;;177    #endif
;;;178    
;;;179    
;;;180    
;;;181    #ifdef OS_SAFETY_CRITICAL
;;;182        if (perr == (INT8U *)0) {
;;;183            OS_SAFETY_CRITICAL_EXCEPTION();
;;;184        }
;;;185    #endif
;;;186    
;;;187    #if OS_ARG_CHK_EN > 0u
;;;188        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;189            *perr = OS_ERR_PEVENT_NULL;
;;;190            return (pevent);
;;;191        }
;;;192    #endif
;;;193        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00000e  7820              LDRB     r0,[r4,#0]
000010  2803              CMP      r0,#3
000012  d004              BEQ      |L42.30|
;;;194            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;195            return (pevent);
000018  4620              MOV      r0,r4
                  |L42.26|
;;;196        }
;;;197        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
;;;198            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
;;;199            return (pevent);
;;;200        }
;;;201        OS_ENTER_CRITICAL();
;;;202        if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
;;;203            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;204        } else {
;;;205            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;206        }
;;;207        switch (opt) {
;;;208            case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
;;;209                 if (tasks_waiting == OS_FALSE) {
;;;210    #if OS_EVENT_NAME_EN > 0u
;;;211                     pevent->OSEventName    = (INT8U *)(void *)"?";
;;;212    #endif
;;;213                     pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;214                     pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
;;;215                     pevent->OSEventCnt     = 0u;
;;;216                     OSEventFreeList        = pevent;          /* Get next free event control block        */
;;;217                     OS_EXIT_CRITICAL();
;;;218                     *perr                  = OS_ERR_NONE;
;;;219                     pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
;;;220                 } else {
;;;221                     OS_EXIT_CRITICAL();
;;;222                     *perr                  = OS_ERR_TASK_WAITING;
;;;223                     pevent_return          = pevent;
;;;224                 }
;;;225                 break;
;;;226    
;;;227            case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
;;;228                 while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
;;;229                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
;;;230                 }
;;;231    #if OS_EVENT_NAME_EN > 0u
;;;232                 pevent->OSEventName    = (INT8U *)(void *)"?";
;;;233    #endif
;;;234                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;235                 pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
;;;236                 pevent->OSEventCnt     = 0u;
;;;237                 OSEventFreeList        = pevent;              /* Get next free event control block        */
;;;238                 OS_EXIT_CRITICAL();
;;;239                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;240                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;241                 }
;;;242                 *perr                  = OS_ERR_NONE;
;;;243                 pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
;;;244                 break;
;;;245    
;;;246            default:
;;;247                 OS_EXIT_CRITICAL();
;;;248                 *perr                  = OS_ERR_INVALID_OPT;
;;;249                 pevent_return          = pevent;
;;;250                 break;
;;;251        }
;;;252        return (pevent_return);
;;;253    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L42.30|
00001e  482a              LDR      r0,|L42.200|
000020  7800              LDRB     r0,[r0,#0]            ;197  ; OSIntNesting
000022  b118              CBZ      r0,|L42.44|
000024  200f              MOVS     r0,#0xf               ;198
000026  7028              STRB     r0,[r5,#0]            ;198
000028  4620              MOV      r0,r4                 ;199
00002a  e7f6              B        |L42.26|
                  |L42.44|
00002c  f7fffffe          BL       OS_CPU_SR_Save
000030  4681              MOV      r9,r0                 ;201
000032  7aa0              LDRB     r0,[r4,#0xa]          ;202
000034  b108              CBZ      r0,|L42.58|
000036  2701              MOVS     r7,#1                 ;203
000038  e000              B        |L42.60|
                  |L42.58|
00003a  2700              MOVS     r7,#0                 ;205
                  |L42.60|
00003c  f1b80f00          CMP      r8,#0                 ;207
000040  d003              BEQ      |L42.74|
000042  f1b80f01          CMP      r8,#1                 ;207
000046  d135              BNE      |L42.180|
000048  e017              B        |L42.122|
                  |L42.74|
00004a  b97f              CBNZ     r7,|L42.108|
00004c  2000              MOVS     r0,#0                 ;213
00004e  7020              STRB     r0,[r4,#0]            ;213
000050  481e              LDR      r0,|L42.204|
000052  6800              LDR      r0,[r0,#0]            ;214  ; OSEventFreeList
000054  6060              STR      r0,[r4,#4]            ;214
000056  2000              MOVS     r0,#0                 ;215
000058  8120              STRH     r0,[r4,#8]            ;215
00005a  481c              LDR      r0,|L42.204|
00005c  6004              STR      r4,[r0,#0]            ;216  ; OSEventFreeList
00005e  4648              MOV      r0,r9                 ;217
000060  f7fffffe          BL       OS_CPU_SR_Restore
000064  2000              MOVS     r0,#0                 ;218
000066  7028              STRB     r0,[r5,#0]            ;218
000068  2600              MOVS     r6,#0                 ;219
00006a  e005              B        |L42.120|
                  |L42.108|
00006c  4648              MOV      r0,r9                 ;221
00006e  f7fffffe          BL       OS_CPU_SR_Restore
000072  2049              MOVS     r0,#0x49              ;222
000074  7028              STRB     r0,[r5,#0]            ;222
000076  4626              MOV      r6,r4                 ;223
                  |L42.120|
000078  e023              B        |L42.194|
                  |L42.122|
00007a  e005              B        |L42.136|
                  |L42.124|
00007c  2300              MOVS     r3,#0                 ;229
00007e  2201              MOVS     r2,#1                 ;229
000080  4619              MOV      r1,r3                 ;229
000082  4620              MOV      r0,r4                 ;229
000084  f7fffffe          BL       OS_EventTaskRdy
                  |L42.136|
000088  7aa0              LDRB     r0,[r4,#0xa]          ;228
00008a  2800              CMP      r0,#0                 ;228
00008c  d1f6              BNE      |L42.124|
00008e  7020              STRB     r0,[r4,#0]            ;234
000090  480e              LDR      r0,|L42.204|
000092  6800              LDR      r0,[r0,#0]            ;235  ; OSEventFreeList
000094  6060              STR      r0,[r4,#4]            ;235
000096  2000              MOVS     r0,#0                 ;236
000098  8120              STRH     r0,[r4,#8]            ;236
00009a  480c              LDR      r0,|L42.204|
00009c  6004              STR      r4,[r0,#0]            ;237  ; OSEventFreeList
00009e  4648              MOV      r0,r9                 ;238
0000a0  f7fffffe          BL       OS_CPU_SR_Restore
0000a4  2f01              CMP      r7,#1                 ;239
0000a6  d101              BNE      |L42.172|
0000a8  f7fffffe          BL       OS_Sched
                  |L42.172|
0000ac  2000              MOVS     r0,#0                 ;242
0000ae  7028              STRB     r0,[r5,#0]            ;242
0000b0  2600              MOVS     r6,#0                 ;243
0000b2  e006              B        |L42.194|
                  |L42.180|
0000b4  4648              MOV      r0,r9                 ;247
0000b6  f7fffffe          BL       OS_CPU_SR_Restore
0000ba  2007              MOVS     r0,#7                 ;248
0000bc  7028              STRB     r0,[r5,#0]            ;248
0000be  4626              MOV      r6,r4                 ;249
0000c0  bf00              NOP                            ;250
                  |L42.194|
0000c2  bf00              NOP                            ;225
0000c4  4630              MOV      r0,r6                 ;252
0000c6  e7a8              B        |L42.26|
;;;254    #endif
                          ENDP

                  |L42.200|
                          DCD      OSIntNesting
                  |L42.204|
                          DCD      OSEventFreeList

                          AREA ||i.OSSemPend||, CODE, READONLY, ALIGN=2

                  OSSemPend PROC
;;;288    /*$PAGE*/
;;;289    void  OSSemPend (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;290                     INT32U     timeout,
;;;291                     INT8U     *perr)
;;;292    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;293    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;294        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;295    #endif
;;;296    
;;;297    
;;;298    
;;;299    #ifdef OS_SAFETY_CRITICAL
;;;300        if (perr == (INT8U *)0) {
;;;301            OS_SAFETY_CRITICAL_EXCEPTION();
;;;302        }
;;;303    #endif
;;;304    
;;;305    #if OS_ARG_CHK_EN > 0u
;;;306        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;307            *perr = OS_ERR_PEVENT_NULL;
;;;308            return;
;;;309        }
;;;310    #endif
;;;311        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00000c  7828              LDRB     r0,[r5,#0]
00000e  2803              CMP      r0,#3
000010  d003              BEQ      |L43.26|
;;;312            *perr = OS_ERR_EVENT_TYPE;
000012  2001              MOVS     r0,#1
000014  7020              STRB     r0,[r4,#0]
                  |L43.22|
;;;313            return;
;;;314        }
;;;315        if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
;;;316            *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
;;;317            return;
;;;318        }
;;;319        if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
;;;320            *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
;;;321            return;
;;;322        }
;;;323        OS_ENTER_CRITICAL();
;;;324        if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
;;;325            pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
;;;326            OS_EXIT_CRITICAL();
;;;327            *perr = OS_ERR_NONE;
;;;328            return;
;;;329        }
;;;330                                                          /* Otherwise, must wait until event occurs       */
;;;331        OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
;;;332        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;333        OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
;;;334        OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
;;;335        OS_EXIT_CRITICAL();
;;;336        OS_Sched();                                       /* Find next highest priority task ready         */
;;;337        OS_ENTER_CRITICAL();
;;;338        switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
;;;339            case OS_STAT_PEND_OK:
;;;340                 *perr = OS_ERR_NONE;
;;;341                 break;
;;;342    
;;;343            case OS_STAT_PEND_ABORT:
;;;344                 *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
;;;345                 break;
;;;346    
;;;347            case OS_STAT_PEND_TO:
;;;348            default:
;;;349                 OS_EventTaskRemove(OSTCBCur, pevent);
;;;350                 *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
;;;351                 break;
;;;352        }
;;;353        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
;;;354        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
;;;355        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
;;;356    #if (OS_EVENT_MULTI_EN > 0u)
;;;357        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;358    #endif
;;;359        OS_EXIT_CRITICAL();
;;;360    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L43.26|
00001a  4831              LDR      r0,|L43.224|
00001c  7800              LDRB     r0,[r0,#0]            ;315  ; OSIntNesting
00001e  b110              CBZ      r0,|L43.38|
000020  2002              MOVS     r0,#2                 ;316
000022  7020              STRB     r0,[r4,#0]            ;316
000024  e7f7              B        |L43.22|
                  |L43.38|
000026  482f              LDR      r0,|L43.228|
000028  7800              LDRB     r0,[r0,#0]            ;319  ; OSLockNesting
00002a  b110              CBZ      r0,|L43.50|
00002c  200d              MOVS     r0,#0xd               ;320
00002e  7020              STRB     r0,[r4,#0]            ;320
000030  e7f1              B        |L43.22|
                  |L43.50|
000032  f7fffffe          BL       OS_CPU_SR_Save
000036  4607              MOV      r7,r0                 ;323
000038  8928              LDRH     r0,[r5,#8]            ;324
00003a  b140              CBZ      r0,|L43.78|
00003c  8928              LDRH     r0,[r5,#8]            ;325
00003e  1e40              SUBS     r0,r0,#1              ;325
000040  8128              STRH     r0,[r5,#8]            ;325
000042  4638              MOV      r0,r7                 ;326
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  2000              MOVS     r0,#0                 ;327
00004a  7020              STRB     r0,[r4,#0]            ;327
00004c  e7e3              B        |L43.22|
                  |L43.78|
00004e  4826              LDR      r0,|L43.232|
000050  6800              LDR      r0,[r0,#0]            ;331  ; OSTCBCur
000052  f8900030          LDRB     r0,[r0,#0x30]         ;331
000056  f0400001          ORR      r0,r0,#1              ;331
00005a  4923              LDR      r1,|L43.232|
00005c  6809              LDR      r1,[r1,#0]            ;331  ; OSTCBCur
00005e  f8810030          STRB     r0,[r1,#0x30]         ;331
000062  2000              MOVS     r0,#0                 ;332
000064  4920              LDR      r1,|L43.232|
000066  6809              LDR      r1,[r1,#0]            ;332  ; OSTCBCur
000068  f8810031          STRB     r0,[r1,#0x31]         ;332
00006c  481e              LDR      r0,|L43.232|
00006e  6800              LDR      r0,[r0,#0]            ;333  ; OSTCBCur
000070  62c6              STR      r6,[r0,#0x2c]         ;333
000072  4628              MOV      r0,r5                 ;334
000074  f7fffffe          BL       OS_EventTaskWait
000078  4638              MOV      r0,r7                 ;335
00007a  f7fffffe          BL       OS_CPU_SR_Restore
00007e  f7fffffe          BL       OS_Sched
000082  f7fffffe          BL       OS_CPU_SR_Save
000086  4607              MOV      r7,r0                 ;337
000088  4817              LDR      r0,|L43.232|
00008a  6800              LDR      r0,[r0,#0]            ;338  ; OSTCBCur
00008c  f8900031          LDRB     r0,[r0,#0x31]         ;338
000090  b120              CBZ      r0,|L43.156|
000092  2801              CMP      r0,#1                 ;338
000094  d009              BEQ      |L43.170|
000096  2802              CMP      r0,#2                 ;338
000098  d106              BNE      |L43.168|
00009a  e002              B        |L43.162|
                  |L43.156|
00009c  2000              MOVS     r0,#0                 ;340
00009e  7020              STRB     r0,[r4,#0]            ;340
0000a0  e00b              B        |L43.186|
                  |L43.162|
0000a2  200e              MOVS     r0,#0xe               ;344
0000a4  7020              STRB     r0,[r4,#0]            ;344
0000a6  e008              B        |L43.186|
                  |L43.168|
0000a8  bf00              NOP                            ;347
                  |L43.170|
0000aa  4629              MOV      r1,r5                 ;349
0000ac  480e              LDR      r0,|L43.232|
0000ae  6800              LDR      r0,[r0,#0]            ;349  ; OSTCBCur
0000b0  f7fffffe          BL       OS_EventTaskRemove
0000b4  200a              MOVS     r0,#0xa               ;350
0000b6  7020              STRB     r0,[r4,#0]            ;350
0000b8  bf00              NOP                            ;351
                  |L43.186|
0000ba  bf00              NOP                            ;341
0000bc  2000              MOVS     r0,#0                 ;353
0000be  490a              LDR      r1,|L43.232|
0000c0  6809              LDR      r1,[r1,#0]            ;353  ; OSTCBCur
0000c2  f8810030          STRB     r0,[r1,#0x30]         ;353
0000c6  4908              LDR      r1,|L43.232|
0000c8  6809              LDR      r1,[r1,#0]            ;354  ; OSTCBCur
0000ca  f8810031          STRB     r0,[r1,#0x31]         ;354
0000ce  4906              LDR      r1,|L43.232|
0000d0  6809              LDR      r1,[r1,#0]            ;355  ; OSTCBCur
0000d2  61c8              STR      r0,[r1,#0x1c]         ;355
0000d4  4638              MOV      r0,r7                 ;359
0000d6  f7fffffe          BL       OS_CPU_SR_Restore
0000da  bf00              NOP      
0000dc  e79b              B        |L43.22|
;;;361    
                          ENDP

0000de  0000              DCW      0x0000
                  |L43.224|
                          DCD      OSIntNesting
                  |L43.228|
                          DCD      OSLockNesting
                  |L43.232|
                          DCD      OSTCBCur

                          AREA ||i.OSSemPendAbort||, CODE, READONLY, ALIGN=1

                  OSSemPendAbort PROC
;;;396    #if OS_SEM_PEND_ABORT_EN > 0u
;;;397    INT8U  OSSemPendAbort (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;398                           INT8U      opt,
;;;399                           INT8U     *perr)
;;;400    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;401        INT8U      nbr_tasks;
;;;402    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;403        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;404    #endif
;;;405    
;;;406    
;;;407    
;;;408    #ifdef OS_SAFETY_CRITICAL
;;;409        if (perr == (INT8U *)0) {
;;;410            OS_SAFETY_CRITICAL_EXCEPTION();
;;;411        }
;;;412    #endif
;;;413    
;;;414    #if OS_ARG_CHK_EN > 0u
;;;415        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;416            *perr = OS_ERR_PEVENT_NULL;
;;;417            return (0u);
;;;418        }
;;;419    #endif
;;;420        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00000e  7820              LDRB     r0,[r4,#0]
000010  2803              CMP      r0,#3
000012  d004              BEQ      |L44.30|
;;;421            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;422            return (0u);
000018  2000              MOVS     r0,#0
                  |L44.26|
;;;423        }
;;;424        OS_ENTER_CRITICAL();
;;;425        if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
;;;426            nbr_tasks = 0u;
;;;427            switch (opt) {
;;;428                case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
;;;429                     while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
;;;430                         (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
;;;431                         nbr_tasks++;
;;;432                     }
;;;433                     break;
;;;434    
;;;435                case OS_PEND_OPT_NONE:
;;;436                default:                                  /* No,  ready HPT       waiting on semaphore     */
;;;437                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
;;;438                     nbr_tasks++;
;;;439                     break;
;;;440            }
;;;441            OS_EXIT_CRITICAL();
;;;442            OS_Sched();                                   /* Find HPT ready to run                         */
;;;443            *perr = OS_ERR_PEND_ABORT;
;;;444            return (nbr_tasks);
;;;445        }
;;;446        OS_EXIT_CRITICAL();
;;;447        *perr = OS_ERR_NONE;
;;;448        return (0u);                                      /* No tasks waiting on semaphore                 */
;;;449    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L44.30|
00001e  f7fffffe          BL       OS_CPU_SR_Save
000022  4680              MOV      r8,r0                 ;424
000024  7aa0              LDRB     r0,[r4,#0xa]          ;425
000026  b320              CBZ      r0,|L44.114|
000028  2600              MOVS     r6,#0                 ;426
00002a  b17f              CBZ      r7,|L44.76|
00002c  2f01              CMP      r7,#1                 ;427
00002e  d10c              BNE      |L44.74|
000030  e007              B        |L44.66|
                  |L44.50|
000032  2302              MOVS     r3,#2                 ;430
000034  2201              MOVS     r2,#1                 ;430
000036  2100              MOVS     r1,#0                 ;430
000038  4620              MOV      r0,r4                 ;430
00003a  f7fffffe          BL       OS_EventTaskRdy
00003e  1c70              ADDS     r0,r6,#1              ;431
000040  b2c6              UXTB     r6,r0                 ;431
                  |L44.66|
000042  7aa0              LDRB     r0,[r4,#0xa]          ;429
000044  2800              CMP      r0,#0                 ;429
000046  d1f4              BNE      |L44.50|
000048  e009              B        |L44.94|
                  |L44.74|
00004a  bf00              NOP                            ;435
                  |L44.76|
00004c  2302              MOVS     r3,#2                 ;437
00004e  2201              MOVS     r2,#1                 ;437
000050  2100              MOVS     r1,#0                 ;437
000052  4620              MOV      r0,r4                 ;437
000054  f7fffffe          BL       OS_EventTaskRdy
000058  1c70              ADDS     r0,r6,#1              ;438
00005a  b2c6              UXTB     r6,r0                 ;438
00005c  bf00              NOP                            ;439
                  |L44.94|
00005e  bf00              NOP                            ;433
000060  4640              MOV      r0,r8                 ;441
000062  f7fffffe          BL       OS_CPU_SR_Restore
000066  f7fffffe          BL       OS_Sched
00006a  200e              MOVS     r0,#0xe               ;443
00006c  7028              STRB     r0,[r5,#0]            ;443
00006e  4630              MOV      r0,r6                 ;444
000070  e7d3              B        |L44.26|
                  |L44.114|
000072  4640              MOV      r0,r8                 ;446
000074  f7fffffe          BL       OS_CPU_SR_Restore
000078  2000              MOVS     r0,#0                 ;447
00007a  7028              STRB     r0,[r5,#0]            ;447
00007c  bf00              NOP                            ;448
00007e  e7cc              B        |L44.26|
;;;450    #endif
                          ENDP


                          AREA ||i.OSSemPost||, CODE, READONLY, ALIGN=1

                  OSSemPost PROC
;;;470    
;;;471    INT8U  OSSemPost (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;472    {
000002  4604              MOV      r4,r0
;;;473    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;474        OS_CPU_SR  cpu_sr = 0u;
000004  2500              MOVS     r5,#0
;;;475    #endif
;;;476    
;;;477    
;;;478    
;;;479    #if OS_ARG_CHK_EN > 0u
;;;480        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;481            return (OS_ERR_PEVENT_NULL);
;;;482        }
;;;483    #endif
;;;484        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000006  7820              LDRB     r0,[r4,#0]
000008  2803              CMP      r0,#3
00000a  d001              BEQ      |L45.16|
;;;485            return (OS_ERR_EVENT_TYPE);
00000c  2001              MOVS     r0,#1
                  |L45.14|
;;;486        }
;;;487        OS_ENTER_CRITICAL();
;;;488        if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
;;;489                                                          /* Ready HPT waiting on event                    */
;;;490            (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
;;;491            OS_EXIT_CRITICAL();
;;;492            OS_Sched();                                   /* Find HPT ready to run                         */
;;;493            return (OS_ERR_NONE);
;;;494        }
;;;495        if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
;;;496            pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
;;;497            OS_EXIT_CRITICAL();
;;;498            return (OS_ERR_NONE);
;;;499        }
;;;500        OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
;;;501        return (OS_ERR_SEM_OVF);
;;;502    }
00000e  bd70              POP      {r4-r6,pc}
                  |L45.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4605              MOV      r5,r0                 ;487
000016  7aa0              LDRB     r0,[r4,#0xa]          ;488
000018  b160              CBZ      r0,|L45.52|
00001a  2300              MOVS     r3,#0                 ;490
00001c  2201              MOVS     r2,#1                 ;490
00001e  4619              MOV      r1,r3                 ;490
000020  4620              MOV      r0,r4                 ;490
000022  f7fffffe          BL       OS_EventTaskRdy
000026  4628              MOV      r0,r5                 ;491
000028  f7fffffe          BL       OS_CPU_SR_Restore
00002c  f7fffffe          BL       OS_Sched
000030  2000              MOVS     r0,#0                 ;493
000032  e7ec              B        |L45.14|
                  |L45.52|
000034  8920              LDRH     r0,[r4,#8]            ;495
000036  f64f71ff          MOV      r1,#0xffff            ;495
00003a  4288              CMP      r0,r1                 ;495
00003c  d207              BCS      |L45.78|
00003e  8920              LDRH     r0,[r4,#8]            ;496
000040  1c40              ADDS     r0,r0,#1              ;496
000042  8120              STRH     r0,[r4,#8]            ;496
000044  4628              MOV      r0,r5                 ;497
000046  f7fffffe          BL       OS_CPU_SR_Restore
00004a  2000              MOVS     r0,#0                 ;498
00004c  e7df              B        |L45.14|
                  |L45.78|
00004e  4628              MOV      r0,r5                 ;500
000050  f7fffffe          BL       OS_CPU_SR_Restore
000054  2033              MOVS     r0,#0x33              ;501
000056  e7da              B        |L45.14|
;;;503    
                          ENDP


                          AREA ||i.OSSemQuery||, CODE, READONLY, ALIGN=1

                  OSSemQuery PROC
;;;524    #if OS_SEM_QUERY_EN > 0u
;;;525    INT8U  OSSemQuery (OS_EVENT     *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;526                       OS_SEM_DATA  *p_sem_data)
;;;527    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;528        INT8U       i;
;;;529        OS_PRIO    *psrc;
;;;530        OS_PRIO    *pdest;
;;;531    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;532        OS_CPU_SR   cpu_sr = 0u;
000008  f04f0900          MOV      r9,#0
;;;533    #endif
;;;534    
;;;535    
;;;536    
;;;537    #if OS_ARG_CHK_EN > 0u
;;;538        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;539            return (OS_ERR_PEVENT_NULL);
;;;540        }
;;;541        if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
;;;542            return (OS_ERR_PDATA_NULL);
;;;543        }
;;;544    #endif
;;;545        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00000c  7820              LDRB     r0,[r4,#0]
00000e  2803              CMP      r0,#3
000010  d002              BEQ      |L46.24|
;;;546            return (OS_ERR_EVENT_TYPE);
000012  2001              MOVS     r0,#1
                  |L46.20|
;;;547        }
;;;548        OS_ENTER_CRITICAL();
;;;549        p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
;;;550        psrc                   = &pevent->OSEventTbl[0];
;;;551        pdest                  = &p_sem_data->OSEventTbl[0];
;;;552        for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
;;;553            *pdest++ = *psrc++;
;;;554        }
;;;555        p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
;;;556        OS_EXIT_CRITICAL();
;;;557        return (OS_ERR_NONE);
;;;558    }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L46.24|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4681              MOV      r9,r0                 ;548
00001e  7aa0              LDRB     r0,[r4,#0xa]          ;549
000020  72a8              STRB     r0,[r5,#0xa]          ;549
000022  f104070b          ADD      r7,r4,#0xb            ;550
000026  f1050802          ADD      r8,r5,#2              ;551
00002a  2600              MOVS     r6,#0                 ;552
00002c  e005              B        |L46.58|
                  |L46.46|
00002e  f8170b01          LDRB     r0,[r7],#1            ;553
000032  f8080b01          STRB     r0,[r8],#1            ;553
000036  1c70              ADDS     r0,r6,#1              ;552
000038  b2c6              UXTB     r6,r0                 ;552
                  |L46.58|
00003a  2e08              CMP      r6,#8                 ;552
00003c  d3f7              BCC      |L46.46|
00003e  8920              LDRH     r0,[r4,#8]            ;555
000040  8028              STRH     r0,[r5,#0]            ;555
000042  4648              MOV      r0,r9                 ;556
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  2000              MOVS     r0,#0                 ;557
00004a  e7e3              B        |L46.20|
;;;559    #endif                                                     /* OS_SEM_QUERY_EN                          */
                          ENDP


                          AREA ||i.OSSemSet||, CODE, READONLY, ALIGN=1

                  OSSemSet PROC
;;;586    #if OS_SEM_SET_EN > 0u
;;;587    void  OSSemSet (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;588                    INT16U     cnt,
;;;589                    INT8U     *perr)
;;;590    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;591    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;592        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;593    #endif
;;;594    
;;;595    
;;;596    
;;;597    #ifdef OS_SAFETY_CRITICAL
;;;598        if (perr == (INT8U *)0) {
;;;599            OS_SAFETY_CRITICAL_EXCEPTION();
;;;600        }
;;;601    #endif
;;;602    
;;;603    #if OS_ARG_CHK_EN > 0u
;;;604        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;605            *perr = OS_ERR_PEVENT_NULL;
;;;606            return;
;;;607        }
;;;608    #endif
;;;609        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00000c  7820              LDRB     r0,[r4,#0]
00000e  2803              CMP      r0,#3
000010  d003              BEQ      |L47.26|
;;;610            *perr = OS_ERR_EVENT_TYPE;
000012  2001              MOVS     r0,#1
000014  7028              STRB     r0,[r5,#0]
                  |L47.22|
;;;611            return;
;;;612        }
;;;613        OS_ENTER_CRITICAL();
;;;614        *perr = OS_ERR_NONE;
;;;615        if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
;;;616            pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
;;;617        } else {                                          /* No                                            */
;;;618            if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
;;;619                pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
;;;620            } else {
;;;621                *perr              = OS_ERR_TASK_WAITING;
;;;622            }
;;;623        }
;;;624        OS_EXIT_CRITICAL();
;;;625    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L47.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;613
000020  2000              MOVS     r0,#0                 ;614
000022  7028              STRB     r0,[r5,#0]            ;614
000024  8920              LDRH     r0,[r4,#8]            ;615
000026  b108              CBZ      r0,|L47.44|
000028  8126              STRH     r6,[r4,#8]            ;616
00002a  e005              B        |L47.56|
                  |L47.44|
00002c  7aa0              LDRB     r0,[r4,#0xa]          ;618
00002e  b908              CBNZ     r0,|L47.52|
000030  8126              STRH     r6,[r4,#8]            ;619
000032  e001              B        |L47.56|
                  |L47.52|
000034  2049              MOVS     r0,#0x49              ;621
000036  7028              STRB     r0,[r5,#0]            ;621
                  |L47.56|
000038  4638              MOV      r0,r7                 ;624
00003a  f7fffffe          BL       OS_CPU_SR_Restore
00003e  bf00              NOP      
000040  e7e9              B        |L47.22|
;;;626    #endif
                          ENDP


                          AREA ||i.OSStart||, CODE, READONLY, ALIGN=2

                  OSStart PROC
;;;822    
;;;823    void  OSStart (void)
000000  b510              PUSH     {r4,lr}
;;;824    {
;;;825        if (OSRunning == OS_FALSE) {
000002  480b              LDR      r0,|L48.48|
000004  7800              LDRB     r0,[r0,#0]  ; OSRunning
000006  b990              CBNZ     r0,|L48.46|
;;;826            OS_SchedNew();                               /* Find highest priority's task priority number   */
000008  f7fffffe          BL       OS_SchedNew
;;;827            OSPrioCur     = OSPrioHighRdy;
00000c  4809              LDR      r0,|L48.52|
00000e  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000010  4909              LDR      r1,|L48.56|
000012  7008              STRB     r0,[r1,#0]
;;;828            OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
000014  4809              LDR      r0,|L48.60|
000016  4907              LDR      r1,|L48.52|
000018  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
00001a  f8500021          LDR      r0,[r0,r1,LSL #2]
00001e  4908              LDR      r1,|L48.64|
000020  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;829            OSTCBCur      = OSTCBHighRdy;
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000026  4907              LDR      r1,|L48.68|
000028  6008              STR      r0,[r1,#0]  ; OSTCBCur
;;;830            OSStartHighRdy();                            /* Execute target specific code to start task     */
00002a  f7fffffe          BL       OSStartHighRdy
                  |L48.46|
;;;831        }
;;;832    }
00002e  bd10              POP      {r4,pc}
;;;833    /*$PAGE*/
                          ENDP

                  |L48.48|
                          DCD      OSRunning
                  |L48.52|
                          DCD      OSPrioHighRdy
                  |L48.56|
                          DCD      OSPrioCur
                  |L48.60|
                          DCD      OSTCBPrioTbl
                  |L48.64|
                          DCD      OSTCBHighRdy
                  |L48.68|
                          DCD      OSTCBCur

                          AREA ||i.OSStatInit||, CODE, READONLY, ALIGN=2

                  OSStatInit PROC
;;;854    #if OS_TASK_STAT_EN > 0u
;;;855    void  OSStatInit (void)
000000  b510              PUSH     {r4,lr}
;;;856    {
;;;857    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;858        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;859    #endif
;;;860    
;;;861    
;;;862    
;;;863        OSTimeDly(2u);                               /* Synchronize with clock tick                        */
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       OSTimeDly
;;;864        OS_ENTER_CRITICAL();
00000a  f7fffffe          BL       OS_CPU_SR_Save
00000e  4604              MOV      r4,r0
;;;865        OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
000010  2000              MOVS     r0,#0
000012  490b              LDR      r1,|L49.64|
000014  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;866        OS_EXIT_CRITICAL();
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       OS_CPU_SR_Restore
;;;867        OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
00001c  2014              MOVS     r0,#0x14
00001e  f7fffffe          BL       OSTimeDly
;;;868        OS_ENTER_CRITICAL();
000022  f7fffffe          BL       OS_CPU_SR_Save
000026  4604              MOV      r4,r0
;;;869        OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
000028  4805              LDR      r0,|L49.64|
00002a  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
00002c  4905              LDR      r1,|L49.68|
00002e  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;870        OSStatRdy    = OS_TRUE;
000030  2001              MOVS     r0,#1
000032  4905              LDR      r1,|L49.72|
000034  7008              STRB     r0,[r1,#0]
;;;871        OS_EXIT_CRITICAL();
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       OS_CPU_SR_Restore
;;;872    }
00003c  bd10              POP      {r4,pc}
;;;873    #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L49.64|
                          DCD      OSIdleCtr
                  |L49.68|
                          DCD      OSIdleCtrMax
                  |L49.72|
                          DCD      OSStatRdy

                          AREA ||i.OSTaskChangePrio||, CODE, READONLY, ALIGN=2

                  OSTaskChangePrio PROC
;;;50     #if OS_TASK_CHANGE_PRIO_EN > 0u
;;;51     INT8U  OSTaskChangePrio (INT8U  oldprio,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;52                              INT8U  newprio)
;;;53     {
000004  4681              MOV      r9,r0
000006  4688              MOV      r8,r1
;;;54     #if (OS_EVENT_EN)
;;;55         OS_EVENT  *pevent;
;;;56     #if (OS_EVENT_MULTI_EN > 0u)
;;;57         OS_EVENT **pevents;
;;;58     #endif
;;;59     #endif
;;;60         OS_TCB    *ptcb;
;;;61         INT8U      y_new;
;;;62         INT8U      x_new;
;;;63         INT8U      y_old;
;;;64         OS_PRIO    bity_new;
;;;65         OS_PRIO    bitx_new;
;;;66         OS_PRIO    bity_old;
;;;67         OS_PRIO    bitx_old;
;;;68     #if OS_CRITICAL_METHOD == 3u
;;;69         OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;70     #endif
;;;71     
;;;72     
;;;73     /*$PAGE*/
;;;74     #if OS_ARG_CHK_EN > 0u
;;;75         if (oldprio >= OS_LOWEST_PRIO) {
;;;76             if (oldprio != OS_PRIO_SELF) {
;;;77                 return (OS_ERR_PRIO_INVALID);
;;;78             }
;;;79         }
;;;80         if (newprio >= OS_LOWEST_PRIO) {
;;;81             return (OS_ERR_PRIO_INVALID);
;;;82         }
;;;83     #endif
;;;84         OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  9000              STR      r0,[sp,#0]
;;;85         if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
000012  4848              LDR      r0,|L50.308|
000014  f8500028          LDR      r0,[r0,r8,LSL #2]
000018  b130              CBZ      r0,|L50.40|
;;;86             OS_EXIT_CRITICAL();
00001a  9800              LDR      r0,[sp,#0]
00001c  f7fffffe          BL       OS_CPU_SR_Restore
;;;87             return (OS_ERR_PRIO_EXIST);
000020  2028              MOVS     r0,#0x28
                  |L50.34|
;;;88         }
;;;89         if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
;;;90             oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
;;;91         }
;;;92         ptcb = OSTCBPrioTbl[oldprio];
;;;93         if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
;;;94             OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
;;;95             return (OS_ERR_PRIO);
;;;96         }
;;;97         if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
;;;98             OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
;;;99             return (OS_ERR_TASK_NOT_EXIST);
;;;100        }
;;;101    #if OS_LOWEST_PRIO <= 63u
;;;102        y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
;;;103        x_new                 = (INT8U)(newprio & 0x07u);
;;;104    #else
;;;105        y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
;;;106        x_new                 = (INT8U)(newprio & 0x0Fu);
;;;107    #endif
;;;108        bity_new              = (OS_PRIO)(1uL << y_new);
;;;109        bitx_new              = (OS_PRIO)(1uL << x_new);
;;;110    
;;;111        OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
;;;112        OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
;;;113        y_old                 =  ptcb->OSTCBY;
;;;114        bity_old              =  ptcb->OSTCBBitY;
;;;115        bitx_old              =  ptcb->OSTCBBitX;
;;;116        if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
;;;117             OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
;;;118             if (OSRdyTbl[y_old] == 0u) {
;;;119                 OSRdyGrp &= (OS_PRIO)~bity_old;
;;;120             }
;;;121             OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
;;;122             OSRdyTbl[y_new] |= bitx_new;
;;;123        }
;;;124    
;;;125    #if (OS_EVENT_EN)
;;;126        pevent = ptcb->OSTCBEventPtr;
;;;127        if (pevent != (OS_EVENT *)0) {
;;;128            pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
;;;129            if (pevent->OSEventTbl[y_old] == 0u) {
;;;130                pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
;;;131            }
;;;132            pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
;;;133            pevent->OSEventTbl[y_new] |= bitx_new;
;;;134        }
;;;135    #if (OS_EVENT_MULTI_EN > 0u)
;;;136        if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
;;;137            pevents =  ptcb->OSTCBEventMultiPtr;
;;;138            pevent  = *pevents;
;;;139            while (pevent != (OS_EVENT *)0) {
;;;140                pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
;;;141                if (pevent->OSEventTbl[y_old] == 0u) {
;;;142                    pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
;;;143                }
;;;144                pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
;;;145                pevent->OSEventTbl[y_new] |= bitx_new;
;;;146                pevents++;
;;;147                pevent                     = *pevents;
;;;148            }
;;;149        }
;;;150    #endif
;;;151    #endif
;;;152    
;;;153        ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
;;;154        ptcb->OSTCBY    = y_new;
;;;155        ptcb->OSTCBX    = x_new;
;;;156        ptcb->OSTCBBitY = bity_new;
;;;157        ptcb->OSTCBBitX = bitx_new;
;;;158        OS_EXIT_CRITICAL();
;;;159        if (OSRunning == OS_TRUE) {
;;;160            OS_Sched();                                         /* Find new highest priority task          */
;;;161        }
;;;162        return (OS_ERR_NONE);
;;;163    }
000022  b004              ADD      sp,sp,#0x10
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L50.40|
000028  f1b90fff          CMP      r9,#0xff              ;89
00002c  d103              BNE      |L50.54|
00002e  4842              LDR      r0,|L50.312|
000030  6800              LDR      r0,[r0,#0]            ;90  ; OSTCBCur
000032  f8909032          LDRB     r9,[r0,#0x32]         ;90
                  |L50.54|
000036  483f              LDR      r0,|L50.308|
000038  f8504029          LDR      r4,[r0,r9,LSL #2]     ;92
00003c  b924              CBNZ     r4,|L50.72|
00003e  9800              LDR      r0,[sp,#0]            ;94
000040  f7fffffe          BL       OS_CPU_SR_Restore
000044  2029              MOVS     r0,#0x29              ;95
000046  e7ec              B        |L50.34|
                  |L50.72|
000048  2c01              CMP      r4,#1                 ;97
00004a  d104              BNE      |L50.86|
00004c  9800              LDR      r0,[sp,#0]            ;98
00004e  f7fffffe          BL       OS_CPU_SR_Restore
000052  2043              MOVS     r0,#0x43              ;99
000054  e7e5              B        |L50.34|
                  |L50.86|
000056  ea4f07e8          ASR      r7,r8,#3              ;102
00005a  f0080007          AND      r0,r8,#7              ;103
00005e  9003              STR      r0,[sp,#0xc]          ;103
000060  2001              MOVS     r0,#1                 ;108
000062  40b8              LSLS     r0,r0,r7              ;108
000064  f0000aff          AND      r10,r0,#0xff          ;108
000068  2101              MOVS     r1,#1                 ;109
00006a  9803              LDR      r0,[sp,#0xc]          ;109
00006c  4081              LSLS     r1,r1,r0              ;109
00006e  f0010bff          AND      r11,r1,#0xff          ;109
000072  2000              MOVS     r0,#0                 ;111
000074  492f              LDR      r1,|L50.308|
000076  f8410029          STR      r0,[r1,r9,LSL #2]     ;111
00007a  4608              MOV      r0,r1                 ;112
00007c  f8404028          STR      r4,[r0,r8,LSL #2]     ;112
000080  f8146f34          LDRB     r6,[r4,#0x34]!        ;113
000084  78a0              LDRB     r0,[r4,#2]            ;114
000086  9002              STR      r0,[sp,#8]            ;114
000088  7860              LDRB     r0,[r4,#1]            ;115
00008a  3c34              SUBS     r4,r4,#0x34           ;115
00008c  9001              STR      r0,[sp,#4]            ;115
00008e  482b              LDR      r0,|L50.316|
000090  5d81              LDRB     r1,[r0,r6]            ;116
000092  9801              LDR      r0,[sp,#4]            ;116
000094  4001              ANDS     r1,r1,r0              ;116
000096  b1d1              CBZ      r1,|L50.206|
000098  4828              LDR      r0,|L50.316|
00009a  5d80              LDRB     r0,[r0,r6]            ;117
00009c  9901              LDR      r1,[sp,#4]            ;117
00009e  4388              BICS     r0,r0,r1              ;117
0000a0  4926              LDR      r1,|L50.316|
0000a2  5588              STRB     r0,[r1,r6]            ;117
0000a4  4608              MOV      r0,r1                 ;118
0000a6  5d80              LDRB     r0,[r0,r6]            ;118
0000a8  b928              CBNZ     r0,|L50.182|
0000aa  4825              LDR      r0,|L50.320|
0000ac  7800              LDRB     r0,[r0,#0]            ;119  ; OSRdyGrp
0000ae  9902              LDR      r1,[sp,#8]            ;119
0000b0  4388              BICS     r0,r0,r1              ;119
0000b2  4923              LDR      r1,|L50.320|
0000b4  7008              STRB     r0,[r1,#0]            ;119
                  |L50.182|
0000b6  4822              LDR      r0,|L50.320|
0000b8  7800              LDRB     r0,[r0,#0]            ;121  ; OSRdyGrp
0000ba  ea40000a          ORR      r0,r0,r10             ;121
0000be  4920              LDR      r1,|L50.320|
0000c0  7008              STRB     r0,[r1,#0]            ;121
0000c2  481e              LDR      r0,|L50.316|
0000c4  5dc0              LDRB     r0,[r0,r7]            ;122
0000c6  ea40000b          ORR      r0,r0,r11             ;122
0000ca  491c              LDR      r1,|L50.316|
0000cc  55c8              STRB     r0,[r1,r7]            ;122
                  |L50.206|
0000ce  69e5              LDR      r5,[r4,#0x1c]         ;126
0000d0  b1d5              CBZ      r5,|L50.264|
0000d2  f105000b          ADD      r0,r5,#0xb            ;128
0000d6  5d80              LDRB     r0,[r0,r6]            ;128
0000d8  9901              LDR      r1,[sp,#4]            ;128
0000da  4388              BICS     r0,r0,r1              ;128
0000dc  f105010b          ADD      r1,r5,#0xb            ;128
0000e0  5588              STRB     r0,[r1,r6]            ;128
0000e2  4608              MOV      r0,r1                 ;129
0000e4  5d80              LDRB     r0,[r0,r6]            ;129
0000e6  b918              CBNZ     r0,|L50.240|
0000e8  7aa8              LDRB     r0,[r5,#0xa]          ;130
0000ea  9902              LDR      r1,[sp,#8]            ;130
0000ec  4388              BICS     r0,r0,r1              ;130
0000ee  72a8              STRB     r0,[r5,#0xa]          ;130
                  |L50.240|
0000f0  7aa8              LDRB     r0,[r5,#0xa]          ;132
0000f2  ea40000a          ORR      r0,r0,r10             ;132
0000f6  72a8              STRB     r0,[r5,#0xa]          ;132
0000f8  f105000b          ADD      r0,r5,#0xb            ;133
0000fc  5dc0              LDRB     r0,[r0,r7]            ;133
0000fe  ea40000b          ORR      r0,r0,r11             ;133
000102  f105010b          ADD      r1,r5,#0xb            ;133
000106  55c8              STRB     r0,[r1,r7]            ;133
                  |L50.264|
000108  f8848032          STRB     r8,[r4,#0x32]         ;153
00010c  f8847034          STRB     r7,[r4,#0x34]         ;154
000110  9803              LDR      r0,[sp,#0xc]          ;155
000112  f8840033          STRB     r0,[r4,#0x33]         ;155
000116  f884a036          STRB     r10,[r4,#0x36]        ;156
00011a  f884b035          STRB     r11,[r4,#0x35]        ;157
00011e  9800              LDR      r0,[sp,#0]            ;158
000120  f7fffffe          BL       OS_CPU_SR_Restore
000124  4807              LDR      r0,|L50.324|
000126  7800              LDRB     r0,[r0,#0]            ;159  ; OSRunning
000128  2801              CMP      r0,#1                 ;159
00012a  d101              BNE      |L50.304|
00012c  f7fffffe          BL       OS_Sched
                  |L50.304|
000130  2000              MOVS     r0,#0                 ;162
000132  e776              B        |L50.34|
;;;164    #endif
                          ENDP

                  |L50.308|
                          DCD      OSTCBPrioTbl
                  |L50.312|
                          DCD      OSTCBCur
                  |L50.316|
                          DCD      OSRdyTbl
                  |L50.320|
                          DCD      OSRdyGrp
                  |L50.324|
                          DCD      OSRunning

                          AREA ||i.OSTaskCreate||, CODE, READONLY, ALIGN=2

                  OSTaskCreate PROC
;;;206    #if OS_TASK_CREATE_EN > 0u
;;;207    INT8U  OSTaskCreate (void   (*task)(void *p_arg),
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;208                         void    *p_arg,
;;;209                         OS_STK  *ptos,
;;;210                         INT8U    prio)
;;;211    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
;;;212        OS_STK    *psp;
;;;213        INT8U      err;
;;;214    #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
;;;215        OS_CPU_SR  cpu_sr = 0u;
00000c  f04f0900          MOV      r9,#0
;;;216    #endif
;;;217    
;;;218    
;;;219    
;;;220    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;221        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;222            OS_SAFETY_CRITICAL_EXCEPTION();
;;;223        }
;;;224    #endif
;;;225    
;;;226    #if OS_ARG_CHK_EN > 0u
;;;227        if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
;;;228            return (OS_ERR_PRIO_INVALID);
;;;229        }
;;;230    #endif
;;;231        OS_ENTER_CRITICAL();
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4681              MOV      r9,r0
;;;232        if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
000016  481f              LDR      r0,|L51.148|
000018  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00001a  b128              CBZ      r0,|L51.40|
;;;233            OS_EXIT_CRITICAL();
00001c  4648              MOV      r0,r9
00001e  f7fffffe          BL       OS_CPU_SR_Restore
;;;234            return (OS_ERR_TASK_CREATE_ISR);
000022  203c              MOVS     r0,#0x3c
                  |L51.36|
;;;235        }
;;;236        if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
;;;237            OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
;;;238                                                 /* ... the same thing until task is created.              */
;;;239            OS_EXIT_CRITICAL();
;;;240            psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
;;;241            err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
;;;242            if (err == OS_ERR_NONE) {
;;;243                if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
;;;244                    OS_Sched();
;;;245                }
;;;246            } else {
;;;247                OS_ENTER_CRITICAL();
;;;248                OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
;;;249                OS_EXIT_CRITICAL();
;;;250            }
;;;251            return (err);
;;;252        }
;;;253        OS_EXIT_CRITICAL();
;;;254        return (OS_ERR_PRIO_EXIST);
;;;255    }
000024  e8bd8ffe          POP      {r1-r11,pc}
                  |L51.40|
000028  481b              LDR      r0,|L51.152|
00002a  f8500024          LDR      r0,[r0,r4,LSL #2]     ;236
00002e  bb60              CBNZ     r0,|L51.138|
000030  2001              MOVS     r0,#1                 ;237
000032  4919              LDR      r1,|L51.152|
000034  f8410024          STR      r0,[r1,r4,LSL #2]     ;237
000038  4648              MOV      r0,r9                 ;239
00003a  f7fffffe          BL       OS_CPU_SR_Restore
00003e  2300              MOVS     r3,#0                 ;240
000040  4642              MOV      r2,r8                 ;240
000042  4639              MOV      r1,r7                 ;240
000044  4630              MOV      r0,r6                 ;240
000046  f7fffffe          BL       OSTaskStkInit
00004a  4682              MOV      r10,r0                ;240
00004c  2000              MOVS     r0,#0                 ;241
00004e  9000              STR      r0,[sp,#0]            ;241
000050  9001              STR      r0,[sp,#4]            ;241
000052  4603              MOV      r3,r0                 ;241
000054  4602              MOV      r2,r0                 ;241
000056  4651              MOV      r1,r10                ;241
000058  9002              STR      r0,[sp,#8]            ;241
00005a  4620              MOV      r0,r4                 ;241
00005c  f7fffffe          BL       OS_TCBInit
000060  4605              MOV      r5,r0                 ;241
000062  b935              CBNZ     r5,|L51.114|
000064  480d              LDR      r0,|L51.156|
000066  7800              LDRB     r0,[r0,#0]            ;243  ; OSRunning
000068  2801              CMP      r0,#1                 ;243
00006a  d10c              BNE      |L51.134|
00006c  f7fffffe          BL       OS_Sched
000070  e009              B        |L51.134|
                  |L51.114|
000072  f7fffffe          BL       OS_CPU_SR_Save
000076  4681              MOV      r9,r0                 ;247
000078  2000              MOVS     r0,#0                 ;248
00007a  4907              LDR      r1,|L51.152|
00007c  f8410024          STR      r0,[r1,r4,LSL #2]     ;248
000080  4648              MOV      r0,r9                 ;249
000082  f7fffffe          BL       OS_CPU_SR_Restore
                  |L51.134|
000086  4628              MOV      r0,r5                 ;251
000088  e7cc              B        |L51.36|
                  |L51.138|
00008a  4648              MOV      r0,r9                 ;253
00008c  f7fffffe          BL       OS_CPU_SR_Restore
000090  2028              MOVS     r0,#0x28              ;254
000092  e7c7              B        |L51.36|
;;;256    #endif
                          ENDP

                  |L51.148|
                          DCD      OSIntNesting
                  |L51.152|
                          DCD      OSTCBPrioTbl
                  |L51.156|
                          DCD      OSRunning

                          AREA ||i.OSTaskCreateExt||, CODE, READONLY, ALIGN=2

                  OSTaskCreateExt PROC
;;;328    #if OS_TASK_CREATE_EXT_EN > 0u
;;;329    INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;330                            void    *p_arg,
;;;331                            OS_STK  *ptos,
;;;332                            INT8U    prio,
;;;333                            INT16U   id,
;;;334                            OS_STK  *pbos,
;;;335                            INT32U   stk_size,
;;;336                            void    *pext,
;;;337                            INT16U   opt)
;;;338    {
000004  b085              SUB      sp,sp,#0x14
000006  4681              MOV      r9,r0
000008  468a              MOV      r10,r1
00000a  4693              MOV      r11,r2
00000c  461c              MOV      r4,r3
00000e  e9dd780f          LDRD     r7,r8,[sp,#0x3c]
000012  9d12              LDR      r5,[sp,#0x48]
;;;339        OS_STK    *psp;
;;;340        INT8U      err;
;;;341    #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
;;;342        OS_CPU_SR  cpu_sr = 0u;
000014  2000              MOVS     r0,#0
000016  9003              STR      r0,[sp,#0xc]
;;;343    #endif
;;;344    
;;;345    
;;;346    
;;;347    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;348        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;349            OS_SAFETY_CRITICAL_EXCEPTION();
;;;350        }
;;;351    #endif
;;;352    
;;;353    #if OS_ARG_CHK_EN > 0u
;;;354        if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
;;;355            return (OS_ERR_PRIO_INVALID);
;;;356        }
;;;357    #endif
;;;358        OS_ENTER_CRITICAL();
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  9003              STR      r0,[sp,#0xc]
;;;359        if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
00001e  4823              LDR      r0,|L52.172|
000020  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000022  b130              CBZ      r0,|L52.50|
;;;360            OS_EXIT_CRITICAL();
000024  9803              LDR      r0,[sp,#0xc]
000026  f7fffffe          BL       OS_CPU_SR_Restore
;;;361            return (OS_ERR_TASK_CREATE_ISR);
00002a  203c              MOVS     r0,#0x3c
                  |L52.44|
;;;362        }
;;;363        if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
;;;364            OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
;;;365                                                 /* ... the same thing until task is created.              */
;;;366            OS_EXIT_CRITICAL();
;;;367    
;;;368    #if (OS_TASK_STAT_STK_CHK_EN > 0u)
;;;369            OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
;;;370    #endif
;;;371    
;;;372            psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
;;;373            err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
;;;374            if (err == OS_ERR_NONE) {
;;;375                if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
;;;376                    OS_Sched();
;;;377                }
;;;378            } else {
;;;379                OS_ENTER_CRITICAL();
;;;380                OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
;;;381                OS_EXIT_CRITICAL();
;;;382            }
;;;383            return (err);
;;;384        }
;;;385        OS_EXIT_CRITICAL();
;;;386        return (OS_ERR_PRIO_EXIST);
;;;387    }
00002c  b005              ADD      sp,sp,#0x14
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L52.50|
000032  481f              LDR      r0,|L52.176|
000034  f8500024          LDR      r0,[r0,r4,LSL #2]     ;363
000038  bb88              CBNZ     r0,|L52.158|
00003a  2001              MOVS     r0,#1                 ;364
00003c  491c              LDR      r1,|L52.176|
00003e  f8410024          STR      r0,[r1,r4,LSL #2]     ;364
000042  9803              LDR      r0,[sp,#0xc]          ;366
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  462a              MOV      r2,r5                 ;369
00004a  4641              MOV      r1,r8                 ;369
00004c  4638              MOV      r0,r7                 ;369
00004e  f7fffffe          BL       OS_TaskStkClr
000052  462b              MOV      r3,r5                 ;372
000054  465a              MOV      r2,r11                ;372
000056  4651              MOV      r1,r10                ;372
000058  4648              MOV      r0,r9                 ;372
00005a  f7fffffe          BL       OSTaskStkInit
00005e  9004              STR      r0,[sp,#0x10]         ;372
000060  9811              LDR      r0,[sp,#0x44]         ;373
000062  e9cd8000          STRD     r8,r0,[sp,#0]         ;373
000066  9502              STR      r5,[sp,#8]            ;373
000068  463a              MOV      r2,r7                 ;373
00006a  4620              MOV      r0,r4                 ;373
00006c  9b0e              LDR      r3,[sp,#0x38]         ;373
00006e  9904              LDR      r1,[sp,#0x10]         ;373
000070  f7fffffe          BL       OS_TCBInit
000074  4606              MOV      r6,r0                 ;373
000076  b936              CBNZ     r6,|L52.134|
000078  480e              LDR      r0,|L52.180|
00007a  7800              LDRB     r0,[r0,#0]            ;375  ; OSRunning
00007c  2801              CMP      r0,#1                 ;375
00007e  d10c              BNE      |L52.154|
000080  f7fffffe          BL       OS_Sched
000084  e009              B        |L52.154|
                  |L52.134|
000086  f7fffffe          BL       OS_CPU_SR_Save
00008a  9003              STR      r0,[sp,#0xc]          ;379
00008c  2000              MOVS     r0,#0                 ;380
00008e  4908              LDR      r1,|L52.176|
000090  f8410024          STR      r0,[r1,r4,LSL #2]     ;380
000094  9803              LDR      r0,[sp,#0xc]          ;381
000096  f7fffffe          BL       OS_CPU_SR_Restore
                  |L52.154|
00009a  4630              MOV      r0,r6                 ;383
00009c  e7c6              B        |L52.44|
                  |L52.158|
00009e  e7ff              B        |L52.160|
                  |L52.160|
0000a0  9803              LDR      r0,[sp,#0xc]          ;385
0000a2  f7fffffe          BL       OS_CPU_SR_Restore
0000a6  2028              MOVS     r0,#0x28              ;386
0000a8  e7c0              B        |L52.44|
;;;388    #endif
                          ENDP

0000aa  0000              DCW      0x0000
                  |L52.172|
                          DCD      OSIntNesting
                  |L52.176|
                          DCD      OSTCBPrioTbl
                  |L52.180|
                          DCD      OSRunning

                          AREA ||i.OSTaskDel||, CODE, READONLY, ALIGN=2

                  OSTaskDel PROC
;;;426    #if OS_TASK_DEL_EN > 0u
;;;427    INT8U  OSTaskDel (INT8U prio)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;428    {
000004  4605              MOV      r5,r0
;;;429    #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
;;;430        OS_FLAG_NODE *pnode;
;;;431    #endif
;;;432        OS_TCB       *ptcb;
;;;433    #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
;;;434        OS_CPU_SR     cpu_sr = 0u;
000006  2700              MOVS     r7,#0
;;;435    #endif
;;;436    
;;;437    
;;;438    
;;;439        if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
000008  4847              LDR      r0,|L53.296|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000c  b110              CBZ      r0,|L53.20|
;;;440            return (OS_ERR_TASK_DEL_ISR);
00000e  2040              MOVS     r0,#0x40
                  |L53.16|
;;;441        }
;;;442        if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
;;;443            return (OS_ERR_TASK_DEL_IDLE);
;;;444        }
;;;445    #if OS_ARG_CHK_EN > 0u
;;;446        if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
;;;447            if (prio != OS_PRIO_SELF) {
;;;448                return (OS_ERR_PRIO_INVALID);
;;;449            }
;;;450        }
;;;451    #endif
;;;452    
;;;453    /*$PAGE*/
;;;454        OS_ENTER_CRITICAL();
;;;455        if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
;;;456            prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
;;;457        }
;;;458        ptcb = OSTCBPrioTbl[prio];
;;;459        if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
;;;460            OS_EXIT_CRITICAL();
;;;461            return (OS_ERR_TASK_NOT_EXIST);
;;;462        }
;;;463        if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
;;;464            OS_EXIT_CRITICAL();
;;;465            return (OS_ERR_TASK_DEL);
;;;466        }
;;;467    
;;;468        OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
;;;469        if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
;;;470            OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
;;;471        }
;;;472    
;;;473    #if (OS_EVENT_EN)
;;;474        if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
;;;475            OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
;;;476        }
;;;477    #if (OS_EVENT_MULTI_EN > 0u)
;;;478        if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
;;;479            OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
;;;480        }
;;;481    #endif
;;;482    #endif
;;;483    
;;;484    #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
;;;485        pnode = ptcb->OSTCBFlagNode;
;;;486        if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
;;;487            OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
;;;488        }
;;;489    #endif
;;;490    
;;;491        ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
;;;492        ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
;;;493        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
;;;494        if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
;;;495            OSLockNesting++;
;;;496        }
;;;497        OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
;;;498        OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
;;;499        OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
;;;500        if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
;;;501            OSLockNesting--;
;;;502        }
;;;503        OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
;;;504        OSTaskCtr--;                                        /* One less task being managed                 */
;;;505        OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
;;;506        if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
;;;507            ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
;;;508            OSTCBList                  = ptcb->OSTCBNext;
;;;509        } else {
;;;510            ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
;;;511            ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
;;;512        }
;;;513        ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
;;;514        OSTCBFreeList       = ptcb;
;;;515    #if OS_TASK_NAME_EN > 0u
;;;516        ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
;;;517    #endif
;;;518        OS_EXIT_CRITICAL();
;;;519        if (OSRunning == OS_TRUE) {
;;;520            OS_Sched();                                     /* Find new highest priority task              */
;;;521        }
;;;522        return (OS_ERR_NONE);
;;;523    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L53.20|
000014  2d3f              CMP      r5,#0x3f              ;442
000016  d101              BNE      |L53.28|
000018  203e              MOVS     r0,#0x3e              ;443
00001a  e7f9              B        |L53.16|
                  |L53.28|
00001c  f7fffffe          BL       OS_CPU_SR_Save
000020  4607              MOV      r7,r0                 ;454
000022  2dff              CMP      r5,#0xff              ;455
000024  d103              BNE      |L53.46|
000026  4841              LDR      r0,|L53.300|
000028  6800              LDR      r0,[r0,#0]            ;456  ; OSTCBCur
00002a  f8905032          LDRB     r5,[r0,#0x32]         ;456
                  |L53.46|
00002e  4840              LDR      r0,|L53.304|
000030  f8504025          LDR      r4,[r0,r5,LSL #2]     ;458
000034  b924              CBNZ     r4,|L53.64|
000036  4638              MOV      r0,r7                 ;460
000038  f7fffffe          BL       OS_CPU_SR_Restore
00003c  2043              MOVS     r0,#0x43              ;461
00003e  e7e7              B        |L53.16|
                  |L53.64|
000040  2c01              CMP      r4,#1                 ;463
000042  d104              BNE      |L53.78|
000044  4638              MOV      r0,r7                 ;464
000046  f7fffffe          BL       OS_CPU_SR_Restore
00004a  203d              MOVS     r0,#0x3d              ;465
00004c  e7e0              B        |L53.16|
                  |L53.78|
00004e  f8140f34          LDRB     r0,[r4,#0x34]!        ;468
000052  4938              LDR      r1,|L53.308|
000054  5c08              LDRB     r0,[r1,r0]            ;468
000056  7861              LDRB     r1,[r4,#1]            ;468
000058  4388              BICS     r0,r0,r1              ;468
00005a  7821              LDRB     r1,[r4,#0]            ;468
00005c  4a35              LDR      r2,|L53.308|
00005e  5450              STRB     r0,[r2,r1]            ;468
000060  f8140934          LDRB     r0,[r4],#-0x34        ;469
000064  4611              MOV      r1,r2                 ;469
000066  5c08              LDRB     r0,[r1,r0]            ;469
000068  b930              CBNZ     r0,|L53.120|
00006a  f8941036          LDRB     r1,[r4,#0x36]         ;470
00006e  4832              LDR      r0,|L53.312|
000070  7800              LDRB     r0,[r0,#0]            ;470  ; OSRdyGrp
000072  4388              BICS     r0,r0,r1              ;470
000074  4930              LDR      r1,|L53.312|
000076  7008              STRB     r0,[r1,#0]            ;470
                  |L53.120|
000078  69e0              LDR      r0,[r4,#0x1c]         ;474
00007a  b118              CBZ      r0,|L53.132|
00007c  4620              MOV      r0,r4                 ;475
00007e  69e1              LDR      r1,[r4,#0x1c]         ;475
000080  f7fffffe          BL       OS_EventTaskRemove
                  |L53.132|
000084  6a66              LDR      r6,[r4,#0x24]         ;485
000086  b116              CBZ      r6,|L53.142|
000088  4630              MOV      r0,r6                 ;487
00008a  f7fffffe          BL       OS_FlagUnlink
                  |L53.142|
00008e  2000              MOVS     r0,#0                 ;491
000090  62e0              STR      r0,[r4,#0x2c]         ;491
000092  f8840030          STRB     r0,[r4,#0x30]         ;492
000096  f8840031          STRB     r0,[r4,#0x31]         ;493
00009a  4828              LDR      r0,|L53.316|
00009c  7800              LDRB     r0,[r0,#0]            ;494  ; OSLockNesting
00009e  28ff              CMP      r0,#0xff              ;494
0000a0  d204              BCS      |L53.172|
0000a2  4826              LDR      r0,|L53.316|
0000a4  7800              LDRB     r0,[r0,#0]            ;495  ; OSLockNesting
0000a6  1c40              ADDS     r0,r0,#1              ;495
0000a8  4924              LDR      r1,|L53.316|
0000aa  7008              STRB     r0,[r1,#0]            ;495
                  |L53.172|
0000ac  4638              MOV      r0,r7                 ;497
0000ae  f7fffffe          BL       OS_CPU_SR_Restore
0000b2  f7fffffe          BL       OS_Dummy
0000b6  f7fffffe          BL       OS_CPU_SR_Save
0000ba  4607              MOV      r7,r0                 ;499
0000bc  481f              LDR      r0,|L53.316|
0000be  7800              LDRB     r0,[r0,#0]            ;500  ; OSLockNesting
0000c0  b120              CBZ      r0,|L53.204|
0000c2  481e              LDR      r0,|L53.316|
0000c4  7800              LDRB     r0,[r0,#0]            ;501  ; OSLockNesting
0000c6  1e40              SUBS     r0,r0,#1              ;501
0000c8  491c              LDR      r1,|L53.316|
0000ca  7008              STRB     r0,[r1,#0]            ;501
                  |L53.204|
0000cc  4620              MOV      r0,r4                 ;503
0000ce  f7fffffe          BL       OSTaskDelHook
0000d2  481b              LDR      r0,|L53.320|
0000d4  7800              LDRB     r0,[r0,#0]            ;504  ; OSTaskCtr
0000d6  1e40              SUBS     r0,r0,#1              ;504
0000d8  4919              LDR      r1,|L53.320|
0000da  7008              STRB     r0,[r1,#0]            ;504
0000dc  2000              MOVS     r0,#0                 ;505
0000de  4914              LDR      r1,|L53.304|
0000e0  f8410025          STR      r0,[r1,r5,LSL #2]     ;505
0000e4  69a0              LDR      r0,[r4,#0x18]         ;506
0000e6  b930              CBNZ     r0,|L53.246|
0000e8  2000              MOVS     r0,#0                 ;507
0000ea  6961              LDR      r1,[r4,#0x14]         ;507
0000ec  6188              STR      r0,[r1,#0x18]         ;507
0000ee  4915              LDR      r1,|L53.324|
0000f0  6960              LDR      r0,[r4,#0x14]         ;508
0000f2  6008              STR      r0,[r1,#0]            ;508  ; OSTCBList
0000f4  e005              B        |L53.258|
                  |L53.246|
0000f6  e9d40105          LDRD     r0,r1,[r4,#0x14]      ;510
0000fa  6148              STR      r0,[r1,#0x14]         ;510
0000fc  e9d41005          LDRD     r1,r0,[r4,#0x14]      ;511
000100  6188              STR      r0,[r1,#0x18]         ;511
                  |L53.258|
000102  4811              LDR      r0,|L53.328|
000104  6800              LDR      r0,[r0,#0]            ;513  ; OSTCBFreeList
000106  6160              STR      r0,[r4,#0x14]         ;513
000108  480f              LDR      r0,|L53.328|
00010a  6004              STR      r4,[r0,#0]            ;514  ; OSTCBFreeList
00010c  a00f              ADR      r0,|L53.332|
00010e  64e0              STR      r0,[r4,#0x4c]         ;516
000110  4638              MOV      r0,r7                 ;518
000112  f7fffffe          BL       OS_CPU_SR_Restore
000116  480e              LDR      r0,|L53.336|
000118  7800              LDRB     r0,[r0,#0]            ;519  ; OSRunning
00011a  2801              CMP      r0,#1                 ;519
00011c  d101              BNE      |L53.290|
00011e  f7fffffe          BL       OS_Sched
                  |L53.290|
000122  2000              MOVS     r0,#0                 ;522
000124  e774              B        |L53.16|
;;;524    #endif
                          ENDP

000126  0000              DCW      0x0000
                  |L53.296|
                          DCD      OSIntNesting
                  |L53.300|
                          DCD      OSTCBCur
                  |L53.304|
                          DCD      OSTCBPrioTbl
                  |L53.308|
                          DCD      OSRdyTbl
                  |L53.312|
                          DCD      OSRdyGrp
                  |L53.316|
                          DCD      OSLockNesting
                  |L53.320|
                          DCD      OSTaskCtr
                  |L53.324|
                          DCD      OSTCBList
                  |L53.328|
                          DCD      OSTCBFreeList
                  |L53.332|
00014c  3f00              DCB      "?",0
00014e  00                DCB      0
00014f  00                DCB      0
                  |L53.336|
                          DCD      OSRunning

                          AREA ||i.OSTaskDelReq||, CODE, READONLY, ALIGN=2

                  OSTaskDelReq PROC
;;;572    #if OS_TASK_DEL_EN > 0u
;;;573    INT8U  OSTaskDelReq (INT8U prio)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;574    {
000004  4604              MOV      r4,r0
;;;575        INT8U      stat;
;;;576        OS_TCB    *ptcb;
;;;577    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;578        OS_CPU_SR  cpu_sr = 0u;
000006  2700              MOVS     r7,#0
;;;579    #endif
;;;580    
;;;581    
;;;582    
;;;583        if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
000008  2c3f              CMP      r4,#0x3f
00000a  d102              BNE      |L54.18|
;;;584            return (OS_ERR_TASK_DEL_IDLE);
00000c  203e              MOVS     r0,#0x3e
                  |L54.14|
;;;585        }
;;;586    #if OS_ARG_CHK_EN > 0u
;;;587        if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
;;;588            if (prio != OS_PRIO_SELF) {
;;;589                return (OS_ERR_PRIO_INVALID);
;;;590            }
;;;591        }
;;;592    #endif
;;;593        if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
;;;594            OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
;;;595            stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
;;;596            OS_EXIT_CRITICAL();
;;;597            return (stat);
;;;598        }
;;;599        OS_ENTER_CRITICAL();
;;;600        ptcb = OSTCBPrioTbl[prio];
;;;601        if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
;;;602            OS_EXIT_CRITICAL();
;;;603            return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
;;;604        }
;;;605        if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
;;;606            OS_EXIT_CRITICAL();
;;;607            return (OS_ERR_TASK_DEL);
;;;608        }
;;;609        ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
;;;610        OS_EXIT_CRITICAL();
;;;611        return (OS_ERR_NONE);
;;;612    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L54.18|
000012  2cff              CMP      r4,#0xff              ;593
000014  d10b              BNE      |L54.46|
000016  f7fffffe          BL       OS_CPU_SR_Save
00001a  4607              MOV      r7,r0                 ;594
00001c  4811              LDR      r0,|L54.100|
00001e  6800              LDR      r0,[r0,#0]            ;595  ; OSTCBCur
000020  f8906037          LDRB     r6,[r0,#0x37]         ;595
000024  4638              MOV      r0,r7                 ;596
000026  f7fffffe          BL       OS_CPU_SR_Restore
00002a  4630              MOV      r0,r6                 ;597
00002c  e7ef              B        |L54.14|
                  |L54.46|
00002e  f7fffffe          BL       OS_CPU_SR_Save
000032  4607              MOV      r7,r0                 ;599
000034  480c              LDR      r0,|L54.104|
000036  f8505024          LDR      r5,[r0,r4,LSL #2]     ;600
00003a  b925              CBNZ     r5,|L54.70|
00003c  4638              MOV      r0,r7                 ;602
00003e  f7fffffe          BL       OS_CPU_SR_Restore
000042  2043              MOVS     r0,#0x43              ;603
000044  e7e3              B        |L54.14|
                  |L54.70|
000046  2d01              CMP      r5,#1                 ;605
000048  d104              BNE      |L54.84|
00004a  4638              MOV      r0,r7                 ;606
00004c  f7fffffe          BL       OS_CPU_SR_Restore
000050  203d              MOVS     r0,#0x3d              ;607
000052  e7dc              B        |L54.14|
                  |L54.84|
000054  203f              MOVS     r0,#0x3f              ;609
000056  f8850037          STRB     r0,[r5,#0x37]         ;609
00005a  4638              MOV      r0,r7                 ;610
00005c  f7fffffe          BL       OS_CPU_SR_Restore
000060  2000              MOVS     r0,#0                 ;611
000062  e7d4              B        |L54.14|
;;;613    #endif
                          ENDP

                  |L54.100|
                          DCD      OSTCBCur
                  |L54.104|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSTaskNameGet||, CODE, READONLY, ALIGN=2

                  OSTaskNameGet PROC
;;;639    #if OS_TASK_NAME_EN > 0u
;;;640    INT8U  OSTaskNameGet (INT8U    prio,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;641                          INT8U  **pname,
;;;642                          INT8U   *perr)
;;;643    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;644        OS_TCB    *ptcb;
;;;645        INT8U      len;
;;;646    #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
;;;647        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;648    #endif
;;;649    
;;;650    
;;;651    
;;;652    #ifdef OS_SAFETY_CRITICAL
;;;653        if (perr == (INT8U *)0) {
;;;654            OS_SAFETY_CRITICAL_EXCEPTION();
;;;655        }
;;;656    #endif
;;;657    
;;;658    #if OS_ARG_CHK_EN > 0u
;;;659        if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
;;;660            if (prio != OS_PRIO_SELF) {
;;;661                *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
;;;662                return (0u);
;;;663            }
;;;664        }
;;;665        if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
;;;666            *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
;;;667            return (0u);
;;;668        }
;;;669    #endif
;;;670        if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
00000e  4819              LDR      r0,|L55.116|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000012  b120              CBZ      r0,|L55.30|
;;;671            *perr = OS_ERR_NAME_GET_ISR;
000014  2011              MOVS     r0,#0x11
000016  7020              STRB     r0,[r4,#0]
;;;672            return (0u);
000018  2000              MOVS     r0,#0
                  |L55.26|
;;;673        }
;;;674        OS_ENTER_CRITICAL();
;;;675        if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
;;;676            prio = OSTCBCur->OSTCBPrio;
;;;677        }
;;;678        ptcb = OSTCBPrioTbl[prio];
;;;679        if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
;;;680            OS_EXIT_CRITICAL();                              /* No                                         */
;;;681            *perr = OS_ERR_TASK_NOT_EXIST;
;;;682            return (0u);
;;;683        }
;;;684        if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
;;;685            OS_EXIT_CRITICAL();                              /* Yes                                        */
;;;686            *perr = OS_ERR_TASK_NOT_EXIST;
;;;687            return (0u);
;;;688        }
;;;689        *pname = ptcb->OSTCBTaskName;
;;;690        len    = OS_StrLen(*pname);
;;;691        OS_EXIT_CRITICAL();
;;;692        *perr  = OS_ERR_NONE;
;;;693        return (len);
;;;694    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L55.30|
00001e  f7fffffe          BL       OS_CPU_SR_Save
000022  4680              MOV      r8,r0                 ;674
000024  2eff              CMP      r6,#0xff              ;675
000026  d103              BNE      |L55.48|
000028  4813              LDR      r0,|L55.120|
00002a  6800              LDR      r0,[r0,#0]            ;676  ; OSTCBCur
00002c  f8906032          LDRB     r6,[r0,#0x32]         ;676
                  |L55.48|
000030  4812              LDR      r0,|L55.124|
000032  f8505026          LDR      r5,[r0,r6,LSL #2]     ;678
000036  b935              CBNZ     r5,|L55.70|
000038  4640              MOV      r0,r8                 ;680
00003a  f7fffffe          BL       OS_CPU_SR_Restore
00003e  2043              MOVS     r0,#0x43              ;681
000040  7020              STRB     r0,[r4,#0]            ;681
000042  2000              MOVS     r0,#0                 ;682
000044  e7e9              B        |L55.26|
                  |L55.70|
000046  2d01              CMP      r5,#1                 ;684
000048  d106              BNE      |L55.88|
00004a  4640              MOV      r0,r8                 ;685
00004c  f7fffffe          BL       OS_CPU_SR_Restore
000050  2043              MOVS     r0,#0x43              ;686
000052  7020              STRB     r0,[r4,#0]            ;686
000054  2000              MOVS     r0,#0                 ;687
000056  e7e0              B        |L55.26|
                  |L55.88|
000058  6ce8              LDR      r0,[r5,#0x4c]         ;689
00005a  6038              STR      r0,[r7,#0]            ;689
00005c  6838              LDR      r0,[r7,#0]            ;690
00005e  f7fffffe          BL       OS_StrLen
000062  4681              MOV      r9,r0                 ;690
000064  4640              MOV      r0,r8                 ;691
000066  f7fffffe          BL       OS_CPU_SR_Restore
00006a  2000              MOVS     r0,#0                 ;692
00006c  7020              STRB     r0,[r4,#0]            ;692
00006e  4648              MOV      r0,r9                 ;693
000070  e7d3              B        |L55.26|
;;;695    #endif
                          ENDP

000072  0000              DCW      0x0000
                  |L55.116|
                          DCD      OSIntNesting
                  |L55.120|
                          DCD      OSTCBCur
                  |L55.124|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSTaskNameSet||, CODE, READONLY, ALIGN=2

                  OSTaskNameSet PROC
;;;720    #if OS_TASK_NAME_EN > 0u
;;;721    void  OSTaskNameSet (INT8U   prio,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;722                         INT8U  *pname,
;;;723                         INT8U  *perr)
;;;724    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;725        OS_TCB    *ptcb;
;;;726    #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
;;;727        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;728    #endif
;;;729    
;;;730    
;;;731    
;;;732    #ifdef OS_SAFETY_CRITICAL
;;;733        if (perr == (INT8U *)0) {
;;;734            OS_SAFETY_CRITICAL_EXCEPTION();
;;;735        }
;;;736    #endif
;;;737    
;;;738    #if OS_ARG_CHK_EN > 0u
;;;739        if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
;;;740            if (prio != OS_PRIO_SELF) {
;;;741                *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
;;;742                return;
;;;743            }
;;;744        }
;;;745        if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
;;;746            *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
;;;747            return;
;;;748        }
;;;749    #endif
;;;750        if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
00000e  4815              LDR      r0,|L56.100|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000012  b118              CBZ      r0,|L56.28|
;;;751            *perr = OS_ERR_NAME_SET_ISR;
000014  2012              MOVS     r0,#0x12
000016  7020              STRB     r0,[r4,#0]
                  |L56.24|
;;;752            return;
;;;753        }
;;;754        OS_ENTER_CRITICAL();
;;;755        if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
;;;756            prio = OSTCBCur->OSTCBPrio;
;;;757        }
;;;758        ptcb = OSTCBPrioTbl[prio];
;;;759        if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
;;;760            OS_EXIT_CRITICAL();                          /* No                                             */
;;;761            *perr = OS_ERR_TASK_NOT_EXIST;
;;;762            return;
;;;763        }
;;;764        if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
;;;765            OS_EXIT_CRITICAL();                          /* Yes                                            */
;;;766            *perr = OS_ERR_TASK_NOT_EXIST;
;;;767            return;
;;;768        }
;;;769        ptcb->OSTCBTaskName = pname;
;;;770        OS_EXIT_CRITICAL();
;;;771        *perr               = OS_ERR_NONE;
;;;772    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L56.28|
00001c  f7fffffe          BL       OS_CPU_SR_Save
000020  4680              MOV      r8,r0                 ;754
000022  2eff              CMP      r6,#0xff              ;755
000024  d103              BNE      |L56.46|
000026  4810              LDR      r0,|L56.104|
000028  6800              LDR      r0,[r0,#0]            ;756  ; OSTCBCur
00002a  f8906032          LDRB     r6,[r0,#0x32]         ;756
                  |L56.46|
00002e  480f              LDR      r0,|L56.108|
000030  f8505026          LDR      r5,[r0,r6,LSL #2]     ;758
000034  b92d              CBNZ     r5,|L56.66|
000036  4640              MOV      r0,r8                 ;760
000038  f7fffffe          BL       OS_CPU_SR_Restore
00003c  2043              MOVS     r0,#0x43              ;761
00003e  7020              STRB     r0,[r4,#0]            ;761
000040  e7ea              B        |L56.24|
                  |L56.66|
000042  2d01              CMP      r5,#1                 ;764
000044  d105              BNE      |L56.82|
000046  4640              MOV      r0,r8                 ;765
000048  f7fffffe          BL       OS_CPU_SR_Restore
00004c  2043              MOVS     r0,#0x43              ;766
00004e  7020              STRB     r0,[r4,#0]            ;766
000050  e7e2              B        |L56.24|
                  |L56.82|
000052  64ef              STR      r7,[r5,#0x4c]         ;769
000054  4640              MOV      r0,r8                 ;770
000056  f7fffffe          BL       OS_CPU_SR_Restore
00005a  2000              MOVS     r0,#0                 ;771
00005c  7020              STRB     r0,[r4,#0]            ;771
00005e  bf00              NOP      
000060  e7da              B        |L56.24|
;;;773    #endif
                          ENDP

000062  0000              DCW      0x0000
                  |L56.100|
                          DCD      OSIntNesting
                  |L56.104|
                          DCD      OSTCBCur
                  |L56.108|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSTaskQuery||, CODE, READONLY, ALIGN=2

                  OSTaskQuery PROC
;;;1019   #if OS_TASK_QUERY_EN > 0u
;;;1020   INT8U  OSTaskQuery (INT8U    prio,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1021                       OS_TCB  *p_task_data)
;;;1022   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;1023       OS_TCB    *ptcb;
;;;1024   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1025       OS_CPU_SR  cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;1026   #endif
;;;1027   
;;;1028   
;;;1029   
;;;1030   #if OS_ARG_CHK_EN > 0u
;;;1031       if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
;;;1032           if (prio != OS_PRIO_SELF) {
;;;1033               return (OS_ERR_PRIO_INVALID);
;;;1034           }
;;;1035       }
;;;1036       if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
;;;1037           return (OS_ERR_PDATA_NULL);
;;;1038       }
;;;1039   #endif
;;;1040       OS_ENTER_CRITICAL();
00000a  f7fffffe          BL       OS_CPU_SR_Save
00000e  4607              MOV      r7,r0
;;;1041       if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
000010  2dff              CMP      r5,#0xff
000012  d103              BNE      |L57.28|
;;;1042           prio = OSTCBCur->OSTCBPrio;
000014  480f              LDR      r0,|L57.84|
000016  6800              LDR      r0,[r0,#0]  ; OSTCBCur
000018  f8905032          LDRB     r5,[r0,#0x32]
                  |L57.28|
;;;1043       }
;;;1044       ptcb = OSTCBPrioTbl[prio];
00001c  480e              LDR      r0,|L57.88|
00001e  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;1045       if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
000022  b92c              CBNZ     r4,|L57.48|
;;;1046           OS_EXIT_CRITICAL();
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       OS_CPU_SR_Restore
;;;1047           return (OS_ERR_PRIO);
00002a  2029              MOVS     r0,#0x29
                  |L57.44|
;;;1048       }
;;;1049       if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
;;;1050           OS_EXIT_CRITICAL();
;;;1051           return (OS_ERR_TASK_NOT_EXIST);
;;;1052       }
;;;1053                                                    /* Copy TCB into user storage area                    */
;;;1054       OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
;;;1055       OS_EXIT_CRITICAL();
;;;1056       return (OS_ERR_NONE);
;;;1057   }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L57.48|
000030  2c01              CMP      r4,#1                 ;1049
000032  d104              BNE      |L57.62|
000034  4638              MOV      r0,r7                 ;1050
000036  f7fffffe          BL       OS_CPU_SR_Restore
00003a  2043              MOVS     r0,#0x43              ;1051
00003c  e7f6              B        |L57.44|
                  |L57.62|
00003e  2254              MOVS     r2,#0x54              ;1054
000040  4621              MOV      r1,r4                 ;1054
000042  4630              MOV      r0,r6                 ;1054
000044  f7fffffe          BL       OS_MemCopy
000048  4638              MOV      r0,r7                 ;1055
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2000              MOVS     r0,#0                 ;1056
000050  e7ec              B        |L57.44|
;;;1058   #endif
                          ENDP

000052  0000              DCW      0x0000
                  |L57.84|
                          DCD      OSTCBCur
                  |L57.88|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSTaskRegGet||, CODE, READONLY, ALIGN=2

                  OSTaskRegGet PROC
;;;1086   #if OS_TASK_REG_TBL_SIZE > 0u
;;;1087   INT32U  OSTaskRegGet (INT8U   prio,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1088                         INT8U   id,
;;;1089                         INT8U  *perr)
;;;1090   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1091   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1092       OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0900          MOV      r9,#0
;;;1093   #endif
;;;1094       INT32U     value;
;;;1095       OS_TCB    *ptcb;
;;;1096   
;;;1097   
;;;1098   #if OS_ARG_CHK_EN > 0u
;;;1099       if (prio >= OS_LOWEST_PRIO) {
;;;1100           if (prio != OS_PRIO_SELF) {
;;;1101               *perr = OS_ERR_PRIO_INVALID;
;;;1102               return (0u);
;;;1103           }
;;;1104       }
;;;1105       if (id >= OS_TASK_REG_TBL_SIZE) {
;;;1106           *perr = OS_ERR_ID_INVALID;
;;;1107           return (0u);
;;;1108       }
;;;1109   #endif
;;;1110       OS_ENTER_CRITICAL();
00000e  f7fffffe          BL       OS_CPU_SR_Save
000012  4681              MOV      r9,r0
;;;1111       if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
000014  2cff              CMP      r4,#0xff
000016  d102              BNE      |L58.30|
;;;1112           ptcb = OSTCBCur;
000018  4808              LDR      r0,|L58.60|
00001a  6805              LDR      r5,[r0,#0]  ; OSTCBCur
00001c  e002              B        |L58.36|
                  |L58.30|
;;;1113       } else {
;;;1114           ptcb = OSTCBPrioTbl[prio];
00001e  4808              LDR      r0,|L58.64|
000020  f8505024          LDR      r5,[r0,r4,LSL #2]
                  |L58.36|
;;;1115       }
;;;1116       value = ptcb->OSTCBRegTbl[id];
000024  f1050050          ADD      r0,r5,#0x50
000028  f8508026          LDR      r8,[r0,r6,LSL #2]
;;;1117       OS_EXIT_CRITICAL();
00002c  4648              MOV      r0,r9
00002e  f7fffffe          BL       OS_CPU_SR_Restore
;;;1118       *perr = OS_ERR_NONE;
000032  2000              MOVS     r0,#0
000034  7038              STRB     r0,[r7,#0]
;;;1119       return (value);
000036  4640              MOV      r0,r8
;;;1120   }
000038  e8bd87f0          POP      {r4-r10,pc}
;;;1121   #endif
                          ENDP

                  |L58.60|
                          DCD      OSTCBCur
                  |L58.64|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSTaskRegSet||, CODE, READONLY, ALIGN=2

                  OSTaskRegSet PROC
;;;1152   #if OS_TASK_REG_TBL_SIZE > 0u
;;;1153   void  OSTaskRegSet (INT8U    prio,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1154                       INT8U    id,
;;;1155                       INT32U   value,
;;;1156                       INT8U   *perr)
;;;1157   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1158   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1159       OS_CPU_SR  cpu_sr = 0u;
00000c  f04f0900          MOV      r9,#0
;;;1160   #endif
;;;1161       OS_TCB    *ptcb;
;;;1162   
;;;1163   
;;;1164   #if OS_ARG_CHK_EN > 0u
;;;1165       if (prio >= OS_LOWEST_PRIO) {
;;;1166           if (prio != OS_PRIO_SELF) {
;;;1167               *perr = OS_ERR_PRIO_INVALID;
;;;1168               return;
;;;1169           }
;;;1170       }
;;;1171       if (id >= OS_TASK_REG_TBL_SIZE) {
;;;1172           *perr = OS_ERR_ID_INVALID;
;;;1173           return;
;;;1174       }
;;;1175   #endif
;;;1176       OS_ENTER_CRITICAL();
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4681              MOV      r9,r0
;;;1177       if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
000016  2cff              CMP      r4,#0xff
000018  d102              BNE      |L59.32|
;;;1178           ptcb = OSTCBCur;
00001a  4809              LDR      r0,|L59.64|
00001c  6805              LDR      r5,[r0,#0]  ; OSTCBCur
00001e  e002              B        |L59.38|
                  |L59.32|
;;;1179       } else {
;;;1180           ptcb = OSTCBPrioTbl[prio];
000020  4808              LDR      r0,|L59.68|
000022  f8505024          LDR      r5,[r0,r4,LSL #2]
                  |L59.38|
;;;1181       }
;;;1182       ptcb->OSTCBRegTbl[id] = value;
000026  f1050050          ADD      r0,r5,#0x50
00002a  f8407026          STR      r7,[r0,r6,LSL #2]
;;;1183       OS_EXIT_CRITICAL();
00002e  4648              MOV      r0,r9
000030  f7fffffe          BL       OS_CPU_SR_Restore
;;;1184       *perr                 = OS_ERR_NONE;
000034  2000              MOVS     r0,#0
000036  f8880000          STRB     r0,[r8,#0]
;;;1185   }
00003a  e8bd87f0          POP      {r4-r10,pc}
;;;1186   #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L59.64|
                          DCD      OSTCBCur
                  |L59.68|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSTaskResume||, CODE, READONLY, ALIGN=2

                  OSTaskResume PROC
;;;794    #if OS_TASK_SUSPEND_EN > 0u
;;;795    INT8U  OSTaskResume (INT8U prio)
000000  b570              PUSH     {r4-r6,lr}
;;;796    {
000002  4605              MOV      r5,r0
;;;797        OS_TCB    *ptcb;
;;;798    #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
;;;799        OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;800    #endif
;;;801    
;;;802    
;;;803    
;;;804    #if OS_ARG_CHK_EN > 0u
;;;805        if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
;;;806            return (OS_ERR_PRIO_INVALID);
;;;807        }
;;;808    #endif
;;;809        OS_ENTER_CRITICAL();
000006  f7fffffe          BL       OS_CPU_SR_Save
00000a  4606              MOV      r6,r0
;;;810        ptcb = OSTCBPrioTbl[prio];
00000c  4823              LDR      r0,|L60.156|
00000e  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;811        if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
000012  b924              CBNZ     r4,|L60.30|
;;;812            OS_EXIT_CRITICAL();
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       OS_CPU_SR_Restore
;;;813            return (OS_ERR_TASK_RESUME_PRIO);
00001a  2046              MOVS     r0,#0x46
                  |L60.28|
;;;814        }
;;;815        if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
;;;816            OS_EXIT_CRITICAL();
;;;817            return (OS_ERR_TASK_NOT_EXIST);
;;;818        }
;;;819        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
;;;820            ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
;;;821            if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
;;;822                if (ptcb->OSTCBDly == 0u) {
;;;823                    OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
;;;824                    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;825                    OS_EXIT_CRITICAL();
;;;826                    if (OSRunning == OS_TRUE) {
;;;827                        OS_Sched();                               /* Find new highest priority task        */
;;;828                    }
;;;829                } else {
;;;830                    OS_EXIT_CRITICAL();
;;;831                }
;;;832            } else {                                              /* Must be pending on event              */
;;;833                OS_EXIT_CRITICAL();
;;;834            }
;;;835            return (OS_ERR_NONE);
;;;836        }
;;;837        OS_EXIT_CRITICAL();
;;;838        return (OS_ERR_TASK_NOT_SUSPENDED);
;;;839    }
00001c  bd70              POP      {r4-r6,pc}
                  |L60.30|
00001e  2c01              CMP      r4,#1                 ;815
000020  d104              BNE      |L60.44|
000022  4630              MOV      r0,r6                 ;816
000024  f7fffffe          BL       OS_CPU_SR_Restore
000028  2043              MOVS     r0,#0x43              ;817
00002a  e7f7              B        |L60.28|
                  |L60.44|
00002c  f8940030          LDRB     r0,[r4,#0x30]         ;819
000030  f0000008          AND      r0,r0,#8              ;819
000034  b360              CBZ      r0,|L60.144|
000036  f8140f30          LDRB     r0,[r4,#0x30]!        ;820
00003a  f00000f7          AND      r0,r0,#0xf7           ;820
00003e  7020              STRB     r0,[r4,#0]            ;820
000040  f8140930          LDRB     r0,[r4],#-0x30        ;821
000044  b9f8              CBNZ     r0,|L60.134|
000046  6ae0              LDR      r0,[r4,#0x2c]         ;822
000048  b9c8              CBNZ     r0,|L60.126|
00004a  3434              ADDS     r4,r4,#0x34           ;823
00004c  78a0              LDRB     r0,[r4,#2]            ;823
00004e  4914              LDR      r1,|L60.160|
000050  7809              LDRB     r1,[r1,#0]            ;823  ; OSRdyGrp
000052  4308              ORRS     r0,r0,r1              ;823
000054  4912              LDR      r1,|L60.160|
000056  7008              STRB     r0,[r1,#0]            ;823
000058  7820              LDRB     r0,[r4,#0]            ;824
00005a  4912              LDR      r1,|L60.164|
00005c  5c08              LDRB     r0,[r1,r0]            ;824
00005e  7861              LDRB     r1,[r4,#1]            ;824
000060  4308              ORRS     r0,r0,r1              ;824
000062  f8141934          LDRB     r1,[r4],#-0x34        ;824
000066  4a0f              LDR      r2,|L60.164|
000068  5450              STRB     r0,[r2,r1]            ;824
00006a  4630              MOV      r0,r6                 ;825
00006c  f7fffffe          BL       OS_CPU_SR_Restore
000070  480d              LDR      r0,|L60.168|
000072  7800              LDRB     r0,[r0,#0]            ;826  ; OSRunning
000074  2801              CMP      r0,#1                 ;826
000076  d109              BNE      |L60.140|
000078  f7fffffe          BL       OS_Sched
00007c  e006              B        |L60.140|
                  |L60.126|
00007e  4630              MOV      r0,r6                 ;830
000080  f7fffffe          BL       OS_CPU_SR_Restore
000084  e002              B        |L60.140|
                  |L60.134|
000086  4630              MOV      r0,r6                 ;833
000088  f7fffffe          BL       OS_CPU_SR_Restore
                  |L60.140|
00008c  2000              MOVS     r0,#0                 ;835
00008e  e7c5              B        |L60.28|
                  |L60.144|
000090  4630              MOV      r0,r6                 ;837
000092  f7fffffe          BL       OS_CPU_SR_Restore
000096  2044              MOVS     r0,#0x44              ;838
000098  e7c0              B        |L60.28|
;;;840    #endif
                          ENDP

00009a  0000              DCW      0x0000
                  |L60.156|
                          DCD      OSTCBPrioTbl
                  |L60.160|
                          DCD      OSRdyGrp
                  |L60.164|
                          DCD      OSRdyTbl
                  |L60.168|
                          DCD      OSRunning

                          AREA ||i.OSTaskStkChk||, CODE, READONLY, ALIGN=2

                  OSTaskStkChk PROC
;;;861    #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;862    INT8U  OSTaskStkChk (INT8U         prio,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;863                         OS_STK_DATA  *p_stk_data)
;;;864    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;865        OS_TCB    *ptcb;
;;;866        OS_STK    *pchk;
;;;867        INT32U     nfree;
;;;868        INT32U     size;
;;;869    #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
;;;870        OS_CPU_SR  cpu_sr = 0u;
000008  f04f0a00          MOV      r10,#0
;;;871    #endif
;;;872    
;;;873    
;;;874    
;;;875    #if OS_ARG_CHK_EN > 0u
;;;876        if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
;;;877            if (prio != OS_PRIO_SELF) {
;;;878                return (OS_ERR_PRIO_INVALID);
;;;879            }
;;;880        }
;;;881        if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
;;;882            return (OS_ERR_PDATA_NULL);
;;;883        }
;;;884    #endif
;;;885        p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
00000c  2000              MOVS     r0,#0
00000e  6028              STR      r0,[r5,#0]
;;;886        p_stk_data->OSUsed = 0u;
000010  6068              STR      r0,[r5,#4]
;;;887        OS_ENTER_CRITICAL();
000012  f7fffffe          BL       OS_CPU_SR_Save
000016  4682              MOV      r10,r0
;;;888        if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
000018  2fff              CMP      r7,#0xff
00001a  d103              BNE      |L61.36|
;;;889            prio = OSTCBCur->OSTCBPrio;
00001c  4819              LDR      r0,|L61.132|
00001e  6800              LDR      r0,[r0,#0]  ; OSTCBCur
000020  f8907032          LDRB     r7,[r0,#0x32]
                  |L61.36|
;;;890        }
;;;891        ptcb = OSTCBPrioTbl[prio];
000024  4818              LDR      r0,|L61.136|
000026  f8504027          LDR      r4,[r0,r7,LSL #2]
;;;892        if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
00002a  b92c              CBNZ     r4,|L61.56|
;;;893            OS_EXIT_CRITICAL();
00002c  4650              MOV      r0,r10
00002e  f7fffffe          BL       OS_CPU_SR_Restore
;;;894            return (OS_ERR_TASK_NOT_EXIST);
000032  2043              MOVS     r0,#0x43
                  |L61.52|
;;;895        }
;;;896        if (ptcb == OS_TCB_RESERVED) {
;;;897            OS_EXIT_CRITICAL();
;;;898            return (OS_ERR_TASK_NOT_EXIST);
;;;899        }
;;;900        if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
;;;901            OS_EXIT_CRITICAL();
;;;902            return (OS_ERR_TASK_OPT);
;;;903        }
;;;904        nfree = 0u;
;;;905        size  = ptcb->OSTCBStkSize;
;;;906        pchk  = ptcb->OSTCBStkBottom;
;;;907        OS_EXIT_CRITICAL();
;;;908    #if OS_STK_GROWTH == 1u
;;;909        while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
;;;910            nfree++;
;;;911        }
;;;912    #else
;;;913        while (*pchk-- == (OS_STK)0) {
;;;914            nfree++;
;;;915        }
;;;916    #endif
;;;917        p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
;;;918        p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
;;;919        return (OS_ERR_NONE);
;;;920    }
000034  e8bd87f0          POP      {r4-r10,pc}
                  |L61.56|
000038  2c01              CMP      r4,#1                 ;896
00003a  d104              BNE      |L61.70|
00003c  4650              MOV      r0,r10                ;897
00003e  f7fffffe          BL       OS_CPU_SR_Restore
000042  2043              MOVS     r0,#0x43              ;898
000044  e7f6              B        |L61.52|
                  |L61.70|
000046  7c20              LDRB     r0,[r4,#0x10]         ;900
000048  f0000001          AND      r0,r0,#1              ;900
00004c  b920              CBNZ     r0,|L61.88|
00004e  4650              MOV      r0,r10                ;901
000050  f7fffffe          BL       OS_CPU_SR_Restore
000054  2045              MOVS     r0,#0x45              ;902
000056  e7ed              B        |L61.52|
                  |L61.88|
000058  2600              MOVS     r6,#0                 ;904
00005a  f8d4900c          LDR      r9,[r4,#0xc]          ;905
00005e  f8d48008          LDR      r8,[r4,#8]            ;906
000062  4650              MOV      r0,r10                ;907
000064  f7fffffe          BL       OS_CPU_SR_Restore
000068  e000              B        |L61.108|
                  |L61.106|
00006a  1c76              ADDS     r6,r6,#1              ;910
                  |L61.108|
00006c  f8581b04          LDR      r1,[r8],#4            ;909
000070  2900              CMP      r1,#0                 ;909
000072  d0fa              BEQ      |L61.106|
000074  00b0              LSLS     r0,r6,#2              ;917
000076  6028              STR      r0,[r5,#0]            ;917
000078  eba90006          SUB      r0,r9,r6              ;918
00007c  0080              LSLS     r0,r0,#2              ;918
00007e  6068              STR      r0,[r5,#4]            ;918
000080  2000              MOVS     r0,#0                 ;919
000082  e7d7              B        |L61.52|
;;;921    #endif
                          ENDP

                  |L61.132|
                          DCD      OSTCBCur
                  |L61.136|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSTaskSuspend||, CODE, READONLY, ALIGN=2

                  OSTaskSuspend PROC
;;;946    #if OS_TASK_SUSPEND_EN > 0u
;;;947    INT8U  OSTaskSuspend (INT8U prio)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;948    {
000004  4605              MOV      r5,r0
;;;949        BOOLEAN    self;
;;;950        OS_TCB    *ptcb;
;;;951        INT8U      y;
;;;952    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;953        OS_CPU_SR  cpu_sr = 0u;
000006  f04f0800          MOV      r8,#0
;;;954    #endif
;;;955    
;;;956    
;;;957    
;;;958    #if OS_ARG_CHK_EN > 0u
;;;959        if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
;;;960            return (OS_ERR_TASK_SUSPEND_IDLE);
;;;961        }
;;;962        if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
;;;963            if (prio != OS_PRIO_SELF) {
;;;964                return (OS_ERR_PRIO_INVALID);
;;;965            }
;;;966        }
;;;967    #endif
;;;968        OS_ENTER_CRITICAL();
00000a  f7fffffe          BL       OS_CPU_SR_Save
00000e  4680              MOV      r8,r0
;;;969        if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
000010  2dff              CMP      r5,#0xff
000012  d105              BNE      |L62.32|
;;;970            prio = OSTCBCur->OSTCBPrio;
000014  4820              LDR      r0,|L62.152|
000016  6800              LDR      r0,[r0,#0]  ; OSTCBCur
000018  f8905032          LDRB     r5,[r0,#0x32]
;;;971            self = OS_TRUE;
00001c  2601              MOVS     r6,#1
00001e  e008              B        |L62.50|
                  |L62.32|
;;;972        } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
000020  481d              LDR      r0,|L62.152|
000022  6800              LDR      r0,[r0,#0]  ; OSTCBCur
000024  f8900032          LDRB     r0,[r0,#0x32]
000028  42a8              CMP      r0,r5
00002a  d101              BNE      |L62.48|
;;;973            self = OS_TRUE;
00002c  2601              MOVS     r6,#1
00002e  e000              B        |L62.50|
                  |L62.48|
;;;974        } else {
;;;975            self = OS_FALSE;                                        /* No suspending another task          */
000030  2600              MOVS     r6,#0
                  |L62.50|
;;;976        }
;;;977        ptcb = OSTCBPrioTbl[prio];
000032  481a              LDR      r0,|L62.156|
000034  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;978        if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
000038  b92c              CBNZ     r4,|L62.70|
;;;979            OS_EXIT_CRITICAL();
00003a  4640              MOV      r0,r8
00003c  f7fffffe          BL       OS_CPU_SR_Restore
;;;980            return (OS_ERR_TASK_SUSPEND_PRIO);
000040  2048              MOVS     r0,#0x48
                  |L62.66|
;;;981        }
;;;982        if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
;;;983            OS_EXIT_CRITICAL();
;;;984            return (OS_ERR_TASK_NOT_EXIST);
;;;985        }
;;;986        y            = ptcb->OSTCBY;
;;;987        OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
;;;988        if (OSRdyTbl[y] == 0u) {
;;;989            OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
;;;990        }
;;;991        ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
;;;992        OS_EXIT_CRITICAL();
;;;993        if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
;;;994            OS_Sched();                                             /* Find new highest priority task      */
;;;995        }
;;;996        return (OS_ERR_NONE);
;;;997    }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L62.70|
000046  2c01              CMP      r4,#1                 ;982
000048  d104              BNE      |L62.84|
00004a  4640              MOV      r0,r8                 ;983
00004c  f7fffffe          BL       OS_CPU_SR_Restore
000050  2043              MOVS     r0,#0x43              ;984
000052  e7f6              B        |L62.66|
                  |L62.84|
000054  f8947034          LDRB     r7,[r4,#0x34]         ;986
000058  4811              LDR      r0,|L62.160|
00005a  5dc0              LDRB     r0,[r0,r7]            ;987
00005c  f8941035          LDRB     r1,[r4,#0x35]         ;987
000060  4388              BICS     r0,r0,r1              ;987
000062  490f              LDR      r1,|L62.160|
000064  55c8              STRB     r0,[r1,r7]            ;987
000066  4608              MOV      r0,r1                 ;988
000068  5dc0              LDRB     r0,[r0,r7]            ;988
00006a  b930              CBNZ     r0,|L62.122|
00006c  f8941036          LDRB     r1,[r4,#0x36]         ;989
000070  480c              LDR      r0,|L62.164|
000072  7800              LDRB     r0,[r0,#0]            ;989  ; OSRdyGrp
000074  4388              BICS     r0,r0,r1              ;989
000076  490b              LDR      r1,|L62.164|
000078  7008              STRB     r0,[r1,#0]            ;989
                  |L62.122|
00007a  f8940030          LDRB     r0,[r4,#0x30]         ;991
00007e  f0400008          ORR      r0,r0,#8              ;991
000082  f8840030          STRB     r0,[r4,#0x30]         ;991
000086  4640              MOV      r0,r8                 ;992
000088  f7fffffe          BL       OS_CPU_SR_Restore
00008c  2e01              CMP      r6,#1                 ;993
00008e  d101              BNE      |L62.148|
000090  f7fffffe          BL       OS_Sched
                  |L62.148|
000094  2000              MOVS     r0,#0                 ;996
000096  e7d4              B        |L62.66|
;;;998    #endif
                          ENDP

                  |L62.152|
                          DCD      OSTCBCur
                  |L62.156|
                          DCD      OSTCBPrioTbl
                  |L62.160|
                          DCD      OSRdyTbl
                  |L62.164|
                          DCD      OSRdyGrp

                          AREA ||i.OSTimeDly||, CODE, READONLY, ALIGN=2

                  OSTimeDly PROC
;;;43     
;;;44     void  OSTimeDly (INT32U ticks)
000000  b570              PUSH     {r4-r6,lr}
;;;45     {
000002  4605              MOV      r5,r0
;;;46         INT8U      y;
;;;47     #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;48         OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;49     #endif
;;;50     
;;;51     
;;;52     
;;;53         if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000006  4817              LDR      r0,|L63.100|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000a  b100              CBZ      r0,|L63.14|
                  |L63.12|
;;;54             return;
;;;55         }
;;;56         if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
;;;57             return;
;;;58         }
;;;59         if (ticks > 0u) {                            /* 0 means no delay!                                  */
;;;60             OS_ENTER_CRITICAL();
;;;61             y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
;;;62             OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
;;;63             if (OSRdyTbl[y] == 0u) {
;;;64                 OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
;;;65             }
;;;66             OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
;;;67             OS_EXIT_CRITICAL();
;;;68             OS_Sched();                              /* Find next task to run!                             */
;;;69         }
;;;70     }
00000c  bd70              POP      {r4-r6,pc}
                  |L63.14|
00000e  4816              LDR      r0,|L63.104|
000010  7800              LDRB     r0,[r0,#0]            ;56  ; OSLockNesting
000012  b100              CBZ      r0,|L63.22|
000014  e7fa              B        |L63.12|
                  |L63.22|
000016  b31d              CBZ      r5,|L63.96|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4606              MOV      r6,r0                 ;60
00001e  4813              LDR      r0,|L63.108|
000020  6800              LDR      r0,[r0,#0]            ;61  ; OSTCBCur
000022  f8904034          LDRB     r4,[r0,#0x34]         ;61
000026  4812              LDR      r0,|L63.112|
000028  5d00              LDRB     r0,[r0,r4]            ;62
00002a  4910              LDR      r1,|L63.108|
00002c  6809              LDR      r1,[r1,#0]            ;62  ; OSTCBCur
00002e  f8911035          LDRB     r1,[r1,#0x35]         ;62
000032  4388              BICS     r0,r0,r1              ;62
000034  490e              LDR      r1,|L63.112|
000036  5508              STRB     r0,[r1,r4]            ;62
000038  4608              MOV      r0,r1                 ;63
00003a  5d00              LDRB     r0,[r0,r4]            ;63
00003c  b940              CBNZ     r0,|L63.80|
00003e  480b              LDR      r0,|L63.108|
000040  6800              LDR      r0,[r0,#0]            ;64  ; OSTCBCur
000042  f8901036          LDRB     r1,[r0,#0x36]         ;64
000046  480b              LDR      r0,|L63.116|
000048  7800              LDRB     r0,[r0,#0]            ;64  ; OSRdyGrp
00004a  4388              BICS     r0,r0,r1              ;64
00004c  4909              LDR      r1,|L63.116|
00004e  7008              STRB     r0,[r1,#0]            ;64
                  |L63.80|
000050  4806              LDR      r0,|L63.108|
000052  6800              LDR      r0,[r0,#0]            ;66  ; OSTCBCur
000054  62c5              STR      r5,[r0,#0x2c]         ;66
000056  4630              MOV      r0,r6                 ;67
000058  f7fffffe          BL       OS_CPU_SR_Restore
00005c  f7fffffe          BL       OS_Sched
                  |L63.96|
000060  bf00              NOP      
000062  e7d3              B        |L63.12|
;;;71     /*$PAGE*/
                          ENDP

                  |L63.100|
                          DCD      OSIntNesting
                  |L63.104|
                          DCD      OSLockNesting
                  |L63.108|
                          DCD      OSTCBCur
                  |L63.112|
                          DCD      OSRdyTbl
                  |L63.116|
                          DCD      OSRdyGrp

                          AREA ||i.OSTimeDlyHMSM||, CODE, READONLY, ALIGN=2

                  OSTimeDlyHMSM PROC
;;;98     #if OS_TIME_DLY_HMSM_EN > 0u
;;;99     INT8U  OSTimeDlyHMSM (INT8U   hours,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;100                          INT8U   minutes,
;;;101                          INT8U   seconds,
;;;102                          INT16U  ms)
;;;103    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;104        INT32U ticks;
;;;105    
;;;106    
;;;107        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  4812              LDR      r0,|L64.88|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b110              CBZ      r0,|L64.24|
;;;108            return (OS_ERR_TIME_DLY_ISR);
000012  2055              MOVS     r0,#0x55
                  |L64.20|
;;;109        }
;;;110        if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
;;;111            return (OS_ERR_SCHED_LOCKED);
;;;112        }
;;;113    #if OS_ARG_CHK_EN > 0u
;;;114        if (hours == 0u) {
;;;115            if (minutes == 0u) {
;;;116                if (seconds == 0u) {
;;;117                    if (ms == 0u) {
;;;118                        return (OS_ERR_TIME_ZERO_DLY);
;;;119                    }
;;;120                }
;;;121            }
;;;122        }
;;;123        if (minutes > 59u) {
;;;124            return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
;;;125        }
;;;126        if (seconds > 59u) {
;;;127            return (OS_ERR_TIME_INVALID_SECONDS);
;;;128        }
;;;129        if (ms > 999u) {
;;;130            return (OS_ERR_TIME_INVALID_MS);
;;;131        }
;;;132    #endif
;;;133                                                     /* Compute the total number of clock ticks required.. */
;;;134                                                     /* .. (rounded to the nearest tick)                   */
;;;135        ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
;;;136              + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
;;;137        OSTimeDly(ticks);
;;;138        return (OS_ERR_NONE);
;;;139    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L64.24|
000018  4810              LDR      r0,|L64.92|
00001a  7800              LDRB     r0,[r0,#0]            ;110  ; OSLockNesting
00001c  b108              CBZ      r0,|L64.34|
00001e  2032              MOVS     r0,#0x32              ;111
000020  e7f8              B        |L64.20|
                  |L64.34|
000022  1cb8              ADDS     r0,r7,#2              ;135
000024  21c8              MOVS     r1,#0xc8              ;135
000026  4348              MULS     r0,r1,r0              ;135
000028  f44f717a          MOV      r1,#0x3e8             ;135
00002c  fbb0f1f1          UDIV     r1,r0,r1              ;135
000030  f44f6061          MOV      r0,#0xe10             ;135
000034  4360              MULS     r0,r4,r0              ;135
000036  ebc51205          RSB      r2,r5,r5,LSL #4       ;135
00003a  eb000082          ADD      r0,r0,r2,LSL #2       ;135
00003e  4430              ADD      r0,r0,r6              ;135
000040  eb0002c0          ADD      r2,r0,r0,LSL #3       ;135
000044  eb021000          ADD      r0,r2,r0,LSL #4       ;135
000048  eb0108c0          ADD      r8,r1,r0,LSL #3       ;135
00004c  4640              MOV      r0,r8                 ;137
00004e  f7fffffe          BL       OSTimeDly
000052  2000              MOVS     r0,#0                 ;138
000054  e7de              B        |L64.20|
;;;140    #endif
                          ENDP

000056  0000              DCW      0x0000
                  |L64.88|
                          DCD      OSIntNesting
                  |L64.92|
                          DCD      OSLockNesting

                          AREA ||i.OSTimeDlyResume||, CODE, READONLY, ALIGN=2

                  OSTimeDlyResume PROC
;;;161    #if OS_TIME_DLY_RESUME_EN > 0u
;;;162    INT8U  OSTimeDlyResume (INT8U prio)
000000  b570              PUSH     {r4-r6,lr}
;;;163    {
000002  4605              MOV      r5,r0
;;;164        OS_TCB    *ptcb;
;;;165    #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
;;;166        OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;167    #endif
;;;168    
;;;169    
;;;170    
;;;171        if (prio >= OS_LOWEST_PRIO) {
000006  2d3f              CMP      r5,#0x3f
000008  d301              BCC      |L65.14|
;;;172            return (OS_ERR_PRIO_INVALID);
00000a  202a              MOVS     r0,#0x2a
                  |L65.12|
;;;173        }
;;;174        OS_ENTER_CRITICAL();
;;;175        ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
;;;176        if (ptcb == (OS_TCB *)0) {
;;;177            OS_EXIT_CRITICAL();
;;;178            return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
;;;179        }
;;;180        if (ptcb == OS_TCB_RESERVED) {
;;;181            OS_EXIT_CRITICAL();
;;;182            return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
;;;183        }
;;;184        if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
;;;185            OS_EXIT_CRITICAL();
;;;186            return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
;;;187        }
;;;188    
;;;189        ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
;;;190        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;191            ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
;;;192            ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
;;;193        } else {
;;;194            ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
;;;195        }
;;;196        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
;;;197            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
;;;198            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;199            OS_EXIT_CRITICAL();
;;;200            OS_Sched();                                            /* See if this is new highest priority  */
;;;201        } else {
;;;202            OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
;;;203        }
;;;204        return (OS_ERR_NONE);
;;;205    }
00000c  bd70              POP      {r4-r6,pc}
                  |L65.14|
00000e  f7fffffe          BL       OS_CPU_SR_Save
000012  4606              MOV      r6,r0                 ;174
000014  4824              LDR      r0,|L65.168|
000016  f8504025          LDR      r4,[r0,r5,LSL #2]     ;175
00001a  b924              CBNZ     r4,|L65.38|
00001c  4630              MOV      r0,r6                 ;177
00001e  f7fffffe          BL       OS_CPU_SR_Restore
000022  2043              MOVS     r0,#0x43              ;178
000024  e7f2              B        |L65.12|
                  |L65.38|
000026  2c01              CMP      r4,#1                 ;180
000028  d104              BNE      |L65.52|
00002a  4630              MOV      r0,r6                 ;181
00002c  f7fffffe          BL       OS_CPU_SR_Restore
000030  2043              MOVS     r0,#0x43              ;182
000032  e7eb              B        |L65.12|
                  |L65.52|
000034  6ae0              LDR      r0,[r4,#0x2c]         ;184
000036  b920              CBNZ     r0,|L65.66|
000038  4630              MOV      r0,r6                 ;185
00003a  f7fffffe          BL       OS_CPU_SR_Restore
00003e  2050              MOVS     r0,#0x50              ;186
000040  e7e4              B        |L65.12|
                  |L65.66|
000042  2000              MOVS     r0,#0                 ;189
000044  62e0              STR      r0,[r4,#0x2c]         ;189
000046  f8940030          LDRB     r0,[r4,#0x30]         ;190
00004a  f0000037          AND      r0,r0,#0x37           ;190
00004e  b140              CBZ      r0,|L65.98|
000050  f8140f30          LDRB     r0,[r4,#0x30]!        ;191
000054  f0200037          BIC      r0,r0,#0x37           ;191
000058  7020              STRB     r0,[r4,#0]            ;191
00005a  2001              MOVS     r0,#1                 ;192
00005c  7060              STRB     r0,[r4,#1]            ;192
00005e  3c30              SUBS     r4,r4,#0x30           ;192
000060  e002              B        |L65.104|
                  |L65.98|
000062  2000              MOVS     r0,#0                 ;194
000064  f8840031          STRB     r0,[r4,#0x31]         ;194
                  |L65.104|
000068  f8940030          LDRB     r0,[r4,#0x30]         ;196
00006c  f0000008          AND      r0,r0,#8              ;196
000070  b9a8              CBNZ     r0,|L65.158|
000072  3434              ADDS     r4,r4,#0x34           ;197
000074  78a0              LDRB     r0,[r4,#2]            ;197
000076  490d              LDR      r1,|L65.172|
000078  7809              LDRB     r1,[r1,#0]            ;197  ; OSRdyGrp
00007a  4308              ORRS     r0,r0,r1              ;197
00007c  490b              LDR      r1,|L65.172|
00007e  7008              STRB     r0,[r1,#0]            ;197
000080  7820              LDRB     r0,[r4,#0]            ;198
000082  490b              LDR      r1,|L65.176|
000084  5c08              LDRB     r0,[r1,r0]            ;198
000086  7861              LDRB     r1,[r4,#1]            ;198
000088  4308              ORRS     r0,r0,r1              ;198
00008a  f8141934          LDRB     r1,[r4],#-0x34        ;198
00008e  4a08              LDR      r2,|L65.176|
000090  5450              STRB     r0,[r2,r1]            ;198
000092  4630              MOV      r0,r6                 ;199
000094  f7fffffe          BL       OS_CPU_SR_Restore
000098  f7fffffe          BL       OS_Sched
00009c  e002              B        |L65.164|
                  |L65.158|
00009e  4630              MOV      r0,r6                 ;202
0000a0  f7fffffe          BL       OS_CPU_SR_Restore
                  |L65.164|
0000a4  2000              MOVS     r0,#0                 ;204
0000a6  e7b1              B        |L65.12|
;;;206    #endif
                          ENDP

                  |L65.168|
                          DCD      OSTCBPrioTbl
                  |L65.172|
                          DCD      OSRdyGrp
                  |L65.176|
                          DCD      OSRdyTbl

                          AREA ||i.OSTimeGet||, CODE, READONLY, ALIGN=2

                  OSTimeGet PROC
;;;221    #if OS_TIME_GET_SET_EN > 0u
;;;222    INT32U  OSTimeGet (void)
000000  b570              PUSH     {r4-r6,lr}
;;;223    {
;;;224        INT32U     ticks;
;;;225    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;226        OS_CPU_SR  cpu_sr = 0u;
000002  2500              MOVS     r5,#0
;;;227    #endif
;;;228    
;;;229    
;;;230    
;;;231        OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4605              MOV      r5,r0
;;;232        ticks = OSTime;
00000a  4803              LDR      r0,|L66.24|
00000c  6804              LDR      r4,[r0,#0]  ; OSTime
;;;233        OS_EXIT_CRITICAL();
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       OS_CPU_SR_Restore
;;;234        return (ticks);
000014  4620              MOV      r0,r4
;;;235    }
000016  bd70              POP      {r4-r6,pc}
;;;236    #endif
                          ENDP

                  |L66.24|
                          DCD      OSTime

                          AREA ||i.OSTimeSet||, CODE, READONLY, ALIGN=2

                  OSTimeSet PROC
;;;250    #if OS_TIME_GET_SET_EN > 0u
;;;251    void  OSTimeSet (INT32U ticks)
000000  b570              PUSH     {r4-r6,lr}
;;;252    {
000002  4604              MOV      r4,r0
;;;253    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;254        OS_CPU_SR  cpu_sr = 0u;
000004  2500              MOVS     r5,#0
;;;255    #endif
;;;256    
;;;257    
;;;258    
;;;259        OS_ENTER_CRITICAL();
000006  f7fffffe          BL       OS_CPU_SR_Save
00000a  4605              MOV      r5,r0
;;;260        OSTime = ticks;
00000c  4802              LDR      r0,|L67.24|
00000e  6004              STR      r4,[r0,#0]  ; OSTime
;;;261        OS_EXIT_CRITICAL();
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       OS_CPU_SR_Restore
;;;262    }
000016  bd70              POP      {r4-r6,pc}
;;;263    #endif
                          ENDP

                  |L67.24|
                          DCD      OSTime

                          AREA ||i.OSTimeTick||, CODE, READONLY, ALIGN=2

                  OSTimeTick PROC
;;;888    
;;;889    void  OSTimeTick (void)
000000  b570              PUSH     {r4-r6,lr}
;;;890    {
;;;891        OS_TCB    *ptcb;
;;;892    #if OS_TICK_STEP_EN > 0u
;;;893        BOOLEAN    step;
;;;894    #endif
;;;895    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
;;;896        OS_CPU_SR  cpu_sr = 0u;
000002  2600              MOVS     r6,#0
;;;897    #endif
;;;898    
;;;899    
;;;900    
;;;901    #if OS_TIME_TICK_HOOK_EN > 0u
;;;902        OSTimeTickHook();                                      /* Call user definable hook                     */
000004  f7fffffe          BL       OSTimeTickHook
;;;903    #endif
;;;904    #if OS_TIME_GET_SET_EN > 0u
;;;905        OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
000008  f7fffffe          BL       OS_CPU_SR_Save
00000c  4606              MOV      r6,r0
;;;906        OSTime++;
00000e  4831              LDR      r0,|L68.212|
000010  6800              LDR      r0,[r0,#0]  ; OSTime
000012  1c40              ADDS     r0,r0,#1
000014  492f              LDR      r1,|L68.212|
000016  6008              STR      r0,[r1,#0]  ; OSTime
;;;907        OS_EXIT_CRITICAL();
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       OS_CPU_SR_Restore
;;;908    #endif
;;;909        if (OSRunning == OS_TRUE) {
00001e  482e              LDR      r0,|L68.216|
000020  7800              LDRB     r0,[r0,#0]  ; OSRunning
000022  2801              CMP      r0,#1
000024  d153              BNE      |L68.206|
;;;910    #if OS_TICK_STEP_EN > 0u
;;;911            switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
000026  482d              LDR      r0,|L68.220|
000028  7800              LDRB     r0,[r0,#0]  ; OSTickStepState
00002a  b120              CBZ      r0,|L68.54|
00002c  2801              CMP      r0,#1
00002e  d004              BEQ      |L68.58|
000030  2802              CMP      r0,#2
000032  d109              BNE      |L68.72|
000034  e003              B        |L68.62|
                  |L68.54|
;;;912                case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
;;;913                     step = OS_TRUE;
000036  2501              MOVS     r5,#1
;;;914                     break;
000038  e00b              B        |L68.82|
                  |L68.58|
;;;915    
;;;916                case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
;;;917                     step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
00003a  2500              MOVS     r5,#0
;;;918                     break;
00003c  e009              B        |L68.82|
                  |L68.62|
;;;919    
;;;920                case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
;;;921                     step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
00003e  2501              MOVS     r5,#1
;;;922                     OSTickStepState = OS_TICK_STEP_WAIT;
000040  2001              MOVS     r0,#1
000042  4926              LDR      r1,|L68.220|
000044  7008              STRB     r0,[r1,#0]
;;;923                     break;
000046  e004              B        |L68.82|
                  |L68.72|
;;;924    
;;;925                default:                                       /* Invalid case, correct situation              */
;;;926                     step            = OS_TRUE;
000048  2501              MOVS     r5,#1
;;;927                     OSTickStepState = OS_TICK_STEP_DIS;
00004a  2000              MOVS     r0,#0
00004c  4923              LDR      r1,|L68.220|
00004e  7008              STRB     r0,[r1,#0]
;;;928                     break;
000050  bf00              NOP      
                  |L68.82|
000052  bf00              NOP                            ;914
;;;929            }
;;;930            if (step == OS_FALSE) {                            /* Return if waiting for step command           */
000054  b905              CBNZ     r5,|L68.88|
                  |L68.86|
;;;931                return;
;;;932            }
;;;933    #endif
;;;934            ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
;;;935            while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
;;;936                OS_ENTER_CRITICAL();
;;;937                if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
;;;938                    ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
;;;939                    if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
;;;940    
;;;941                        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;942                            ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
;;;943                            ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
;;;944                        } else {
;;;945                            ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
;;;946                        }
;;;947    
;;;948                        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
;;;949                            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
;;;950                            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;951                        }
;;;952                    }
;;;953                }
;;;954                ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
;;;955                OS_EXIT_CRITICAL();
;;;956            }
;;;957        }
;;;958    }
000056  bd70              POP      {r4-r6,pc}
                  |L68.88|
000058  4821              LDR      r0,|L68.224|
00005a  6804              LDR      r4,[r0,#0]            ;934  ; OSTCBList
00005c  e033              B        |L68.198|
                  |L68.94|
00005e  f7fffffe          BL       OS_CPU_SR_Save
000062  4606              MOV      r6,r0                 ;936
000064  6ae0              LDR      r0,[r4,#0x2c]         ;937
000066  b350              CBZ      r0,|L68.190|
000068  6ae0              LDR      r0,[r4,#0x2c]         ;938
00006a  1e40              SUBS     r0,r0,#1              ;938
00006c  62e0              STR      r0,[r4,#0x2c]         ;938
00006e  6ae0              LDR      r0,[r4,#0x2c]         ;939
000070  bb28              CBNZ     r0,|L68.190|
000072  f8940030          LDRB     r0,[r4,#0x30]         ;941
000076  f0000037          AND      r0,r0,#0x37           ;941
00007a  b140              CBZ      r0,|L68.142|
00007c  f8140f30          LDRB     r0,[r4,#0x30]!        ;942
000080  f00000c8          AND      r0,r0,#0xc8           ;942
000084  7020              STRB     r0,[r4,#0]            ;942
000086  2001              MOVS     r0,#1                 ;943
000088  7060              STRB     r0,[r4,#1]            ;943
00008a  3c30              SUBS     r4,r4,#0x30           ;943
00008c  e002              B        |L68.148|
                  |L68.142|
00008e  2000              MOVS     r0,#0                 ;945
000090  f8840031          STRB     r0,[r4,#0x31]         ;945
                  |L68.148|
000094  f8940030          LDRB     r0,[r4,#0x30]         ;948
000098  f0000008          AND      r0,r0,#8              ;948
00009c  b978              CBNZ     r0,|L68.190|
00009e  3434              ADDS     r4,r4,#0x34           ;949
0000a0  78a0              LDRB     r0,[r4,#2]            ;949
0000a2  4910              LDR      r1,|L68.228|
0000a4  7809              LDRB     r1,[r1,#0]            ;949  ; OSRdyGrp
0000a6  4308              ORRS     r0,r0,r1              ;949
0000a8  490e              LDR      r1,|L68.228|
0000aa  7008              STRB     r0,[r1,#0]            ;949
0000ac  7820              LDRB     r0,[r4,#0]            ;950
0000ae  490e              LDR      r1,|L68.232|
0000b0  5c08              LDRB     r0,[r1,r0]            ;950
0000b2  7861              LDRB     r1,[r4,#1]            ;950
0000b4  4308              ORRS     r0,r0,r1              ;950
0000b6  f8141934          LDRB     r1,[r4],#-0x34        ;950
0000ba  4a0b              LDR      r2,|L68.232|
0000bc  5450              STRB     r0,[r2,r1]            ;950
                  |L68.190|
0000be  6964              LDR      r4,[r4,#0x14]         ;954
0000c0  4630              MOV      r0,r6                 ;955
0000c2  f7fffffe          BL       OS_CPU_SR_Restore
                  |L68.198|
0000c6  f8940032          LDRB     r0,[r4,#0x32]         ;935
0000ca  283f              CMP      r0,#0x3f              ;935
0000cc  d1c7              BNE      |L68.94|
                  |L68.206|
0000ce  bf00              NOP      
0000d0  e7c1              B        |L68.86|
;;;959    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L68.212|
                          DCD      OSTime
                  |L68.216|
                          DCD      OSRunning
                  |L68.220|
                          DCD      OSTickStepState
                  |L68.224|
                          DCD      OSTCBList
                  |L68.228|
                          DCD      OSRdyGrp
                  |L68.232|
                          DCD      OSRdyTbl

                          AREA ||i.OSVersion||, CODE, READONLY, ALIGN=1

                  OSVersion PROC
;;;974    
;;;975    INT16U  OSVersion (void)
000000  f2401023          MOV      r0,#0x123
;;;976    {
;;;977        return (OS_VERSION);
;;;978    }
000004  4770              BX       lr
;;;979    
                          ENDP


                          AREA ||i.OS_Dummy||, CODE, READONLY, ALIGN=1

                  OS_Dummy PROC
;;;993    #if OS_TASK_DEL_EN > 0u
;;;994    void  OS_Dummy (void)
000000  4770              BX       lr
;;;995    {
;;;996    }
;;;997    #endif
                          ENDP


                          AREA ||i.OS_EventTaskRdy||, CODE, READONLY, ALIGN=2

                  OS_EventTaskRdy PROC
;;;1027   #if (OS_EVENT_EN)
;;;1028   INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1029                           void      *pmsg,
;;;1030                           INT8U      msk,
;;;1031                           INT8U      pend_stat)
;;;1032   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;1033       OS_TCB   *ptcb;
;;;1034       INT8U     y;
;;;1035       INT8U     x;
;;;1036       INT8U     prio;
;;;1037   #if OS_LOWEST_PRIO > 63u
;;;1038       OS_PRIO  *ptbl;
;;;1039   #endif
;;;1040   
;;;1041   
;;;1042   #if OS_LOWEST_PRIO <= 63u
;;;1043       y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
00000c  7aa8              LDRB     r0,[r5,#0xa]
00000e  4919              LDR      r1,|L71.116|
000010  5c0e              LDRB     r6,[r1,r0]
;;;1044       x    = OSUnMapTbl[pevent->OSEventTbl[y]];
000012  f105000b          ADD      r0,r5,#0xb
000016  5d80              LDRB     r0,[r0,r6]
000018  f811b000          LDRB     r11,[r1,r0]
;;;1045       prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
00001c  eb0b00c6          ADD      r0,r11,r6,LSL #3
000020  f0000aff          AND      r10,r0,#0xff
;;;1046   #else
;;;1047       if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
;;;1048           y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
;;;1049       } else {
;;;1050           y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
;;;1051       }
;;;1052       ptbl = &pevent->OSEventTbl[y];
;;;1053       if ((*ptbl & 0xFFu) != 0u) {
;;;1054           x = OSUnMapTbl[*ptbl & 0xFFu];
;;;1055       } else {
;;;1056           x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
;;;1057       }
;;;1058       prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
;;;1059   #endif
;;;1060   
;;;1061       ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
000024  4814              LDR      r0,|L71.120|
000026  f850402a          LDR      r4,[r0,r10,LSL #2]
;;;1062       ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
00002a  2000              MOVS     r0,#0
00002c  3420              ADDS     r4,r4,#0x20
00002e  60e0              STR      r0,[r4,#0xc]
;;;1063   #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
;;;1064       ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
000030  6027              STR      r7,[r4,#0]
;;;1065   #else
;;;1066       pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
;;;1067   #endif
;;;1068       ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
000032  7c20              LDRB     r0,[r4,#0x10]
000034  ea200008          BIC      r0,r0,r8
000038  7420              STRB     r0,[r4,#0x10]
;;;1069       ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
00003a  f8849011          STRB     r9,[r4,#0x11]
;;;1070                                                           /* See if task is ready (could be susp'd)      */
;;;1071       if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
00003e  7c20              LDRB     r0,[r4,#0x10]
000040  3c20              SUBS     r4,r4,#0x20
000042  f0000008          AND      r0,r0,#8
000046  b968              CBNZ     r0,|L71.100|
;;;1072           OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
000048  f8940036          LDRB     r0,[r4,#0x36]
00004c  490b              LDR      r1,|L71.124|
00004e  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
000050  4308              ORRS     r0,r0,r1
000052  490a              LDR      r1,|L71.124|
000054  7008              STRB     r0,[r1,#0]
;;;1073           OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
000056  480a              LDR      r0,|L71.128|
000058  5d80              LDRB     r0,[r0,r6]
00005a  f8941035          LDRB     r1,[r4,#0x35]
00005e  4308              ORRS     r0,r0,r1
000060  4907              LDR      r1,|L71.128|
000062  5588              STRB     r0,[r1,r6]
                  |L71.100|
;;;1074       }
;;;1075   
;;;1076       OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000064  4629              MOV      r1,r5
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       OS_EventTaskRemove
;;;1077   #if (OS_EVENT_MULTI_EN > 0u)
;;;1078       if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
;;;1079           OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
;;;1080           ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
;;;1081       }
;;;1082   #endif
;;;1083   
;;;1084       return (prio);
00006c  4650              MOV      r0,r10
;;;1085   }
00006e  e8bd8ff0          POP      {r4-r11,pc}
;;;1086   #endif
                          ENDP

000072  0000              DCW      0x0000
                  |L71.116|
                          DCD      OSUnMapTbl
                  |L71.120|
                          DCD      OSTCBPrioTbl
                  |L71.124|
                          DCD      OSRdyGrp
                  |L71.128|
                          DCD      OSRdyTbl

                          AREA ||i.OS_EventTaskRemove||, CODE, READONLY, ALIGN=1

                  OS_EventTaskRemove PROC
;;;1179   #if (OS_EVENT_EN)
;;;1180   void  OS_EventTaskRemove (OS_TCB   *ptcb,
000000  b510              PUSH     {r4,lr}
;;;1181                             OS_EVENT *pevent)
;;;1182   {
;;;1183       INT8U  y;
;;;1184   
;;;1185   
;;;1186       y                       =  ptcb->OSTCBY;
000002  f8902034          LDRB     r2,[r0,#0x34]
;;;1187       pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
000006  f101030b          ADD      r3,r1,#0xb
00000a  5c9b              LDRB     r3,[r3,r2]
00000c  f8904035          LDRB     r4,[r0,#0x35]
000010  43a3              BICS     r3,r3,r4
000012  f101040b          ADD      r4,r1,#0xb
000016  54a3              STRB     r3,[r4,r2]
;;;1188       if (pevent->OSEventTbl[y] == 0u) {
000018  4623              MOV      r3,r4
00001a  5c9b              LDRB     r3,[r3,r2]
00001c  b923              CBNZ     r3,|L72.40|
;;;1189           pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00001e  7a8b              LDRB     r3,[r1,#0xa]
000020  f8904036          LDRB     r4,[r0,#0x36]
000024  43a3              BICS     r3,r3,r4
000026  728b              STRB     r3,[r1,#0xa]
                  |L72.40|
;;;1190       }
;;;1191   }
000028  bd10              POP      {r4,pc}
;;;1192   #endif
                          ENDP


                          AREA ||i.OS_EventTaskWait||, CODE, READONLY, ALIGN=2

                  OS_EventTaskWait PROC
;;;1102   #if (OS_EVENT_EN)
;;;1103   void  OS_EventTaskWait (OS_EVENT *pevent)
000000  b510              PUSH     {r4,lr}
;;;1104   {
;;;1105       INT8U  y;
;;;1106   
;;;1107   
;;;1108       OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
000002  4a1b              LDR      r2,|L73.112|
000004  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000006  61d0              STR      r0,[r2,#0x1c]
;;;1109   
;;;1110       pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
000008  4a19              LDR      r2,|L73.112|
00000a  6812              LDR      r2,[r2,#0]  ; OSTCBCur
00000c  f8923034          LDRB     r3,[r2,#0x34]
000010  f100020b          ADD      r2,r0,#0xb
000014  5cd2              LDRB     r2,[r2,r3]
000016  4b16              LDR      r3,|L73.112|
000018  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00001a  f8933035          LDRB     r3,[r3,#0x35]
00001e  431a              ORRS     r2,r2,r3
000020  4b13              LDR      r3,|L73.112|
000022  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000024  f8934034          LDRB     r4,[r3,#0x34]
000028  f100030b          ADD      r3,r0,#0xb
00002c  551a              STRB     r2,[r3,r4]
;;;1111       pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00002e  7a82              LDRB     r2,[r0,#0xa]
000030  4b0f              LDR      r3,|L73.112|
000032  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000034  f8933036          LDRB     r3,[r3,#0x36]
000038  431a              ORRS     r2,r2,r3
00003a  7282              STRB     r2,[r0,#0xa]
;;;1112   
;;;1113       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00003c  4a0c              LDR      r2,|L73.112|
00003e  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000040  f8921034          LDRB     r1,[r2,#0x34]
;;;1114       OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000044  4a0b              LDR      r2,|L73.116|
000046  5c52              LDRB     r2,[r2,r1]
000048  4b09              LDR      r3,|L73.112|
00004a  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00004c  f8933035          LDRB     r3,[r3,#0x35]
000050  439a              BICS     r2,r2,r3
000052  4b08              LDR      r3,|L73.116|
000054  545a              STRB     r2,[r3,r1]
;;;1115       if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
000056  461a              MOV      r2,r3
000058  5c52              LDRB     r2,[r2,r1]
00005a  b942              CBNZ     r2,|L73.110|
;;;1116           OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00005c  4a04              LDR      r2,|L73.112|
00005e  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000060  f8923036          LDRB     r3,[r2,#0x36]
000064  4a04              LDR      r2,|L73.120|
000066  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
000068  439a              BICS     r2,r2,r3
00006a  4b03              LDR      r3,|L73.120|
00006c  701a              STRB     r2,[r3,#0]
                  |L73.110|
;;;1117       }
;;;1118   }
00006e  bd10              POP      {r4,pc}
;;;1119   #endif
                          ENDP

                  |L73.112|
                          DCD      OSTCBCur
                  |L73.116|
                          DCD      OSRdyTbl
                  |L73.120|
                          DCD      OSRdyGrp

                          AREA ||i.OS_EventWaitListInit||, CODE, READONLY, ALIGN=1

                  OS_EventWaitListInit PROC
;;;1249   #if (OS_EVENT_EN)
;;;1250   void  OS_EventWaitListInit (OS_EVENT *pevent)
000000  4601              MOV      r1,r0
;;;1251   {
;;;1252       INT8U  i;
;;;1253   
;;;1254   
;;;1255       pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
000002  2200              MOVS     r2,#0
000004  728a              STRB     r2,[r1,#0xa]
;;;1256       for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000006  2000              MOVS     r0,#0
000008  e005              B        |L74.22|
                  |L74.10|
;;;1257           pevent->OSEventTbl[i] = 0u;
00000a  2300              MOVS     r3,#0
00000c  f101020b          ADD      r2,r1,#0xb
000010  5413              STRB     r3,[r2,r0]
000012  1c42              ADDS     r2,r0,#1              ;1256
000014  b2d0              UXTB     r0,r2                 ;1256
                  |L74.22|
000016  2808              CMP      r0,#8                 ;1256
000018  d3f7              BCC      |L74.10|
;;;1258       }
;;;1259   }
00001a  4770              BX       lr
;;;1260   #endif
                          ENDP


                          AREA ||i.OS_FlagBlock||, CODE, READONLY, ALIGN=2

                  OS_FlagBlock PROC
;;;1024   
;;;1025   static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1026                               OS_FLAG_NODE *pnode,
;;;1027                               OS_FLAGS      flags,
;;;1028                               INT8U         wait_type,
;;;1029                               INT32U        timeout)
;;;1030   {
000002  4614              MOV      r4,r2
000004  9e05              LDR      r6,[sp,#0x14]
;;;1031       OS_FLAG_NODE  *pnode_next;
;;;1032       INT8U          y;
;;;1033   
;;;1034   
;;;1035       OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
000006  4f24              LDR      r7,|L75.152|
000008  683f              LDR      r7,[r7,#0]  ; OSTCBCur
00000a  f8977030          LDRB     r7,[r7,#0x30]
00000e  f0470720          ORR      r7,r7,#0x20
000012  f8dfc084          LDR      r12,|L75.152|
000016  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
00001a  f88c7030          STRB     r7,[r12,#0x30]
;;;1036       OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
00001e  2700              MOVS     r7,#0
000020  f8dfc074          LDR      r12,|L75.152|
000024  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
000028  f88c7031          STRB     r7,[r12,#0x31]
;;;1037       OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
00002c  4f1a              LDR      r7,|L75.152|
00002e  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000030  62fe              STR      r6,[r7,#0x2c]
;;;1038   #if OS_TASK_DEL_EN > 0u
;;;1039       OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
000032  4f19              LDR      r7,|L75.152|
000034  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000036  6279              STR      r1,[r7,#0x24]
;;;1040   #endif
;;;1041       pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
000038  820c              STRH     r4,[r1,#0x10]
;;;1042       pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
00003a  748b              STRB     r3,[r1,#0x12]
;;;1043       pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
00003c  4f16              LDR      r7,|L75.152|
00003e  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000040  608f              STR      r7,[r1,#8]
;;;1044       pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
000042  6847              LDR      r7,[r0,#4]
000044  600f              STR      r7,[r1,#0]
;;;1045       pnode->OSFlagNodePrev     = (void *)0;
000046  2700              MOVS     r7,#0
000048  604f              STR      r7,[r1,#4]
;;;1046       pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
00004a  60c8              STR      r0,[r1,#0xc]
;;;1047       pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
00004c  6845              LDR      r5,[r0,#4]
;;;1048       if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
00004e  b105              CBZ      r5,|L75.82|
;;;1049           pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
000050  6069              STR      r1,[r5,#4]
                  |L75.82|
;;;1050       }
;;;1051       pgrp->OSFlagWaitList = (void *)pnode;
000052  6041              STR      r1,[r0,#4]
;;;1052   
;;;1053       y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
000054  4f10              LDR      r7,|L75.152|
000056  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000058  f8972034          LDRB     r2,[r7,#0x34]
;;;1054       OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00005c  4f0f              LDR      r7,|L75.156|
00005e  5cbf              LDRB     r7,[r7,r2]
000060  f8dfc034          LDR      r12,|L75.152|
000064  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
000068  f89cc035          LDRB     r12,[r12,#0x35]
00006c  ea27070c          BIC      r7,r7,r12
000070  f8dfc028          LDR      r12,|L75.156|
000074  f80c7002          STRB     r7,[r12,r2]
;;;1055       if (OSRdyTbl[y] == 0x00u) {
000078  4667              MOV      r7,r12
00007a  5cbf              LDRB     r7,[r7,r2]
00007c  b95f              CBNZ     r7,|L75.150|
;;;1056           OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00007e  4f06              LDR      r7,|L75.152|
000080  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000082  f897c036          LDRB     r12,[r7,#0x36]
000086  4f06              LDR      r7,|L75.160|
000088  783f              LDRB     r7,[r7,#0]  ; OSRdyGrp
00008a  ea27070c          BIC      r7,r7,r12
00008e  f8dfc010          LDR      r12,|L75.160|
000092  f88c7000          STRB     r7,[r12,#0]
                  |L75.150|
;;;1057       }
;;;1058   }
000096  bdf0              POP      {r4-r7,pc}
;;;1059   
                          ENDP

                  |L75.152|
                          DCD      OSTCBCur
                  |L75.156|
                          DCD      OSRdyTbl
                  |L75.160|
                          DCD      OSRdyGrp

                          AREA ||i.OS_FlagInit||, CODE, READONLY, ALIGN=2

                  OS_FlagInit PROC
;;;1075   
;;;1076   void  OS_FlagInit (void)
000000  b570              PUSH     {r4-r6,lr}
;;;1077   {
;;;1078   #if OS_MAX_FLAGS == 1u
;;;1079       OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
;;;1080       OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;1081       OSFlagFreeList->OSFlagWaitList = (void *)0;
;;;1082       OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
;;;1083   #if OS_FLAG_NAME_EN > 0u
;;;1084       OSFlagFreeList->OSFlagName     = (INT8U *)"?";
;;;1085   #endif
;;;1086   #endif
;;;1087   
;;;1088   #if OS_MAX_FLAGS >= 2u
;;;1089       INT16U        ix;
;;;1090       INT16U        ix_next;
;;;1091       OS_FLAG_GRP  *pgrp1;
;;;1092       OS_FLAG_GRP  *pgrp2;
;;;1093   
;;;1094   
;;;1095       OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
000002  2150              MOVS     r1,#0x50
000004  4810              LDR      r0,|L76.72|
000006  f7fffffe          BL       OS_MemClr
;;;1096       for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
00000a  2400              MOVS     r4,#0
00000c  e00d              B        |L76.42|
                  |L76.14|
;;;1097           ix_next = ix + 1u;
00000e  1c60              ADDS     r0,r4,#1
000010  b285              UXTH     r5,r0
;;;1098           pgrp1 = &OSFlagTbl[ix];
000012  480d              LDR      r0,|L76.72|
000014  eb001304          ADD      r3,r0,r4,LSL #4
;;;1099           pgrp2 = &OSFlagTbl[ix_next];
000018  eb001605          ADD      r6,r0,r5,LSL #4
;;;1100           pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00001c  2000              MOVS     r0,#0
00001e  7018              STRB     r0,[r3,#0]
;;;1101           pgrp1->OSFlagWaitList = (void *)pgrp2;
000020  605e              STR      r6,[r3,#4]
;;;1102   #if OS_FLAG_NAME_EN > 0u
;;;1103           pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
000022  a00a              ADR      r0,|L76.76|
000024  60d8              STR      r0,[r3,#0xc]
000026  1c60              ADDS     r0,r4,#1              ;1096
000028  b284              UXTH     r4,r0                 ;1096
                  |L76.42|
00002a  2c04              CMP      r4,#4                 ;1096
00002c  d3ef              BCC      |L76.14|
;;;1104   #endif
;;;1105       }
;;;1106       pgrp1                 = &OSFlagTbl[ix];
00002e  4806              LDR      r0,|L76.72|
000030  eb001304          ADD      r3,r0,r4,LSL #4
;;;1107       pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
000034  2000              MOVS     r0,#0
000036  7018              STRB     r0,[r3,#0]
;;;1108       pgrp1->OSFlagWaitList = (void *)0;
000038  6058              STR      r0,[r3,#4]
;;;1109   #if OS_FLAG_NAME_EN > 0u
;;;1110       pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
00003a  a004              ADR      r0,|L76.76|
00003c  60d8              STR      r0,[r3,#0xc]
;;;1111   #endif
;;;1112       OSFlagFreeList        = &OSFlagTbl[0];
00003e  4802              LDR      r0,|L76.72|
000040  4903              LDR      r1,|L76.80|
000042  6008              STR      r0,[r1,#0]  ; OSFlagFreeList
;;;1113   #endif
;;;1114   }
000044  bd70              POP      {r4-r6,pc}
;;;1115   
                          ENDP

000046  0000              DCW      0x0000
                  |L76.72|
                          DCD      OSFlagTbl
                  |L76.76|
00004c  3f00              DCB      "?",0
00004e  00                DCB      0
00004f  00                DCB      0
                  |L76.80|
                          DCD      OSFlagFreeList

                          AREA ||i.OS_FlagTaskRdy||, CODE, READONLY, ALIGN=2

                  OS_FlagTaskRdy PROC
;;;1139   
;;;1140   static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1141                                    OS_FLAGS      flags_rdy)
;;;1142   {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;1143       OS_TCB   *ptcb;
;;;1144       BOOLEAN   sched;
;;;1145   
;;;1146   
;;;1147       ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
000006  68b4              LDR      r4,[r6,#8]
;;;1148       ptcb->OSTCBDly       = 0u;
000008  2000              MOVS     r0,#0
00000a  3428              ADDS     r4,r4,#0x28
00000c  6060              STR      r0,[r4,#4]
;;;1149       ptcb->OSTCBFlagsRdy  = flags_rdy;
00000e  8027              STRH     r7,[r4,#0]
;;;1150       ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
000010  7a20              LDRB     r0,[r4,#8]
000012  f00000df          AND      r0,r0,#0xdf
000016  7220              STRB     r0,[r4,#8]
;;;1151       ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
000018  2000              MOVS     r0,#0
00001a  7260              STRB     r0,[r4,#9]
;;;1152       if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
00001c  7a20              LDRB     r0,[r4,#8]
00001e  3c28              SUBS     r4,r4,#0x28
000020  b988              CBNZ     r0,|L77.70|
;;;1153           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
000022  3434              ADDS     r4,r4,#0x34
000024  78a0              LDRB     r0,[r4,#2]
000026  490b              LDR      r1,|L77.84|
000028  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
00002a  4308              ORRS     r0,r0,r1
00002c  4909              LDR      r1,|L77.84|
00002e  7008              STRB     r0,[r1,#0]
;;;1154           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000030  7820              LDRB     r0,[r4,#0]
000032  4909              LDR      r1,|L77.88|
000034  5c08              LDRB     r0,[r1,r0]
000036  7861              LDRB     r1,[r4,#1]
000038  4308              ORRS     r0,r0,r1
00003a  f8141934          LDRB     r1,[r4],#-0x34
00003e  4a06              LDR      r2,|L77.88|
000040  5450              STRB     r0,[r2,r1]
;;;1155           sched                   = OS_TRUE;
000042  2501              MOVS     r5,#1
000044  e000              B        |L77.72|
                  |L77.70|
;;;1156       } else {
;;;1157           sched                   = OS_FALSE;
000046  2500              MOVS     r5,#0
                  |L77.72|
;;;1158       }
;;;1159       OS_FlagUnlink(pnode);
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       OS_FlagUnlink
;;;1160       return (sched);
00004e  4628              MOV      r0,r5
;;;1161   }
000050  bdf0              POP      {r4-r7,pc}
;;;1162   
                          ENDP

000052  0000              DCW      0x0000
                  |L77.84|
                          DCD      OSRdyGrp
                  |L77.88|
                          DCD      OSRdyTbl

                          AREA ||i.OS_FlagUnlink||, CODE, READONLY, ALIGN=1

                  OS_FlagUnlink PROC
;;;1184   
;;;1185   void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
000000  b530              PUSH     {r4,r5,lr}
;;;1186   {
000002  4601              MOV      r1,r0
;;;1187   #if OS_TASK_DEL_EN > 0u
;;;1188       OS_TCB       *ptcb;
;;;1189   #endif
;;;1190       OS_FLAG_GRP  *pgrp;
;;;1191       OS_FLAG_NODE *pnode_prev;
;;;1192       OS_FLAG_NODE *pnode_next;
;;;1193   
;;;1194   
;;;1195       pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
000004  684a              LDR      r2,[r1,#4]
;;;1196       pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
000006  6808              LDR      r0,[r1,#0]
;;;1197       if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
000008  b92a              CBNZ     r2,|L78.22|
;;;1198           pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
00000a  68cc              LDR      r4,[r1,#0xc]
;;;1199           pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
00000c  6060              STR      r0,[r4,#4]
;;;1200           if (pnode_next != (OS_FLAG_NODE *)0) {
00000e  b128              CBZ      r0,|L78.28|
;;;1201               pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
000010  2500              MOVS     r5,#0
000012  6045              STR      r5,[r0,#4]
000014  e002              B        |L78.28|
                  |L78.22|
;;;1202           }
;;;1203       } else {                                                    /* No,  A node somewhere in the list   */
;;;1204           pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
000016  6010              STR      r0,[r2,#0]
;;;1205           if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
000018  b100              CBZ      r0,|L78.28|
;;;1206               pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
00001a  6042              STR      r2,[r0,#4]
                  |L78.28|
;;;1207           }
;;;1208       }
;;;1209   #if OS_TASK_DEL_EN > 0u
;;;1210       ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
00001c  688b              LDR      r3,[r1,#8]
;;;1211       ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
00001e  2500              MOVS     r5,#0
000020  625d              STR      r5,[r3,#0x24]
;;;1212   #endif
;;;1213   }
000022  bd30              POP      {r4,r5,pc}
;;;1214   #endif
                          ENDP


                          AREA ||i.OS_InitEventList||, CODE, READONLY, ALIGN=2

                  OS_InitEventList PROC
;;;1274   
;;;1275   static  void  OS_InitEventList (void)
000000  b570              PUSH     {r4-r6,lr}
;;;1276   {
;;;1277   #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
;;;1278   #if (OS_MAX_EVENTS > 1u)
;;;1279       INT16U     ix;
;;;1280       INT16U     ix_next;
;;;1281       OS_EVENT  *pevent1;
;;;1282       OS_EVENT  *pevent2;
;;;1283   
;;;1284   
;;;1285       OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
000002  21c8              MOVS     r1,#0xc8
000004  4811              LDR      r0,|L79.76|
000006  f7fffffe          BL       OS_MemClr
;;;1286       for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
00000a  2300              MOVS     r3,#0
00000c  e00f              B        |L79.46|
                  |L79.14|
;;;1287           ix_next = ix + 1u;
00000e  1c58              ADDS     r0,r3,#1
000010  b285              UXTH     r5,r0
;;;1288           pevent1 = &OSEventTbl[ix];
000012  eb030083          ADD      r0,r3,r3,LSL #2
000016  490d              LDR      r1,|L79.76|
000018  eb010480          ADD      r4,r1,r0,LSL #2
;;;1289           pevent2 = &OSEventTbl[ix_next];
00001c  eb050085          ADD      r0,r5,r5,LSL #2
000020  eb010680          ADD      r6,r1,r0,LSL #2
;;;1290           pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
000024  2000              MOVS     r0,#0
000026  7020              STRB     r0,[r4,#0]
;;;1291           pevent1->OSEventPtr     = pevent2;
000028  6066              STR      r6,[r4,#4]
00002a  1c58              ADDS     r0,r3,#1              ;1286
00002c  b283              UXTH     r3,r0                 ;1286
                  |L79.46|
00002e  2b09              CMP      r3,#9                 ;1286
000030  d3ed              BCC      |L79.14|
;;;1292   #if OS_EVENT_NAME_EN > 0u
;;;1293           pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
;;;1294   #endif
;;;1295       }
;;;1296       pevent1                         = &OSEventTbl[ix];
000032  eb030083          ADD      r0,r3,r3,LSL #2
000036  4905              LDR      r1,|L79.76|
000038  eb010480          ADD      r4,r1,r0,LSL #2
;;;1297       pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
00003c  2000              MOVS     r0,#0
00003e  7020              STRB     r0,[r4,#0]
;;;1298       pevent1->OSEventPtr             = (OS_EVENT *)0;
000040  6060              STR      r0,[r4,#4]
;;;1299   #if OS_EVENT_NAME_EN > 0u
;;;1300       pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
;;;1301   #endif
;;;1302       OSEventFreeList                 = &OSEventTbl[0];
000042  4608              MOV      r0,r1
000044  4902              LDR      r1,|L79.80|
000046  6008              STR      r0,[r1,#0]  ; OSEventFreeList
;;;1303   #else
;;;1304       OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
;;;1305       OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1306       OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
;;;1307   #if OS_EVENT_NAME_EN > 0u
;;;1308       OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
;;;1309   #endif
;;;1310   #endif
;;;1311   #endif
;;;1312   }
000048  bd70              POP      {r4-r6,pc}
;;;1313   /*$PAGE*/
                          ENDP

00004a  0000              DCW      0x0000
                  |L79.76|
                          DCD      OSEventTbl
                  |L79.80|
                          DCD      OSEventFreeList

                          AREA ||i.OS_InitMisc||, CODE, READONLY, ALIGN=2

                  OS_InitMisc PROC
;;;1326   
;;;1327   static  void  OS_InitMisc (void)
000000  2000              MOVS     r0,#0
;;;1328   {
;;;1329   #if OS_TIME_GET_SET_EN > 0u
;;;1330       OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
000002  490a              LDR      r1,|L80.44|
000004  6008              STR      r0,[r1,#0]  ; OSTime
;;;1331   #endif
;;;1332   
;;;1333       OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
000006  490a              LDR      r1,|L80.48|
000008  7008              STRB     r0,[r1,#0]
;;;1334       OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
00000a  490a              LDR      r1,|L80.52|
00000c  7008              STRB     r0,[r1,#0]
;;;1335   
;;;1336       OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
00000e  490a              LDR      r1,|L80.56|
000010  7008              STRB     r0,[r1,#0]
;;;1337   
;;;1338       OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
000012  490a              LDR      r1,|L80.60|
000014  7008              STRB     r0,[r1,#0]
;;;1339   
;;;1340       OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
000016  490a              LDR      r1,|L80.64|
000018  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1341       OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
00001a  490a              LDR      r1,|L80.68|
00001c  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1342   
;;;1343   #if OS_TASK_STAT_EN > 0u
;;;1344       OSIdleCtrRun              = 0uL;
00001e  490a              LDR      r1,|L80.72|
000020  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1345       OSIdleCtrMax              = 0uL;
000022  490a              LDR      r1,|L80.76|
000024  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1346       OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
000026  490a              LDR      r1,|L80.80|
000028  7008              STRB     r0,[r1,#0]
;;;1347   #endif
;;;1348   
;;;1349   #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;1350       OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
;;;1351   #endif
;;;1352   }
00002a  4770              BX       lr
;;;1353   /*$PAGE*/
                          ENDP

                  |L80.44|
                          DCD      OSTime
                  |L80.48|
                          DCD      OSIntNesting
                  |L80.52|
                          DCD      OSLockNesting
                  |L80.56|
                          DCD      OSTaskCtr
                  |L80.60|
                          DCD      OSRunning
                  |L80.64|
                          DCD      OSCtxSwCtr
                  |L80.68|
                          DCD      OSIdleCtr
                  |L80.72|
                          DCD      OSIdleCtrRun
                  |L80.76|
                          DCD      OSIdleCtrMax
                  |L80.80|
                          DCD      OSStatRdy

                          AREA ||i.OS_InitRdyList||, CODE, READONLY, ALIGN=2

                  OS_InitRdyList PROC
;;;1366   
;;;1367   static  void  OS_InitRdyList (void)
000000  2100              MOVS     r1,#0
;;;1368   {
;;;1369       INT8U  i;
;;;1370   
;;;1371   
;;;1372       OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
000002  4a0a              LDR      r2,|L81.44|
000004  7011              STRB     r1,[r2,#0]
;;;1373       for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
000006  2000              MOVS     r0,#0
000008  e004              B        |L81.20|
                  |L81.10|
;;;1374           OSRdyTbl[i] = 0u;
00000a  2100              MOVS     r1,#0
00000c  4a08              LDR      r2,|L81.48|
00000e  5411              STRB     r1,[r2,r0]
000010  1c41              ADDS     r1,r0,#1              ;1373
000012  b2c8              UXTB     r0,r1                 ;1373
                  |L81.20|
000014  2808              CMP      r0,#8                 ;1373
000016  d3f8              BCC      |L81.10|
;;;1375       }
;;;1376   
;;;1377       OSPrioCur     = 0u;
000018  2100              MOVS     r1,#0
00001a  4a06              LDR      r2,|L81.52|
00001c  7011              STRB     r1,[r2,#0]
;;;1378       OSPrioHighRdy = 0u;
00001e  4a06              LDR      r2,|L81.56|
000020  7011              STRB     r1,[r2,#0]
;;;1379   
;;;1380       OSTCBHighRdy  = (OS_TCB *)0;
000022  4a06              LDR      r2,|L81.60|
000024  6011              STR      r1,[r2,#0]  ; OSTCBHighRdy
;;;1381       OSTCBCur      = (OS_TCB *)0;
000026  4a06              LDR      r2,|L81.64|
000028  6011              STR      r1,[r2,#0]  ; OSTCBCur
;;;1382   }
00002a  4770              BX       lr
;;;1383   
                          ENDP

                  |L81.44|
                          DCD      OSRdyGrp
                  |L81.48|
                          DCD      OSRdyTbl
                  |L81.52|
                          DCD      OSPrioCur
                  |L81.56|
                          DCD      OSPrioHighRdy
                  |L81.60|
                          DCD      OSTCBHighRdy
                  |L81.64|
                          DCD      OSTCBCur

                          AREA ||i.OS_InitTCBList||, CODE, READONLY, ALIGN=2

                  OS_InitTCBList PROC
;;;1521   
;;;1522   static  void  OS_InitTCBList (void)
000000  b570              PUSH     {r4-r6,lr}
;;;1523   {
;;;1524       INT8U    ix;
;;;1525       INT8U    ix_next;
;;;1526       OS_TCB  *ptcb1;
;;;1527       OS_TCB  *ptcb2;
;;;1528   
;;;1529   
;;;1530       OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
000002  f44f717c          MOV      r1,#0x3f0
000006  4819              LDR      r0,|L82.108|
000008  f7fffffe          BL       OS_MemClr
;;;1531       OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
00000c  f44f7180          MOV      r1,#0x100
000010  4817              LDR      r0,|L82.112|
000012  f7fffffe          BL       OS_MemClr
;;;1532       for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
000016  2400              MOVS     r4,#0
000018  e013              B        |L82.66|
                  |L82.26|
;;;1533           ix_next =  ix + 1u;
00001a  1c60              ADDS     r0,r4,#1
00001c  b2c5              UXTB     r5,r0
;;;1534           ptcb1   = &OSTCBTbl[ix];
00001e  ebc400c4          RSB      r0,r4,r4,LSL #3
000022  eb000040          ADD      r0,r0,r0,LSL #1
000026  4911              LDR      r1,|L82.108|
000028  eb010380          ADD      r3,r1,r0,LSL #2
;;;1535           ptcb2   = &OSTCBTbl[ix_next];
00002c  ebc500c5          RSB      r0,r5,r5,LSL #3
000030  eb000040          ADD      r0,r0,r0,LSL #1
000034  eb010680          ADD      r6,r1,r0,LSL #2
;;;1536           ptcb1->OSTCBNext = ptcb2;
000038  615e              STR      r6,[r3,#0x14]
;;;1537   #if OS_TASK_NAME_EN > 0u
;;;1538           ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
00003a  a00e              ADR      r0,|L82.116|
00003c  64d8              STR      r0,[r3,#0x4c]
00003e  1c60              ADDS     r0,r4,#1              ;1532
000040  b2c4              UXTB     r4,r0                 ;1532
                  |L82.66|
000042  2c0b              CMP      r4,#0xb               ;1532
000044  d3e9              BCC      |L82.26|
;;;1539   #endif
;;;1540       }
;;;1541       ptcb1                   = &OSTCBTbl[ix];
000046  ebc400c4          RSB      r0,r4,r4,LSL #3
00004a  eb000040          ADD      r0,r0,r0,LSL #1
00004e  4907              LDR      r1,|L82.108|
000050  eb010380          ADD      r3,r1,r0,LSL #2
;;;1542       ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
000054  2000              MOVS     r0,#0
000056  6158              STR      r0,[r3,#0x14]
;;;1543   #if OS_TASK_NAME_EN > 0u
;;;1544       ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
000058  a006              ADR      r0,|L82.116|
00005a  64d8              STR      r0,[r3,#0x4c]
;;;1545   #endif
;;;1546       OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
00005c  2000              MOVS     r0,#0
00005e  4906              LDR      r1,|L82.120|
000060  6008              STR      r0,[r1,#0]  ; OSTCBList
;;;1547       OSTCBFreeList           = &OSTCBTbl[0];
000062  4802              LDR      r0,|L82.108|
000064  4905              LDR      r1,|L82.124|
000066  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1548   }
000068  bd70              POP      {r4-r6,pc}
;;;1549   /*$PAGE*/
                          ENDP

00006a  0000              DCW      0x0000
                  |L82.108|
                          DCD      OSTCBTbl
                  |L82.112|
                          DCD      OSTCBPrioTbl
                  |L82.116|
000074  3f00              DCB      "?",0
000076  00                DCB      0
000077  00                DCB      0
                  |L82.120|
                          DCD      OSTCBList
                  |L82.124|
                          DCD      OSTCBFreeList

                          AREA ||i.OS_InitTaskIdle||, CODE, READONLY, ALIGN=2

                  OS_InitTaskIdle PROC
;;;1397   
;;;1398   static  void  OS_InitTaskIdle (void)
000000  b500              PUSH     {lr}
;;;1399   {
000002  b087              SUB      sp,sp,#0x1c
;;;1400   #if OS_TASK_NAME_EN > 0u
;;;1401       INT8U  err;
;;;1402   #endif
;;;1403   
;;;1404   
;;;1405   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1406       #if OS_STK_GROWTH == 1u
;;;1407       (void)OSTaskCreateExt(OS_TaskIdle,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  2280              MOVS     r2,#0x80
00000a  4b0a              LDR      r3,|L83.52|
00000c  e9cd3201          STRD     r3,r2,[sp,#4]
000010  e9cd1003          STRD     r1,r0,[sp,#0xc]
000014  f64f70ff          MOV      r0,#0xffff
000018  233f              MOVS     r3,#0x3f
00001a  4a07              LDR      r2,|L83.56|
00001c  9000              STR      r0,[sp,#0]
00001e  4807              LDR      r0,|L83.60|
000020  f7fffffe          BL       OSTaskCreateExt
;;;1408                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1409                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
;;;1410                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1411                             OS_TASK_IDLE_ID,
;;;1412                             &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
;;;1413                             OS_TASK_IDLE_STK_SIZE,
;;;1414                             (void *)0,                                 /* No TCB extension                     */
;;;1415                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1416       #else
;;;1417       (void)OSTaskCreateExt(OS_TaskIdle,
;;;1418                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1419                             &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
;;;1420                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1421                             OS_TASK_IDLE_ID,
;;;1422                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
;;;1423                             OS_TASK_IDLE_STK_SIZE,
;;;1424                             (void *)0,                                 /* No TCB extension                     */
;;;1425                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1426       #endif
;;;1427   #else
;;;1428       #if OS_STK_GROWTH == 1u
;;;1429       (void)OSTaskCreate(OS_TaskIdle,
;;;1430                          (void *)0,
;;;1431                          &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
;;;1432                          OS_TASK_IDLE_PRIO);
;;;1433       #else
;;;1434       (void)OSTaskCreate(OS_TaskIdle,
;;;1435                          (void *)0,
;;;1436                          &OSTaskIdleStk[0],
;;;1437                          OS_TASK_IDLE_PRIO);
;;;1438       #endif
;;;1439   #endif
;;;1440   
;;;1441   #if OS_TASK_NAME_EN > 0u
;;;1442       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a106              ADR      r1,|L83.64|
000028  203f              MOVS     r0,#0x3f
00002a  f7fffffe          BL       OSTaskNameSet
;;;1443   #endif
;;;1444   }
00002e  b007              ADD      sp,sp,#0x1c
000030  bd00              POP      {pc}
;;;1445   /*$PAGE*/
                          ENDP

000032  0000              DCW      0x0000
                  |L83.52|
                          DCD      OSTaskIdleStk
                  |L83.56|
                          DCD      OSTaskIdleStk+0x1fc
                  |L83.60|
                          DCD      OS_TaskIdle
                  |L83.64|
000040  75432f4f          DCB      "uC/OS-II Idle",0
000044  532d4949
000048  2049646c
00004c  6500    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.OS_InitTaskStat||, CODE, READONLY, ALIGN=2

                  OS_InitTaskStat PROC
;;;1459   #if OS_TASK_STAT_EN > 0u
;;;1460   static  void  OS_InitTaskStat (void)
000000  b500              PUSH     {lr}
;;;1461   {
000002  b087              SUB      sp,sp,#0x1c
;;;1462   #if OS_TASK_NAME_EN > 0u
;;;1463       INT8U  err;
;;;1464   #endif
;;;1465   
;;;1466   
;;;1467   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1468       #if OS_STK_GROWTH == 1u
;;;1469       (void)OSTaskCreateExt(OS_TaskStat,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  2280              MOVS     r2,#0x80
00000a  4b0a              LDR      r3,|L84.52|
00000c  e9cd3201          STRD     r3,r2,[sp,#4]
000010  e9cd1003          STRD     r1,r0,[sp,#0xc]
000014  f64f70fe          MOV      r0,#0xfffe
000018  233e              MOVS     r3,#0x3e
00001a  4a07              LDR      r2,|L84.56|
00001c  9000              STR      r0,[sp,#0]
00001e  4807              LDR      r0,|L84.60|
000020  f7fffffe          BL       OSTaskCreateExt
;;;1470                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1471                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
;;;1472                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1473                             OS_TASK_STAT_ID,
;;;1474                             &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
;;;1475                             OS_TASK_STAT_STK_SIZE,
;;;1476                             (void *)0,                                   /* No TCB extension               */
;;;1477                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1478       #else
;;;1479       (void)OSTaskCreateExt(OS_TaskStat,
;;;1480                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1481                             &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
;;;1482                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1483                             OS_TASK_STAT_ID,
;;;1484                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
;;;1485                             OS_TASK_STAT_STK_SIZE,
;;;1486                             (void *)0,                                   /* No TCB extension               */
;;;1487                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1488       #endif
;;;1489   #else
;;;1490       #if OS_STK_GROWTH == 1u
;;;1491       (void)OSTaskCreate(OS_TaskStat,
;;;1492                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1493                          &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
;;;1494                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1495       #else
;;;1496       (void)OSTaskCreate(OS_TaskStat,
;;;1497                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1498                          &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
;;;1499                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1500       #endif
;;;1501   #endif
;;;1502   
;;;1503   #if OS_TASK_NAME_EN > 0u
;;;1504       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a106              ADR      r1,|L84.64|
000028  203e              MOVS     r0,#0x3e
00002a  f7fffffe          BL       OSTaskNameSet
;;;1505   #endif
;;;1506   }
00002e  b007              ADD      sp,sp,#0x1c
000030  bd00              POP      {pc}
;;;1507   #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L84.52|
                          DCD      OSTaskStatStk
                  |L84.56|
                          DCD      OSTaskStatStk+0x1fc
                  |L84.60|
                          DCD      OS_TaskStat
                  |L84.64|
000040  75432f4f          DCB      "uC/OS-II Stat",0
000044  532d4949
000048  20537461
00004c  7400    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.OS_MemClr||, CODE, READONLY, ALIGN=1

                  OS_MemClr PROC
;;;1569   
;;;1570   void  OS_MemClr (INT8U  *pdest,
000000  e004              B        |L85.12|
                  |L85.2|
;;;1571                    INT16U  size)
;;;1572   {
;;;1573       while (size > 0u) {
;;;1574           *pdest++ = (INT8U)0;
000002  2200              MOVS     r2,#0
000004  f8002b01          STRB     r2,[r0],#1
;;;1575           size--;
000008  1e4a              SUBS     r2,r1,#1
00000a  b291              UXTH     r1,r2
                  |L85.12|
00000c  2900              CMP      r1,#0                 ;1573
00000e  d1f8              BNE      |L85.2|
;;;1576       }
;;;1577   }
000010  4770              BX       lr
;;;1578   /*$PAGE*/
                          ENDP


                          AREA ||i.OS_MemCopy||, CODE, READONLY, ALIGN=1

                  OS_MemCopy PROC
;;;1602   
;;;1603   void  OS_MemCopy (INT8U  *pdest,
000000  e005              B        |L86.14|
                  |L86.2|
;;;1604                     INT8U  *psrc,
;;;1605                     INT16U  size)
;;;1606   {
;;;1607       while (size > 0u) {
;;;1608           *pdest++ = *psrc++;
000002  f8113b01          LDRB     r3,[r1],#1
000006  f8003b01          STRB     r3,[r0],#1
;;;1609           size--;
00000a  1e53              SUBS     r3,r2,#1
00000c  b29a              UXTH     r2,r3
                  |L86.14|
00000e  2a00              CMP      r2,#0                 ;1607
000010  d1f7              BNE      |L86.2|
;;;1610       }
;;;1611   }
000012  4770              BX       lr
;;;1612   /*$PAGE*/
                          ENDP


                          AREA ||i.OS_QInit||, CODE, READONLY, ALIGN=2

                  OS_QInit PROC
;;;864    
;;;865    void  OS_QInit (void)
000000  b570              PUSH     {r4-r6,lr}
;;;866    {
;;;867    #if OS_MAX_QS == 1u
;;;868        OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
;;;869        OSQFreeList->OSQPtr = (OS_Q *)0;
;;;870    #endif
;;;871    
;;;872    #if OS_MAX_QS >= 2u
;;;873        INT16U   ix;
;;;874        INT16U   ix_next;
;;;875        OS_Q    *pq1;
;;;876        OS_Q    *pq2;
;;;877    
;;;878    
;;;879    
;;;880        OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
000002  2178              MOVS     r1,#0x78
000004  480f              LDR      r0,|L87.68|
000006  f7fffffe          BL       OS_MemClr
;;;881        for (ix = 0u; ix < (OS_MAX_QS - 1u); ix++) {     /* Init. list of free QUEUE control blocks        */
00000a  2300              MOVS     r3,#0
00000c  e00d              B        |L87.42|
                  |L87.14|
;;;882            ix_next = ix + 1u;
00000e  1c58              ADDS     r0,r3,#1
000010  b285              UXTH     r5,r0
;;;883            pq1 = &OSQTbl[ix];
000012  eb030043          ADD      r0,r3,r3,LSL #1
000016  490b              LDR      r1,|L87.68|
000018  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;884            pq2 = &OSQTbl[ix_next];
00001c  eb050045          ADD      r0,r5,r5,LSL #1
000020  eb0106c0          ADD      r6,r1,r0,LSL #3
;;;885            pq1->OSQPtr = pq2;
000024  6026              STR      r6,[r4,#0]
000026  1c58              ADDS     r0,r3,#1              ;881
000028  b283              UXTH     r3,r0                 ;881
                  |L87.42|
00002a  2b04              CMP      r3,#4                 ;881
00002c  d3ef              BCC      |L87.14|
;;;886        }
;;;887        pq1         = &OSQTbl[ix];
00002e  eb030043          ADD      r0,r3,r3,LSL #1
000032  4904              LDR      r1,|L87.68|
000034  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;888        pq1->OSQPtr = (OS_Q *)0;
000038  2000              MOVS     r0,#0
00003a  6020              STR      r0,[r4,#0]
;;;889        OSQFreeList = &OSQTbl[0];
00003c  4608              MOV      r0,r1
00003e  4902              LDR      r1,|L87.72|
000040  6008              STR      r0,[r1,#0]  ; OSQFreeList
;;;890    #endif
;;;891    }
000042  bd70              POP      {r4-r6,pc}
;;;892    #endif                                               /* OS_Q_EN                                        */
                          ENDP

                  |L87.68|
                          DCD      OSQTbl
                  |L87.72|
                          DCD      OSQFreeList

                          AREA ||i.OS_Sched||, CODE, READONLY, ALIGN=2

                  OS_Sched PROC
;;;1629   
;;;1630   void  OS_Sched (void)
000000  b510              PUSH     {r4,lr}
;;;1631   {
;;;1632   #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
;;;1633       OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;1634   #endif
;;;1635   
;;;1636   
;;;1637   
;;;1638       OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4604              MOV      r4,r0
;;;1639       if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
00000a  4813              LDR      r0,|L88.88|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000e  b9f8              CBNZ     r0,|L88.80|
;;;1640           if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
000010  4812              LDR      r0,|L88.92|
000012  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000014  b9e0              CBNZ     r0,|L88.80|
;;;1641               OS_SchedNew();
000016  f7fffffe          BL       OS_SchedNew
;;;1642               OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00001a  4811              LDR      r0,|L88.96|
00001c  4911              LDR      r1,|L88.100|
00001e  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000020  f8500021          LDR      r0,[r0,r1,LSL #2]
000024  4910              LDR      r1,|L88.104|
000026  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;1643               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
000028  480e              LDR      r0,|L88.100|
00002a  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
00002c  490f              LDR      r1,|L88.108|
00002e  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000030  4288              CMP      r0,r1
000032  d00d              BEQ      |L88.80|
;;;1644   #if OS_TASK_PROFILE_EN > 0u
;;;1645                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
000034  480c              LDR      r0,|L88.104|
000036  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000038  6b80              LDR      r0,[r0,#0x38]
00003a  1c40              ADDS     r0,r0,#1
00003c  490a              LDR      r1,|L88.104|
00003e  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000040  6388              STR      r0,[r1,#0x38]
;;;1646   #endif
;;;1647                   OSCtxSwCtr++;                          /* Increment context switch counter             */
000042  480b              LDR      r0,|L88.112|
000044  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
000046  1c40              ADDS     r0,r0,#1
000048  4909              LDR      r1,|L88.112|
00004a  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1648                   OS_TASK_SW();                          /* Perform a context switch                     */
00004c  f7fffffe          BL       OSCtxSw
                  |L88.80|
;;;1649               }
;;;1650           }
;;;1651       }
;;;1652       OS_EXIT_CRITICAL();
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       OS_CPU_SR_Restore
;;;1653   }
000056  bd10              POP      {r4,pc}
;;;1654   
                          ENDP

                  |L88.88|
                          DCD      OSIntNesting
                  |L88.92|
                          DCD      OSLockNesting
                  |L88.96|
                          DCD      OSTCBPrioTbl
                  |L88.100|
                          DCD      OSPrioHighRdy
                  |L88.104|
                          DCD      OSTCBHighRdy
                  |L88.108|
                          DCD      OSPrioCur
                  |L88.112|
                          DCD      OSCtxSwCtr

                          AREA ||i.OS_SchedNew||, CODE, READONLY, ALIGN=2

                  OS_SchedNew PROC
;;;1671   
;;;1672   static  void  OS_SchedNew (void)
000000  4906              LDR      r1,|L89.28|
;;;1673   {
;;;1674   #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
;;;1675       INT8U   y;
;;;1676   
;;;1677   
;;;1678       y             = OSUnMapTbl[OSRdyGrp];
000002  4a07              LDR      r2,|L89.32|
000004  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
000006  5c88              LDRB     r0,[r1,r2]
;;;1679       OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
000008  4906              LDR      r1,|L89.36|
00000a  5c09              LDRB     r1,[r1,r0]
00000c  4a03              LDR      r2,|L89.28|
00000e  5c51              LDRB     r1,[r2,r1]
000010  eb0101c0          ADD      r1,r1,r0,LSL #3
000014  4a04              LDR      r2,|L89.40|
000016  7011              STRB     r1,[r2,#0]
;;;1680   #else                                            /* We support up to 256 tasks                         */
;;;1681       INT8U     y;
;;;1682       OS_PRIO  *ptbl;
;;;1683   
;;;1684   
;;;1685       if ((OSRdyGrp & 0xFFu) != 0u) {
;;;1686           y = OSUnMapTbl[OSRdyGrp & 0xFFu];
;;;1687       } else {
;;;1688           y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
;;;1689       }
;;;1690       ptbl = &OSRdyTbl[y];
;;;1691       if ((*ptbl & 0xFFu) != 0u) {
;;;1692           OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
;;;1693       } else {
;;;1694           OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
;;;1695       }
;;;1696   #endif
;;;1697   }
000018  4770              BX       lr
;;;1698   
                          ENDP

00001a  0000              DCW      0x0000
                  |L89.28|
                          DCD      OSUnMapTbl
                  |L89.32|
                          DCD      OSRdyGrp
                  |L89.36|
                          DCD      OSRdyTbl
                  |L89.40|
                          DCD      OSPrioHighRdy

                          AREA ||i.OS_StrLen||, CODE, READONLY, ALIGN=1

                  OS_StrLen PROC
;;;1716   #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
;;;1717   INT8U  OS_StrLen (INT8U *psrc)
000000  4601              MOV      r1,r0
;;;1718   {
;;;1719       INT8U  len;
;;;1720   
;;;1721   
;;;1722       len = 0u;
000002  2000              MOVS     r0,#0
;;;1723       while (*psrc != OS_ASCII_NUL) {
000004  e002              B        |L90.12|
                  |L90.6|
;;;1724           psrc++;
000006  1c49              ADDS     r1,r1,#1
;;;1725           len++;
000008  1c42              ADDS     r2,r0,#1
00000a  b2d0              UXTB     r0,r2
                  |L90.12|
00000c  780a              LDRB     r2,[r1,#0]            ;1723
00000e  2a00              CMP      r2,#0                 ;1723
000010  d1f9              BNE      |L90.6|
;;;1726       }
;;;1727       return (len);
;;;1728   }
000012  4770              BX       lr
;;;1729   #endif
                          ENDP


                          AREA ||i.OS_TCBInit||, CODE, READONLY, ALIGN=2

                  OS_TCBInit PROC
;;;1916   
;;;1917   INT8U  OS_TCBInit (INT8U    prio,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1918                      OS_STK  *ptos,
;;;1919                      OS_STK  *pbos,
;;;1920                      INT16U   id,
;;;1921                      INT32U   stk_size,
;;;1922                      void    *pext,
;;;1923                      INT16U   opt)
;;;1924   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;1925       OS_TCB    *ptcb;
;;;1926   #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;1927       OS_CPU_SR  cpu_sr = 0u;
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;1928   #endif
;;;1929   #if OS_TASK_REG_TBL_SIZE > 0u
;;;1930       INT8U      i;
;;;1931   #endif
;;;1932   
;;;1933   
;;;1934       OS_ENTER_CRITICAL();
000014  f7fffffe          BL       OS_CPU_SR_Save
000018  9000              STR      r0,[sp,#0]
;;;1935       ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
00001a  483f              LDR      r0,|L91.280|
00001c  6804              LDR      r4,[r0,#0]  ; OSTCBFreeList
;;;1936       if (ptcb != (OS_TCB *)0) {
00001e  2c00              CMP      r4,#0
000020  d074              BEQ      |L91.268|
;;;1937           OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
000022  3418              ADDS     r4,r4,#0x18
000024  f8540c04          LDR      r0,[r4,#-4]
000028  493b              LDR      r1,|L91.280|
00002a  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1938           OS_EXIT_CRITICAL();
00002c  9800              LDR      r0,[sp,#0]
00002e  f7fffffe          BL       OS_CPU_SR_Restore
;;;1939           ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
000032  f8447c18          STR      r7,[r4,#-0x18]
;;;1940           ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
000036  76a5              STRB     r5,[r4,#0x1a]
;;;1941           ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
000038  2000              MOVS     r0,#0
00003a  7620              STRB     r0,[r4,#0x18]
;;;1942           ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
00003c  7660              STRB     r0,[r4,#0x19]
;;;1943           ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
00003e  6160              STR      r0,[r4,#0x14]
;;;1944   
;;;1945   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1946           ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
000040  f844bc14          STR      r11,[r4,#-0x14]
;;;1947           ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
000044  f844ac0c          STR      r10,[r4,#-0xc]
;;;1948           ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
000048  f8448c10          STR      r8,[r4,#-0x10]
;;;1949           ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
00004c  980c              LDR      r0,[sp,#0x30]
00004e  f8240c08          STRH     r0,[r4,#-8]
;;;1950           ptcb->OSTCBId            = id;                     /* Store task ID                            */
000052  f8249c06          STRH     r9,[r4,#-6]
;;;1951   #else
;;;1952           pext                     = pext;                   /* Prevent compiler warning if not used     */
;;;1953           stk_size                 = stk_size;
;;;1954           pbos                     = pbos;
;;;1955           opt                      = opt;
;;;1956           id                       = id;
;;;1957   #endif
;;;1958   
;;;1959   #if OS_TASK_DEL_EN > 0u
;;;1960           ptcb->OSTCBDelReq        = OS_ERR_NONE;
000056  2000              MOVS     r0,#0
000058  77e0              STRB     r0,[r4,#0x1f]
;;;1961   #endif
;;;1962   
;;;1963   #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
;;;1964           ptcb->OSTCBY             = (INT8U)(prio >> 3u);
00005a  10e8              ASRS     r0,r5,#3
00005c  7720              STRB     r0,[r4,#0x1c]
;;;1965           ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
00005e  f0050007          AND      r0,r5,#7
000062  76e0              STRB     r0,[r4,#0x1b]
;;;1966   #else                                                             /* Pre-compute X, Y                  */
;;;1967           ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
;;;1968           ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
;;;1969   #endif
;;;1970                                                                     /* Pre-compute BitX and BitY         */
;;;1971           ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
000064  7f21              LDRB     r1,[r4,#0x1c]
000066  2001              MOVS     r0,#1
000068  4088              LSLS     r0,r0,r1
00006a  77a0              STRB     r0,[r4,#0x1e]
;;;1972           ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
00006c  7ee1              LDRB     r1,[r4,#0x1b]
00006e  2001              MOVS     r0,#1
000070  4088              LSLS     r0,r0,r1
000072  7760              STRB     r0,[r4,#0x1d]
;;;1973   
;;;1974   #if (OS_EVENT_EN)
;;;1975           ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
000074  2000              MOVS     r0,#0
000076  6060              STR      r0,[r4,#4]
;;;1976   #if (OS_EVENT_MULTI_EN > 0u)
;;;1977           ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
;;;1978   #endif
;;;1979   #endif
;;;1980   
;;;1981   #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
;;;1982           ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
000078  60e0              STR      r0,[r4,#0xc]
;;;1983   #endif
;;;1984   
;;;1985   #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
;;;1986           ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
00007a  60a0              STR      r0,[r4,#8]
;;;1987   #endif
;;;1988   
;;;1989   #if OS_TASK_PROFILE_EN > 0u
;;;1990           ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
00007c  6220              STR      r0,[r4,#0x20]
;;;1991           ptcb->OSTCBCyclesStart = 0uL;
00007e  62a0              STR      r0,[r4,#0x28]
;;;1992           ptcb->OSTCBCyclesTot   = 0uL;
000080  6260              STR      r0,[r4,#0x24]
;;;1993           ptcb->OSTCBStkBase     = (OS_STK *)0;
000082  62e0              STR      r0,[r4,#0x2c]
;;;1994           ptcb->OSTCBStkUsed     = 0uL;
000084  6320              STR      r0,[r4,#0x30]
;;;1995   #endif
;;;1996   
;;;1997   #if OS_TASK_NAME_EN > 0u
;;;1998           ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
000086  a025              ADR      r0,|L91.284|
000088  6360              STR      r0,[r4,#0x34]
00008a  3c18              SUBS     r4,r4,#0x18
;;;1999   #endif
;;;2000   
;;;2001   #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
;;;2002           for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
00008c  2600              MOVS     r6,#0
00008e  e006              B        |L91.158|
                  |L91.144|
;;;2003               ptcb->OSTCBRegTbl[i] = 0u;
000090  2100              MOVS     r1,#0
000092  f1040050          ADD      r0,r4,#0x50
000096  f8401026          STR      r1,[r0,r6,LSL #2]
00009a  1c70              ADDS     r0,r6,#1              ;2002
00009c  b2c6              UXTB     r6,r0                 ;2002
                  |L91.158|
00009e  2e00              CMP      r6,#0                 ;2002
0000a0  d0f6              BEQ      |L91.144|
;;;2004           }
;;;2005   #endif
;;;2006   
;;;2007           OSTCBInitHook(ptcb);
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       OSTCBInitHook
;;;2008   
;;;2009           OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       OSTaskCreateHook
;;;2010   
;;;2011           OS_ENTER_CRITICAL();
0000ae  f7fffffe          BL       OS_CPU_SR_Save
0000b2  9000              STR      r0,[sp,#0]
;;;2012           OSTCBPrioTbl[prio] = ptcb;
0000b4  481a              LDR      r0,|L91.288|
0000b6  f8404025          STR      r4,[r0,r5,LSL #2]
;;;2013           ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
0000ba  481a              LDR      r0,|L91.292|
0000bc  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000be  6160              STR      r0,[r4,#0x14]
;;;2014           ptcb->OSTCBPrev    = (OS_TCB *)0;
0000c0  2000              MOVS     r0,#0
0000c2  61a0              STR      r0,[r4,#0x18]
;;;2015           if (OSTCBList != (OS_TCB *)0) {
0000c4  4817              LDR      r0,|L91.292|
0000c6  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000c8  b110              CBZ      r0,|L91.208|
;;;2016               OSTCBList->OSTCBPrev = ptcb;
0000ca  4816              LDR      r0,|L91.292|
0000cc  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000ce  6184              STR      r4,[r0,#0x18]
                  |L91.208|
;;;2017           }
;;;2018           OSTCBList               = ptcb;
0000d0  4814              LDR      r0,|L91.292|
0000d2  6004              STR      r4,[r0,#0]  ; OSTCBList
;;;2019           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
0000d4  3434              ADDS     r4,r4,#0x34
0000d6  78a0              LDRB     r0,[r4,#2]
0000d8  4913              LDR      r1,|L91.296|
0000da  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
0000dc  4308              ORRS     r0,r0,r1
0000de  4912              LDR      r1,|L91.296|
0000e0  7008              STRB     r0,[r1,#0]
;;;2020           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000e2  7820              LDRB     r0,[r4,#0]
0000e4  4911              LDR      r1,|L91.300|
0000e6  5c08              LDRB     r0,[r1,r0]
0000e8  7861              LDRB     r1,[r4,#1]
0000ea  4308              ORRS     r0,r0,r1
0000ec  f8141934          LDRB     r1,[r4],#-0x34
0000f0  4a0e              LDR      r2,|L91.300|
0000f2  5450              STRB     r0,[r2,r1]
;;;2021           OSTaskCtr++;                                       /* Increment the #tasks counter             */
0000f4  480e              LDR      r0,|L91.304|
0000f6  7800              LDRB     r0,[r0,#0]  ; OSTaskCtr
0000f8  1c40              ADDS     r0,r0,#1
0000fa  490d              LDR      r1,|L91.304|
0000fc  7008              STRB     r0,[r1,#0]
;;;2022           OS_EXIT_CRITICAL();
0000fe  9800              LDR      r0,[sp,#0]
000100  f7fffffe          BL       OS_CPU_SR_Restore
;;;2023           return (OS_ERR_NONE);
000104  2000              MOVS     r0,#0
                  |L91.262|
;;;2024       }
;;;2025       OS_EXIT_CRITICAL();
;;;2026       return (OS_ERR_TASK_NO_MORE_TCB);
;;;2027   }
000106  e8bd8ff8          POP      {r3-r11,pc}
00010a  e7ff              B        |L91.268|
                  |L91.268|
00010c  9800              LDR      r0,[sp,#0]            ;2025
00010e  f7fffffe          BL       OS_CPU_SR_Restore
000112  2042              MOVS     r0,#0x42              ;2026
000114  e7f7              B        |L91.262|
;;;2028   	 	   	  		 			 	    		   		 		 	 	 			 	    		   	 			 	  	 		 				 		  			 		 					 	  	  		      		  	   		      		  	 		 	      		   		 		  	 		 	      		  		  		  
                          ENDP

000116  0000              DCW      0x0000
                  |L91.280|
                          DCD      OSTCBFreeList
                  |L91.284|
00011c  3f00              DCB      "?",0
00011e  00                DCB      0
00011f  00                DCB      0
                  |L91.288|
                          DCD      OSTCBPrioTbl
                  |L91.292|
                          DCD      OSTCBList
                  |L91.296|
                          DCD      OSRdyGrp
                  |L91.300|
                          DCD      OSRdyTbl
                  |L91.304|
                          DCD      OSTaskCtr

                          AREA ||i.OS_TaskIdle||, CODE, READONLY, ALIGN=2

                  OS_TaskIdle PROC
;;;1751   
;;;1752   void  OS_TaskIdle (void *p_arg)
000000  2400              MOVS     r4,#0
;;;1753   {
;;;1754   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1755       OS_CPU_SR  cpu_sr = 0u;
;;;1756   #endif
;;;1757   
;;;1758   
;;;1759   
;;;1760       p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
000002  bf00              NOP      
;;;1761       for (;;) {
000004  bf00              NOP      
                  |L92.6|
;;;1762           OS_ENTER_CRITICAL();
000006  f7fffffe          BL       OS_CPU_SR_Save
00000a  4604              MOV      r4,r0
;;;1763           OSIdleCtr++;
00000c  4805              LDR      r0,|L92.36|
00000e  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
000010  1c40              ADDS     r0,r0,#1
000012  4904              LDR      r1,|L92.36|
000014  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1764           OS_EXIT_CRITICAL();
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       OS_CPU_SR_Restore
;;;1765           OSTaskIdleHook();                        /* Call user definable HOOK                           */
00001c  f7fffffe          BL       OSTaskIdleHook
000020  e7f1              B        |L92.6|
;;;1766       }
;;;1767   }
;;;1768   /*$PAGE*/
                          ENDP

000022  0000              DCW      0x0000
                  |L92.36|
                          DCD      OSIdleCtr

                          AREA ||i.OS_TaskReturn||, CODE, READONLY, ALIGN=2

                  OS_TaskReturn PROC
;;;1203   
;;;1204   void  OS_TaskReturn (void)
000000  b510              PUSH     {r4,lr}
;;;1205   {
;;;1206       OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
000002  4804              LDR      r0,|L93.20|
000004  6800              LDR      r0,[r0,#0]  ; OSTCBCur
000006  f7fffffe          BL       OSTaskReturnHook
;;;1207   
;;;1208   #if OS_TASK_DEL_EN > 0u
;;;1209       (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
00000a  20ff              MOVS     r0,#0xff
00000c  f7fffffe          BL       OSTaskDel
;;;1210   #else
;;;1211       for (;;) {
;;;1212           OSTimeDly(OS_TICKS_PER_SEC);
;;;1213       }
;;;1214   #endif
;;;1215   }
000010  bd10              POP      {r4,pc}
;;;1216   
                          ENDP

000012  0000              DCW      0x0000
                  |L93.20|
                          DCD      OSTCBCur

                          AREA ||i.OS_TaskStat||, CODE, READONLY, ALIGN=2

                  OS_TaskStat PROC
;;;1793   #if OS_TASK_STAT_EN > 0u
;;;1794   void  OS_TaskStat (void *p_arg)
000000  2400              MOVS     r4,#0
;;;1795   {
;;;1796   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1797       OS_CPU_SR  cpu_sr = 0u;
;;;1798   #endif
;;;1799   
;;;1800   
;;;1801   
;;;1802       p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
000002  bf00              NOP      
;;;1803       while (OSStatRdy == OS_FALSE) {
000004  e002              B        |L94.12|
                  |L94.6|
;;;1804           OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
000006  2028              MOVS     r0,#0x28
000008  f7fffffe          BL       OSTimeDly
                  |L94.12|
00000c  4819              LDR      r0,|L94.116|
00000e  7800              LDRB     r0,[r0,#0]            ;1803  ; OSStatRdy
000010  2800              CMP      r0,#0                 ;1803
000012  d0f8              BEQ      |L94.6|
;;;1805       }
;;;1806       OSIdleCtrMax /= 100uL;
000014  4818              LDR      r0,|L94.120|
000016  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
000018  2164              MOVS     r1,#0x64
00001a  fbb0f0f1          UDIV     r0,r0,r1
00001e  4916              LDR      r1,|L94.120|
000020  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1807       if (OSIdleCtrMax == 0uL) {
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
000026  b928              CBNZ     r0,|L94.52|
;;;1808           OSCPUUsage = 0u;
000028  2000              MOVS     r0,#0
00002a  4914              LDR      r1,|L94.124|
00002c  7008              STRB     r0,[r1,#0]
;;;1809   #if OS_TASK_SUSPEND_EN > 0u
;;;1810           (void)OSTaskSuspend(OS_PRIO_SELF);
00002e  20ff              MOVS     r0,#0xff
000030  f7fffffe          BL       OSTaskSuspend
                  |L94.52|
;;;1811   #else
;;;1812           for (;;) {
;;;1813               OSTimeDly(OS_TICKS_PER_SEC);
;;;1814           }
;;;1815   #endif
;;;1816       }
;;;1817       for (;;) {
000034  bf00              NOP      
                  |L94.54|
;;;1818           OS_ENTER_CRITICAL();
000036  f7fffffe          BL       OS_CPU_SR_Save
00003a  4604              MOV      r4,r0
;;;1819           OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
00003c  4810              LDR      r0,|L94.128|
00003e  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
000040  4910              LDR      r1,|L94.132|
000042  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1820           OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
000044  2000              MOVS     r0,#0
000046  490e              LDR      r1,|L94.128|
000048  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1821           OS_EXIT_CRITICAL();
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       OS_CPU_SR_Restore
;;;1822           OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
000050  480c              LDR      r0,|L94.132|
000052  6800              LDR      r0,[r0,#0]  ; OSIdleCtrRun
000054  4908              LDR      r1,|L94.120|
000056  6809              LDR      r1,[r1,#0]  ; OSIdleCtrMax
000058  fbb0f0f1          UDIV     r0,r0,r1
00005c  f1c00064          RSB      r0,r0,#0x64
000060  4906              LDR      r1,|L94.124|
000062  7008              STRB     r0,[r1,#0]
;;;1823           OSTaskStatHook();                        /* Invoke user definable hook                         */
000064  f7fffffe          BL       OSTaskStatHook
;;;1824   #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;1825           OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
000068  f7fffffe          BL       OS_TaskStatStkChk
;;;1826   #endif
;;;1827           OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
00006c  2014              MOVS     r0,#0x14
00006e  f7fffffe          BL       OSTimeDly
000072  e7e0              B        |L94.54|
;;;1828       }
;;;1829   }
;;;1830   #endif
                          ENDP

                  |L94.116|
                          DCD      OSStatRdy
                  |L94.120|
                          DCD      OSIdleCtrMax
                  |L94.124|
                          DCD      OSCPUUsage
                  |L94.128|
                          DCD      OSIdleCtr
                  |L94.132|
                          DCD      OSIdleCtrRun

                          AREA ||i.OS_TaskStatStkChk||, CODE, READONLY, ALIGN=2

                  OS_TaskStatStkChk PROC
;;;1844   #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;1845   void  OS_TaskStatStkChk (void)
000000  b57c              PUSH     {r2-r6,lr}
;;;1846   {
;;;1847       OS_TCB      *ptcb;
;;;1848       OS_STK_DATA  stk_data;
;;;1849       INT8U        err;
;;;1850       INT8U        prio;
;;;1851   
;;;1852   
;;;1853       for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
000002  2500              MOVS     r5,#0
000004  e014              B        |L95.48|
                  |L95.6|
;;;1854           err = OSTaskStkChk(prio, &stk_data);
000006  4669              MOV      r1,sp
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       OSTaskStkChk
00000e  4606              MOV      r6,r0
;;;1855           if (err == OS_ERR_NONE) {
000010  b966              CBNZ     r6,|L95.44|
;;;1856               ptcb = OSTCBPrioTbl[prio];
000012  4809              LDR      r0,|L95.56|
000014  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;1857               if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
000018  b144              CBZ      r4,|L95.44|
;;;1858                   if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
00001a  2c01              CMP      r4,#1
00001c  d006              BEQ      |L95.44|
;;;1859   #if OS_TASK_PROFILE_EN > 0u
;;;1860                       #if OS_STK_GROWTH == 1u
;;;1861                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
00001e  e9d40102          LDRD     r0,r1,[r4,#8]
000022  eb000081          ADD      r0,r0,r1,LSL #2
000026  6460              STR      r0,[r4,#0x44]
;;;1862                       #else
;;;1863                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
;;;1864                       #endif
;;;1865                       ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
000028  9801              LDR      r0,[sp,#4]
00002a  64a0              STR      r0,[r4,#0x48]
                  |L95.44|
00002c  1c68              ADDS     r0,r5,#1              ;1853
00002e  b2c5              UXTB     r5,r0                 ;1853
                  |L95.48|
000030  2d3f              CMP      r5,#0x3f              ;1853
000032  d9e8              BLS      |L95.6|
;;;1866   #endif
;;;1867                   }
;;;1868               }
;;;1869           }
;;;1870       }
;;;1871   }
000034  bd7c              POP      {r2-r6,pc}
;;;1872   #endif
                          ENDP

000036  0000              DCW      0x0000
                  |L95.56|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OS_TaskStkClr||, CODE, READONLY, ALIGN=1

                  OS_TaskStkClr PROC
;;;1240   #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;1241   void  OS_TaskStkClr (OS_STK  *pbos,
000000  f0020301          AND      r3,r2,#1
;;;1242                        INT32U   size,
;;;1243                        INT16U   opt)
;;;1244   {
;;;1245       if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
000004  b143              CBZ      r3,|L96.24|
;;;1246           if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
000006  f0020302          AND      r3,r2,#2
00000a  b12b              CBZ      r3,|L96.24|
;;;1247   #if OS_STK_GROWTH == 1u
;;;1248               while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
00000c  e002              B        |L96.20|
                  |L96.14|
;;;1249                   size--;
00000e  1e49              SUBS     r1,r1,#1
;;;1250                   *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
000010  2300              MOVS     r3,#0
000012  c008              STM      r0!,{r3}
                  |L96.20|
000014  2900              CMP      r1,#0                 ;1248
000016  d1fa              BNE      |L96.14|
                  |L96.24|
;;;1251               }
;;;1252   #else
;;;1253               while (size > 0u) {                        /* Stack grows from LOW to HIGH memory          */
;;;1254                   size--;
;;;1255                   *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
;;;1256               }
;;;1257   #endif
;;;1258           }
;;;1259       }
;;;1260   }
000018  4770              BX       lr
;;;1261   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  OSEventTbl
                          %        200
                  OSFlagTbl
                          %        80
                  OSTaskStatStk
                          %        512
                  OSTaskIdleStk
                          %        512
                  OSTCBPrioTbl
                          %        256
                  OSTCBTbl
                          %        1008
                  OSQTbl
                          %        120

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OSUnMapTbl
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  OSCtxSwCtr
                          DCD      0x00000000
                  OSEventFreeList
                          DCD      0x00000000
                  OSFlagFreeList
                          DCD      0x00000000
                  OSCPUUsage
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  OSIdleCtrMax
                          DCD      0x00000000
                  OSIdleCtrRun
                          DCD      0x00000000
                  OSStatRdy
000018  00                DCB      0x00
                  OSIntNesting
000019  00                DCB      0x00
                  OSLockNesting
00001a  00                DCB      0x00
                  OSPrioCur
00001b  00                DCB      0x00
                  OSPrioHighRdy
00001c  00                DCB      0x00
                  OSRdyGrp
00001d  00                DCB      0x00
                  OSRdyTbl
00001e  0000              DCB      0x00,0x00
                          DCD      0x00000000
000024  0000              DCB      0x00,0x00
                  OSRunning
000026  00                DCB      0x00
                  OSTaskCtr
000027  00                DCB      0x00
                  OSIdleCtr
                          DCD      0x00000000
                  OSTCBCur
                          DCD      0x00000000
                  OSTCBFreeList
                          DCD      0x00000000
                  OSTCBHighRdy
                          DCD      0x00000000
                  OSTCBList
                          DCD      0x00000000
                  OSTickStepState
00003c  00000000          DCB      0x00,0x00,0x00,0x00
                  OSQFreeList
                          DCD      0x00000000
                  OSTime
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\UCOSII\\CORE\\ucos_ii.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_ucos_ii_c_057ac61b____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_ucos_ii_c_057ac61b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_ucos_ii_c_057ac61b____REVSH|
#line 144
|__asm___9_ucos_ii_c_057ac61b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
