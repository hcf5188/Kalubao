; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=..\obj\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\SYSTEM -I..\USER -I..\LIB\inc -I..\UCOSII\CONFIG -I..\UCOSII\PORT -I..\UCOSII\CORE -I..\HAEDWARE -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\usart.crf ..\SYSTEM\usart.c]
                          THUMB

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;129    
;;;130    void USART1_IRQHandler(void)                	//串口1中断服务程序
000000  b510              PUSH     {r4,lr}
;;;131    	{
;;;132    	u8 Res;
;;;133    #if SYSTEM_SUPPORT_OS 		//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.
;;;134    	OSIntEnter();    
000002  f7fffffe          BL       OSIntEnter
;;;135    #endif
;;;136    	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)
000006  f2405125          MOV      r1,#0x525
00000a  481e              LDR      r0,|L1.132|
00000c  f7fffffe          BL       USART_GetITStatus
000010  b310              CBZ      r0,|L1.88|
;;;137    		{
;;;138    		Res =USART_ReceiveData(USART1);	//读取接收到的数据
000012  481c              LDR      r0,|L1.132|
000014  f7fffffe          BL       USART_ReceiveData
000018  b2c4              UXTB     r4,r0
;;;139    		
;;;140    		if((USART_RX_STA&0x8000)==0)//接收未完成
00001a  481b              LDR      r0,|L1.136|
00001c  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00001e  f4004000          AND      r0,r0,#0x8000
000022  b9c8              CBNZ     r0,|L1.88|
;;;141    			{
;;;142    			if(USART_RX_STA&0x4000)//接收到了0x0d
000024  4818              LDR      r0,|L1.136|
000026  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000028  f4004080          AND      r0,r0,#0x4000
00002c  b160              CBZ      r0,|L1.72|
;;;143    				{
;;;144    				if(Res!=0x0a)USART_RX_STA=0;//接收错误,重新开始
00002e  2c0a              CMP      r4,#0xa
000030  d003              BEQ      |L1.58|
000032  2000              MOVS     r0,#0
000034  4914              LDR      r1,|L1.136|
000036  8008              STRH     r0,[r1,#0]
000038  e020              B        |L1.124|
                  |L1.58|
;;;145    				else USART_RX_STA|=0x8000;	//接收完成了 
00003a  4813              LDR      r0,|L1.136|
00003c  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00003e  f4404000          ORR      r0,r0,#0x8000
000042  4911              LDR      r1,|L1.136|
000044  8008              STRH     r0,[r1,#0]
000046  e019              B        |L1.124|
                  |L1.72|
;;;146    				}
;;;147    			else //还没收到0X0D
;;;148    				{	
;;;149    				if(Res==0x0d)USART_RX_STA|=0x4000;
000048  2c0d              CMP      r4,#0xd
00004a  d106              BNE      |L1.90|
00004c  480e              LDR      r0,|L1.136|
00004e  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000050  f4404080          ORR      r0,r0,#0x4000
000054  490c              LDR      r1,|L1.136|
000056  8008              STRH     r0,[r1,#0]
                  |L1.88|
000058  e010              B        |L1.124|
                  |L1.90|
;;;150    				else
;;;151    					{
;;;152    					USART_RX_BUF[USART_RX_STA&0X3FFF]=Res ;
00005a  480b              LDR      r0,|L1.136|
00005c  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00005e  f3c0000d          UBFX     r0,r0,#0,#14
000062  490a              LDR      r1,|L1.140|
000064  540c              STRB     r4,[r1,r0]
;;;153    					USART_RX_STA++;
000066  4808              LDR      r0,|L1.136|
000068  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00006a  1c40              ADDS     r0,r0,#1
00006c  4906              LDR      r1,|L1.136|
00006e  8008              STRH     r0,[r1,#0]
;;;154    					if(USART_RX_STA>(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收	  
000070  4608              MOV      r0,r1
000072  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000074  28c7              CMP      r0,#0xc7
000076  dd01              BLE      |L1.124|
000078  2000              MOVS     r0,#0
00007a  8008              STRH     r0,[r1,#0]
                  |L1.124|
;;;155    					}		 
;;;156    				}
;;;157    			}   		 
;;;158         } 
;;;159    #if SYSTEM_SUPPORT_OS 	//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.
;;;160    	OSIntExit();  											 
00007c  f7fffffe          BL       OSIntExit
;;;161    #endif
;;;162    } 
000080  bd10              POP      {r4,pc}
;;;163    #endif	
                          ENDP

000082  0000              DCW      0x0000
                  |L1.132|
                          DCD      0x40013800
                  |L1.136|
                          DCD      USART_RX_STA
                  |L1.140|
                          DCD      USART_RX_BUF

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;52     //重定义fputc函数 
;;;53     int fputc(int ch, FILE *f)
000000  bf00              NOP      
                  |L2.2|
;;;54     {      
;;;55     	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
000002  4a05              LDR      r2,|L2.24|
000004  8812              LDRH     r2,[r2,#0]
000006  f0020240          AND      r2,r2,#0x40
00000a  2a00              CMP      r2,#0
00000c  d0f9              BEQ      |L2.2|
;;;56         USART1->DR = (u8) ch;      
00000e  b2c2              UXTB     r2,r0
000010  4b01              LDR      r3,|L2.24|
000012  1d1b              ADDS     r3,r3,#4
000014  801a              STRH     r2,[r3,#0]
;;;57     	return ch;
;;;58     }
000016  4770              BX       lr
;;;59     #endif 
                          ENDP

                  |L2.24|
                          DCD      0x40013800

                          AREA ||i.uart_init||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;88       
;;;89     void uart_init(u32 bound){
000000  b510              PUSH     {r4,lr}
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;90       //GPIO端口设置
;;;91       GPIO_InitTypeDef GPIO_InitStructure;
;;;92     	USART_InitTypeDef USART_InitStructure;
;;;93     	NVIC_InitTypeDef NVIC_InitStructure;
;;;94     	 
;;;95     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);	//使能USART1，GPIOA时钟
000006  2101              MOVS     r1,#1
000008  f2440004          MOV      r0,#0x4004
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;96       
;;;97     	//USART1_TX   GPIOA.9
;;;98       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9
000010  f44f7000          MOV      r0,#0x200
000014  f8ad0014          STRH     r0,[sp,#0x14]
;;;99       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
00001a  f88d0016          STRB     r0,[sp,#0x16]
;;;100      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
00001e  2018              MOVS     r0,#0x18
000020  f88d0017          STRB     r0,[sp,#0x17]
;;;101      GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.9
000024  a905              ADD      r1,sp,#0x14
000026  481c              LDR      r0,|L3.152|
000028  f7fffffe          BL       GPIO_Init
;;;102       
;;;103      //USART1_RX	  GPIOA.10初始化
;;;104      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10
00002c  f44f6080          MOV      r0,#0x400
000030  f8ad0014          STRH     r0,[sp,#0x14]
;;;105      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
000034  2004              MOVS     r0,#4
000036  f88d0017          STRB     r0,[sp,#0x17]
;;;106      GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.10  
00003a  a905              ADD      r1,sp,#0x14
00003c  4816              LDR      r0,|L3.152|
00003e  f7fffffe          BL       GPIO_Init
;;;107    
;;;108      //Usart1 NVIC 配置
;;;109      NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000042  2025              MOVS     r0,#0x25
000044  f88d0000          STRB     r0,[sp,#0]
;;;110    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3
000048  2003              MOVS     r0,#3
00004a  f88d0001          STRB     r0,[sp,#1]
;;;111    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;		//子优先级3
00004e  f88d0002          STRB     r0,[sp,#2]
;;;112    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
000052  2001              MOVS     r0,#1
000054  f88d0003          STRB     r0,[sp,#3]
;;;113    	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
000058  4668              MOV      r0,sp
00005a  f7fffffe          BL       NVIC_Init
;;;114      
;;;115       //USART 初始化设置
;;;116    
;;;117    	USART_InitStructure.USART_BaudRate = bound;//串口波特率
00005e  9401              STR      r4,[sp,#4]
;;;118    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
000060  2000              MOVS     r0,#0
000062  f8ad0008          STRH     r0,[sp,#8]
;;;119    	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
000066  f8ad000a          STRH     r0,[sp,#0xa]
;;;120    	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
00006a  f8ad000c          STRH     r0,[sp,#0xc]
;;;121    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
00006e  f8ad0010          STRH     r0,[sp,#0x10]
;;;122    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000072  200c              MOVS     r0,#0xc
000074  f8ad000e          STRH     r0,[sp,#0xe]
;;;123    
;;;124      USART_Init(USART1, &USART_InitStructure); //初始化串口1
000078  a901              ADD      r1,sp,#4
00007a  4808              LDR      r0,|L3.156|
00007c  f7fffffe          BL       USART_Init
;;;125      USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断
000080  2201              MOVS     r2,#1
000082  f2405125          MOV      r1,#0x525
000086  4805              LDR      r0,|L3.156|
000088  f7fffffe          BL       USART_ITConfig
;;;126      USART_Cmd(USART1, ENABLE);                    //使能串口1 
00008c  2101              MOVS     r1,#1
00008e  4803              LDR      r0,|L3.156|
000090  f7fffffe          BL       USART_Cmd
;;;127    
;;;128    }
000094  b006              ADD      sp,sp,#0x18
000096  bd10              POP      {r4,pc}
;;;129    
                          ENDP

                  |L3.152|
                          DCD      0x40010800
                  |L3.156|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USART_RX_BUF
                          %        200

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
                  USART_RX_STA
000004  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\SYSTEM\\usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_fputc____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_usart_c_fputc____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_fputc____REVSH|
#line 144
|__asm___7_usart_c_fputc____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
